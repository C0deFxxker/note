{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/favicon.ico","path":"images/favicon.ico","modified":0,"renderable":0},{"_id":"source/images/k8s-security.jpg","path":"images/k8s-security.jpg","modified":0,"renderable":0},{"_id":"source/images/ceph.png","path":"images/ceph.png","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1566631144000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1566631144000},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1566631144000},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1566631144000},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1566631144000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1566631144000},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1566631144000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1566631144000},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1566631144000},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1566631144000},{"_id":"themes/next/README.cn.md","hash":"263b74f1ac7c0f6f9424b8cced4b0b320ae61efc","modified":1566631144000},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1566631144000},{"_id":"themes/next/_config.yml","hash":"36bb65c3144fd4afc587cfdfe60787e9d644db8a","modified":1566633769000},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1566631144000},{"_id":"themes/next/README.md","hash":"287c7e6b7a6ddf75d815dda0df8bd228e3f285c5","modified":1566631144000},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1566631144000},{"_id":"source/_drafts/DRF算法.md","hash":"0ea33855e8481d1882d5bd221fe9c885497dc236","modified":1566804636000},{"_id":"source/_drafts/PCA.md","hash":"a091e3c6398719396676281b5cc0fd369626b37c","modified":1528416232000},{"_id":"source/_drafts/ceph.md","hash":"1ab91180f99cd5ced09a5e6f1cc59e1a92de3457","modified":1579502607363},{"_id":"source/_drafts/docker-privileged.md","hash":"aec60595a843c82f4e1b357d6cea95817a85be30","modified":1572507404000},{"_id":"source/_drafts/etcd.md","hash":"035b04c8b0fda6d34279de5339b0e04c90471e3e","modified":1572252690000},{"_id":"source/_drafts/k8s-daemonset.md","hash":"2c26faff628a3f9f394a1645709875b3b699c049","modified":1572488711000},{"_id":"source/_drafts/k8s-ca.md","hash":"0a18efb23afddf478845cc6e449e3e41e90ed30f","modified":1572488688000},{"_id":"source/_drafts/k8s-deploy.md","hash":"b26138a187dd18c95a36de7daec452d0037f65e9","modified":1567685476000},{"_id":"source/_drafts/k8s-kubeconfig.md","hash":"b21e7f6ef322218c1eacca365755d58202f6a53d","modified":1566971020000},{"_id":"source/_drafts/k8s-pod.md","hash":"37bd947f47c300cc0a1374a1971beefd687079c5","modified":1571314682000},{"_id":"source/_drafts/k8s-serviceAccount.md","hash":"331fedbb823dfc43ff7d971e667fe23becef21c6","modified":1580783549868},{"_id":"source/_drafts/k8s-storage.md","hash":"2a6b06595389b0c61981f5e9ae2ad8c8bff4e66a","modified":1578375407000},{"_id":"source/_drafts/k8s-容器主从模式.md","hash":"c6438dabf2ed6d9660e430bb2a559f52a2b7a267","modified":1574305477000},{"_id":"source/_drafts/k8s基本概念.md","hash":"b173c00ccee7607a3b28e18156fe23bbe03ad182","modified":1578972861000},{"_id":"source/_drafts/rook-ceph.md","hash":"4f0d5673aa64329791f6ce733564651e4965bf6d","modified":1578293868000},{"_id":"source/_drafts/决策树.md","hash":"482aab81fdc42c26ce6cbb6d4755b653fe98f7a0","modified":1528416223000},{"_id":"source/_drafts/分布式训练.md","hash":"7aacf28e1e9fce07771ac7dd6fe037f7a05ed0f9","modified":1569727388000},{"_id":"source/_drafts/支持向量机.md","hash":"568934f95037918c73209cadb9b02cdecbf45ecc","modified":1528416226000},{"_id":"source/_drafts/贝叶斯分类.md","hash":"51ce568f483ead89818ec7d3eab22e7504e9ddcb","modified":1528416218000},{"_id":"source/_posts/ceph安装.md","hash":"51f381cfe461bf311502f1ce2e8bbeb5b1ee75b4","modified":1580783405363},{"_id":"source/images/favicon.ico","hash":"b80be58b35a4537e0ce0277e939e333d1aa67518","modified":1566632368000},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1566631144000},{"_id":"themes/next/.git/config","hash":"bf7d1df65cf34d0f25a7184a58c37a09f72e4be7","modified":1566631144000},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1566631083000},{"_id":"themes/next/.git/index","hash":"38f729eed5fa9abc06fa9f5dc26b0d2ddf4348a7","modified":1566631144000},{"_id":"themes/next/.git/packed-refs","hash":"3bb2e8e3fad44742d3e3bfadfb0b4d791fe9fe9e","modified":1566631144000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1566631144000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"50d48c47162817a3810a9d9ad51104e83947419a","modified":1566631144000},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1566631144000},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1566631144000},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1566631144000},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1566631144000},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1566631144000},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1566631144000},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1566631144000},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1566631144000},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1566631144000},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1566631144000},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1566631144000},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1566631144000},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1566631144000},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1566631144000},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1566631144000},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1566631144000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1566631144000},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1566631144000},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1566631144000},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1566631144000},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1566631144000},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1566631144000},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1566631144000},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1566631144000},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1566631144000},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1566631144000},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1566631144000},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1566631144000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1566631144000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1566631144000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1566631144000},{"_id":"source/images/k8s-security.jpg","hash":"890c67a0744a5109f62bf5422904c559bbc4fda0","modified":1574505824000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1566631144000},{"_id":"source/images/ceph.png","hash":"8170ea83c9389bf8f5ca801683512c58ea953361","modified":1580783206858},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1566631083000},{"_id":"themes/next/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1566631083000},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1566631083000},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1566631083000},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"33729ad4ce51acda35094e581e4088f3167a0af8","modified":1566631083000},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1566631083000},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1566631083000},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1566631083000},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1566631083000},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1566631083000},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1566631083000},{"_id":"themes/next/.git/logs/HEAD","hash":"8dce4b898dce1a4d64697bd014e04272df099f83","modified":1566631144000},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1566631083000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1566631144000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1566631144000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1566631144000},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1566631144000},{"_id":"themes/next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1566631144000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1566631144000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1566631144000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1566631144000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1566631144000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1566631144000},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1566631144000},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1566631144000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1566631144000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1566631144000},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1566631144000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1566631144000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1566631144000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1566631144000},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1566631144000},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1566631144000},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1566631144000},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1566631144000},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1566631144000},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1566631144000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1566631144000},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1566631144000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1566631144000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1566631144000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1566631144000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1566631144000},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1566631144000},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1566631144000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1566631144000},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1566631144000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1566631144000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1566631144000},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1566631144000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1566631144000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1566631144000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1566631144000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1566631144000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1566631144000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1566631144000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1566631144000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1566631144000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1566631144000},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1566631144000},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1566631144000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1566631144000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1566631144000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1566631144000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1566631144000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1566631144000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1566631144000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1566631144000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1566631144000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1566631144000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1566631144000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1566631144000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1566631144000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1566631144000},{"_id":"themes/next/.git/refs/heads/master","hash":"3c959678e3fe6e51e935526c19927d21443a3be3","modified":1566631144000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1566631144000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1566631144000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1566631144000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1566631144000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1566631144000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1566631144000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1566631144000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1566631144000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1566631144000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1566631144000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1566631144000},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1566631144000},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1566631144000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1566631144000},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1566631144000},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1566631144000},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1566631144000},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1566631144000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1566631144000},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1566631144000},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1566631144000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1566631144000},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1566631144000},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1566631144000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1566631144000},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1566631144000},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1566631144000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1566631144000},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1566631144000},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1566631144000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1566631144000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1566631144000},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1566631144000},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1566631144000},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1566631144000},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1566631144000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1566631144000},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1566631144000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1566631144000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1566631144000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1566631144000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1566631144000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1566631144000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1566631144000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1566631144000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1566631144000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1566631144000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1566631144000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1566631144000},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1566631144000},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1566631144000},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1566631144000},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1566631144000},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1566631144000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1566631144000},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1566631144000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1566631144000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1566631144000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1566631144000},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1566631144000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1566631144000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1566631144000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1566631144000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1566631144000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1566631144000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1566631144000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1566631144000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1566631144000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1566631144000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1566631144000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1566631144000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1566631144000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1566631144000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1566631144000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1566631144000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1566631144000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1566631144000},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1566631144000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1566631144000},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1566631144000},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1566631144000},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1566631144000},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1566631144000},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1566631144000},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1566631144000},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1566631144000},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1566631144000},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1566631144000},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1566631144000},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1566631144000},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1566631144000},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1566631144000},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1566631144000},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1566631144000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1566631144000},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1566631144000},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1566631144000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1566631144000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1566631144000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1566631144000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1566631144000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1566631144000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1566631144000},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"8dce4b898dce1a4d64697bd014e04272df099f83","modified":1566631144000},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1566631144000},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1566631144000},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1566631144000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1566631144000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1566631144000},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1566631144000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1566631144000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1566631144000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1566631144000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1566631144000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1566631144000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1566631144000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1566631144000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1566631144000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1566631144000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1566631144000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1566631144000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1566631144000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1566631144000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1566631144000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1566631144000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1566631144000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1566631144000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1566631144000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1566631144000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1566631144000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1566631144000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1566631144000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1566631144000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1566631144000},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1566631144000},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1566631144000},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1566631144000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1566631144000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1566631144000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1566631144000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1566631144000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1566631144000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1566631144000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1566631144000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1566631144000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1566631144000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1566631144000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1566631144000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1566631144000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1566631144000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1566631144000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1566631144000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1566631144000},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1566631144000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1566631144000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1566631144000},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"8dce4b898dce1a4d64697bd014e04272df099f83","modified":1566631144000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1566631144000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1566631144000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1566631144000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1566631144000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1566631144000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1566631144000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1566631144000},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1566631144000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1566631144000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1566631144000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1566631144000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1566631144000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1566631144000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1566631144000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1566631144000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1566631144000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1566631144000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1566631144000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1566631144000},{"_id":"themes/next/.git/objects/pack/pack-2094ec0f6437d1788a13f0aec9c47f4ed1a77de3.idx","hash":"6507e0cdf986f371d6d304387f789444a7663c56","modified":1566631144000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1566631144000},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1566631144000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1566631144000},{"_id":"themes/next/.git/objects/pack/pack-2094ec0f6437d1788a13f0aec9c47f4ed1a77de3.pack","hash":"2ab7a76d496119b851249983db6b500a45c77c47","modified":1566631144000},{"_id":"public/archives/index.html","hash":"44422ee5a30a17631e8a0be9219b22e6af0f8d91","modified":1580783780079},{"_id":"public/archives/2020/index.html","hash":"1783c5746ac96faf75b6a5a3250b2394d914d29e","modified":1580783780079},{"_id":"public/archives/2020/02/index.html","hash":"6a81d80276cec32845d4571d3273b5d7633c6cf2","modified":1580783780080},{"_id":"public/categories/Ceph/index.html","hash":"ba9f4061ebb086b6cbd3cedb02cf25b9356695c2","modified":1580783780080},{"_id":"public/index.html","hash":"55dbe06f1df91bd4bdce0217ca5372edcfb6f1d9","modified":1580783780080},{"_id":"public/2020/02/04/ceph安装/index.html","hash":"5b52c638b422e4a16c57df3a1519e4fb2f623bfb","modified":1580783609194},{"_id":"public/images/favicon.ico","hash":"b80be58b35a4537e0ce0277e939e333d1aa67518","modified":1580783780083},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1580783780084},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1580783780084},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1580783780084},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1580783780084},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1580783780084},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1580783780084},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1580783780084},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1580783780084},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1580783780084},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1580783780084},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1580783780084},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1580783780084},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1580783780084},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1580783780084},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1580783780084},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1580783780084},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1580783780084},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1580783780084},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1580783780084},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1580783780084},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1580783780084},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1580783780084},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1580783780084},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1580783780084},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1580783780085},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1580783780085},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1580783780085},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1580783780085},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1580783780085},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1580783780085},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1580783780085},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1580783780085},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1580783780085},{"_id":"public/images/k8s-security.jpg","hash":"890c67a0744a5109f62bf5422904c559bbc4fda0","modified":1580783780409},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1580783780413},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1580783780421},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1580783780427},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1580783780427},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1580783780427},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1580783780427},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1580783780427},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1580783780427},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1580783780427},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1580783780427},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1580783780427},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1580783780427},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1580783780427},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1580783780427},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1580783780427},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1580783780427},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1580783780427},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1580783780427},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1580783780427},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1580783780427},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1580783780427},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1580783780427},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1580783780427},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1580783780427},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1580783780427},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1580783780428},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1580783780428},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1580783780428},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1580783780428},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1580783780428},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1580783780428},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1580783780428},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1580783780428},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1580783780428},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1580783780428},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1580783780428},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1580783780428},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1580783780428},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1580783780428},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1580783780428},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1580783780428},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1580783780428},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1580783780428},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1580783780428},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1580783780428},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1580783780428},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1580783780429},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1580783780429},{"_id":"public/lib/fastclick/README.html","hash":"c5a4c05ca80132b7e343d5fd1d1d1a976b4ad151","modified":1580783780429},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"81057e5b518b8ab60474e1ad027e868b558f15b7","modified":1580783780429},{"_id":"public/lib/jquery_lazyload/README.html","hash":"18a600ca1aafd3bf08af52b6a6fe5f056aeed9f4","modified":1580783780429},{"_id":"public/css/main.css","hash":"22be940e3a7ddb655fdffc327d40c7f7a61d1464","modified":1580783780429},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1580783780429},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1580783780429},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1580783780429},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1580783780429},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1580783780429},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1580783780429},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1580783780429},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1580783780429},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1580783780429},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1580783780429},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1580783780429},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1580783780429},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1580783780429},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1580783780429},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1580783780429},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1580783780429},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1580783780430},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1580783780430},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1580783780430},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1580783780430},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1580783780430},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1580783780430},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1580783780430},{"_id":"public/images/ceph.png","hash":"8170ea83c9389bf8f5ca801683512c58ea953361","modified":1580783780430},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1580783780439},{"_id":"source/_posts/ceph-1.md","hash":"f82d56bcec73d00839df6544a3a21048d9e4f8bb","modified":1580783769436},{"_id":"public/2020/02/04/ceph-1/index.html","hash":"5ac9ff2ac96b2de1e1c1d8c21a1bf6c8e85c0c68","modified":1580783780080}],"Category":[{"name":"算法","_id":"ck679mtrs0002lbmd3onpl9cz"},{"name":"Ceph","_id":"ck679mtrv0006lbmd04j9u7ky"},{"name":"docker","_id":"ck679mtrx000albmdoxu57uom"},{"name":"k8s","_id":"ck679mtry000elbmd4ymfxl64"}],"Data":[],"Page":[],"Post":[{"title":"DRF调度算法","mathjax":true,"_content":"\nDRF算法是 Dominant Resource Fairness 的简称，意思是主资源公平分配，它是多纬度资源分配算法。\n\n<!--more-->\n\n# Max-Min Fairness(MMFS)\n要介绍DRF算法前，不得不先介绍 Max-Min Fairness 算法，Max-Min Fairness 算法解决了单纬度资源公平分配的问题，而DRF算法则是基于 Max-Min Fairness 延伸出的多维度资源调度算法。\n\n该算法会为每个用户定义了最低资源要求(min)和资源上限(max)。如果每个用户提交任务的资源需求量还未达到上限，则照常分配任务即可。当某个用户提交任务的资源需求总量大于分配给该用户的资源上限时，我们需要使用 Max-Min Fairness 算法来调度其它空闲用户的资源暂时借给这个忙用户使用，从而提高集群资源使用率。\n\nMax-Min Fairness 算法资源分配遵循以下规则：\n\n* 分配资源顺序与资源申请的提交顺序一致。\n* 出现多个不能满足资源需求的用户时，分配给这些用户的资源量相等。\n* 用户获取到的资源不能大于该用户提交的资源需求量。\n\n* 单一资源公平性：对于单一资源，解决方案应降低到最大 - 最小公平性。\n* 瓶颈公平性：如果每个用户都有一个百分比要求的资源，那么解决方案应该降低到该资源的最大 - 最小公平性。\n* 人口单调性：当用户离开系统并放弃其资源时，其余用户的分配都不会减少。\n* 资源单调性：如果将更多资源添加到系统，则现有用户的任何分配都不应减少。\n\n假设把集群资源分配给\n\n# Dominant Resource Fairness(DRF)\n__主资源__指的是用户提出的资源需求占集群资源容量百分比最大的那个纬度的资源，不同用户的主资源纬度可能不一样。假设集群资源有4核CPU+12GB内存，有两个用户向集群申请资源，用户A申请\"1核CPU+6GB内存\"，用户B申请\"3核CPU+1GB内存\"，那么用户A来说主资源纬度就是内存，主资源值是6/12=0.5，用户B的主资源纬度是CPU，主资源值为1/4=0.25。先计算出各个用户资源申请的主资源值，然后直接对主资源值执行Max-Min Fairness算法就是DRF算法。\n\n# 参考文献\n* CSDN博文: https://blog.csdn.net/pelick/article/details/19326865\n* [Dominant Resource Fairness: Fair Allocation of Multiple Resource Types](http://static.usenix.org/event/nsdi11/tech/full_papers/Ghodsi.pdf)\n* [Computer Networks : Performance and Quality of Service](https://www.ece.rutgers.edu/~marsic/books/CN/book-CN_marsic.pdf) - 第五章","source":"_drafts/DRF算法.md","raw":"---\ntitle: \"DRF调度算法\"\ncategory: 算法\nmathjax: true\n---\n\nDRF算法是 Dominant Resource Fairness 的简称，意思是主资源公平分配，它是多纬度资源分配算法。\n\n<!--more-->\n\n# Max-Min Fairness(MMFS)\n要介绍DRF算法前，不得不先介绍 Max-Min Fairness 算法，Max-Min Fairness 算法解决了单纬度资源公平分配的问题，而DRF算法则是基于 Max-Min Fairness 延伸出的多维度资源调度算法。\n\n该算法会为每个用户定义了最低资源要求(min)和资源上限(max)。如果每个用户提交任务的资源需求量还未达到上限，则照常分配任务即可。当某个用户提交任务的资源需求总量大于分配给该用户的资源上限时，我们需要使用 Max-Min Fairness 算法来调度其它空闲用户的资源暂时借给这个忙用户使用，从而提高集群资源使用率。\n\nMax-Min Fairness 算法资源分配遵循以下规则：\n\n* 分配资源顺序与资源申请的提交顺序一致。\n* 出现多个不能满足资源需求的用户时，分配给这些用户的资源量相等。\n* 用户获取到的资源不能大于该用户提交的资源需求量。\n\n* 单一资源公平性：对于单一资源，解决方案应降低到最大 - 最小公平性。\n* 瓶颈公平性：如果每个用户都有一个百分比要求的资源，那么解决方案应该降低到该资源的最大 - 最小公平性。\n* 人口单调性：当用户离开系统并放弃其资源时，其余用户的分配都不会减少。\n* 资源单调性：如果将更多资源添加到系统，则现有用户的任何分配都不应减少。\n\n假设把集群资源分配给\n\n# Dominant Resource Fairness(DRF)\n__主资源__指的是用户提出的资源需求占集群资源容量百分比最大的那个纬度的资源，不同用户的主资源纬度可能不一样。假设集群资源有4核CPU+12GB内存，有两个用户向集群申请资源，用户A申请\"1核CPU+6GB内存\"，用户B申请\"3核CPU+1GB内存\"，那么用户A来说主资源纬度就是内存，主资源值是6/12=0.5，用户B的主资源纬度是CPU，主资源值为1/4=0.25。先计算出各个用户资源申请的主资源值，然后直接对主资源值执行Max-Min Fairness算法就是DRF算法。\n\n# 参考文献\n* CSDN博文: https://blog.csdn.net/pelick/article/details/19326865\n* [Dominant Resource Fairness: Fair Allocation of Multiple Resource Types](http://static.usenix.org/event/nsdi11/tech/full_papers/Ghodsi.pdf)\n* [Computer Networks : Performance and Quality of Service](https://www.ece.rutgers.edu/~marsic/books/CN/book-CN_marsic.pdf) - 第五章","slug":"DRF算法","published":0,"date":"2020-01-16T17:23:25.488Z","updated":"2019-08-26T07:30:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck679mtrm0000lbmdtnm12o3z","content":"<p>DRF算法是 Dominant Resource Fairness 的简称，意思是主资源公平分配，它是多纬度资源分配算法。</p>\n<a id=\"more\"></a>\n\n<h1 id=\"Max-Min-Fairness-MMFS\"><a href=\"#Max-Min-Fairness-MMFS\" class=\"headerlink\" title=\"Max-Min Fairness(MMFS)\"></a>Max-Min Fairness(MMFS)</h1><p>要介绍DRF算法前，不得不先介绍 Max-Min Fairness 算法，Max-Min Fairness 算法解决了单纬度资源公平分配的问题，而DRF算法则是基于 Max-Min Fairness 延伸出的多维度资源调度算法。</p>\n<p>该算法会为每个用户定义了最低资源要求(min)和资源上限(max)。如果每个用户提交任务的资源需求量还未达到上限，则照常分配任务即可。当某个用户提交任务的资源需求总量大于分配给该用户的资源上限时，我们需要使用 Max-Min Fairness 算法来调度其它空闲用户的资源暂时借给这个忙用户使用，从而提高集群资源使用率。</p>\n<p>Max-Min Fairness 算法资源分配遵循以下规则：</p>\n<ul>\n<li><p>分配资源顺序与资源申请的提交顺序一致。</p>\n</li>\n<li><p>出现多个不能满足资源需求的用户时，分配给这些用户的资源量相等。</p>\n</li>\n<li><p>用户获取到的资源不能大于该用户提交的资源需求量。</p>\n</li>\n<li><p>单一资源公平性：对于单一资源，解决方案应降低到最大 - 最小公平性。</p>\n</li>\n<li><p>瓶颈公平性：如果每个用户都有一个百分比要求的资源，那么解决方案应该降低到该资源的最大 - 最小公平性。</p>\n</li>\n<li><p>人口单调性：当用户离开系统并放弃其资源时，其余用户的分配都不会减少。</p>\n</li>\n<li><p>资源单调性：如果将更多资源添加到系统，则现有用户的任何分配都不应减少。</p>\n</li>\n</ul>\n<p>假设把集群资源分配给</p>\n<h1 id=\"Dominant-Resource-Fairness-DRF\"><a href=\"#Dominant-Resource-Fairness-DRF\" class=\"headerlink\" title=\"Dominant Resource Fairness(DRF)\"></a>Dominant Resource Fairness(DRF)</h1><p><strong>主资源</strong>指的是用户提出的资源需求占集群资源容量百分比最大的那个纬度的资源，不同用户的主资源纬度可能不一样。假设集群资源有4核CPU+12GB内存，有两个用户向集群申请资源，用户A申请”1核CPU+6GB内存”，用户B申请”3核CPU+1GB内存”，那么用户A来说主资源纬度就是内存，主资源值是6/12=0.5，用户B的主资源纬度是CPU，主资源值为1/4=0.25。先计算出各个用户资源申请的主资源值，然后直接对主资源值执行Max-Min Fairness算法就是DRF算法。</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ul>\n<li>CSDN博文: <a href=\"https://blog.csdn.net/pelick/article/details/19326865\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/pelick/article/details/19326865</a></li>\n<li><a href=\"http://static.usenix.org/event/nsdi11/tech/full_papers/Ghodsi.pdf\" target=\"_blank\" rel=\"noopener\">Dominant Resource Fairness: Fair Allocation of Multiple Resource Types</a></li>\n<li><a href=\"https://www.ece.rutgers.edu/~marsic/books/CN/book-CN_marsic.pdf\" target=\"_blank\" rel=\"noopener\">Computer Networks : Performance and Quality of Service</a> - 第五章</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>DRF算法是 Dominant Resource Fairness 的简称，意思是主资源公平分配，它是多纬度资源分配算法。</p>","more":"<h1 id=\"Max-Min-Fairness-MMFS\"><a href=\"#Max-Min-Fairness-MMFS\" class=\"headerlink\" title=\"Max-Min Fairness(MMFS)\"></a>Max-Min Fairness(MMFS)</h1><p>要介绍DRF算法前，不得不先介绍 Max-Min Fairness 算法，Max-Min Fairness 算法解决了单纬度资源公平分配的问题，而DRF算法则是基于 Max-Min Fairness 延伸出的多维度资源调度算法。</p>\n<p>该算法会为每个用户定义了最低资源要求(min)和资源上限(max)。如果每个用户提交任务的资源需求量还未达到上限，则照常分配任务即可。当某个用户提交任务的资源需求总量大于分配给该用户的资源上限时，我们需要使用 Max-Min Fairness 算法来调度其它空闲用户的资源暂时借给这个忙用户使用，从而提高集群资源使用率。</p>\n<p>Max-Min Fairness 算法资源分配遵循以下规则：</p>\n<ul>\n<li><p>分配资源顺序与资源申请的提交顺序一致。</p>\n</li>\n<li><p>出现多个不能满足资源需求的用户时，分配给这些用户的资源量相等。</p>\n</li>\n<li><p>用户获取到的资源不能大于该用户提交的资源需求量。</p>\n</li>\n<li><p>单一资源公平性：对于单一资源，解决方案应降低到最大 - 最小公平性。</p>\n</li>\n<li><p>瓶颈公平性：如果每个用户都有一个百分比要求的资源，那么解决方案应该降低到该资源的最大 - 最小公平性。</p>\n</li>\n<li><p>人口单调性：当用户离开系统并放弃其资源时，其余用户的分配都不会减少。</p>\n</li>\n<li><p>资源单调性：如果将更多资源添加到系统，则现有用户的任何分配都不应减少。</p>\n</li>\n</ul>\n<p>假设把集群资源分配给</p>\n<h1 id=\"Dominant-Resource-Fairness-DRF\"><a href=\"#Dominant-Resource-Fairness-DRF\" class=\"headerlink\" title=\"Dominant Resource Fairness(DRF)\"></a>Dominant Resource Fairness(DRF)</h1><p><strong>主资源</strong>指的是用户提出的资源需求占集群资源容量百分比最大的那个纬度的资源，不同用户的主资源纬度可能不一样。假设集群资源有4核CPU+12GB内存，有两个用户向集群申请资源，用户A申请”1核CPU+6GB内存”，用户B申请”3核CPU+1GB内存”，那么用户A来说主资源纬度就是内存，主资源值是6/12=0.5，用户B的主资源纬度是CPU，主资源值为1/4=0.25。先计算出各个用户资源申请的主资源值，然后直接对主资源值执行Max-Min Fairness算法就是DRF算法。</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ul>\n<li>CSDN博文: <a href=\"https://blog.csdn.net/pelick/article/details/19326865\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/pelick/article/details/19326865</a></li>\n<li><a href=\"http://static.usenix.org/event/nsdi11/tech/full_papers/Ghodsi.pdf\" target=\"_blank\" rel=\"noopener\">Dominant Resource Fairness: Fair Allocation of Multiple Resource Types</a></li>\n<li><a href=\"https://www.ece.rutgers.edu/~marsic/books/CN/book-CN_marsic.pdf\" target=\"_blank\" rel=\"noopener\">Computer Networks : Performance and Quality of Service</a> - 第五章</li>\n</ul>"},{"_content":"<script type=\"text/javascript\" async src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML\"> </script>\n\n# 1. 向量内积含义\n向量： $(a_1,a_2,\\cdots,a_n)^T\\cdot(b_1,b_2,\\cdots,b_n)^T=a_1b_1+a_2b_2+\\cdots+a_nb_n$\n解释：$A \\cdot B=|A||B|cos(a)$\n\n设向量B的模为1，则A与B的内积值等于A向B所在直线投影的矢量长度。\n\n# 2. 基变换\n\n基是一个向量\n基是正交的（即内积为0，或直观说相互垂直）\n要求：线性无关\n\n变换：数据与第一个基做内积运算，结果作为第一个新的坐标分量，然后与第二个基做内积运算，结果作为第二个新坐标的分量\n\n如坐标点 $(3,2)$ 映射到基\n$$\n\\begin{pmatrix}\n   1/\\sqrt{2} & 1/\\sqrt{2} \\\\\\\\\n   -1/\\sqrt{2} & 1/\\sqrt{2}\n\\end{pmatrix}\n$$\n中的坐标为：\n$$\n\\begin{pmatrix}\n   1/\\sqrt{2} & 1/\\sqrt{2} \\\\\\\\\n   -1/\\sqrt{2} & 1/\\sqrt{2}\n\\end{pmatrix}\n\\begin{pmatrix}\n   3 \\\\\\\\\n   2\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n   5/\\sqrt{2} \\\\\\\\\n   -1/\\sqrt{2}\n\\end{pmatrix}\n$$\n\n# 3. PCA算法\n将一组N维向量降为K维（K大于0，小于N），目标是选择K个单位正交基，使原始数据变换到这组基上，各字段两两间协方差为0，字段的方差则尽可能大。\n\n设有两个特征维度的数据为：\n$$\nX = \\begin{pmatrix}\n   a_1 & a_2 & \\cdots & a_m \\\\\\\\\n   b_1 & b_2 & \\cdots & b_m\n\\end{pmatrix}\n$$\n\n对应的协方差矩阵：\n$$\n\\frac{1}{m} X X^T = \\begin{pmatrix}\n   \\frac{1}{m}\\sum^m_{i=1}a_i^2 & \\frac{1}{m}\\sum^m_{i=1}a_ib_i \\\\\\\\\n   \\frac{1}{m}\\sum^m_{i=1}a_ib_i & \\frac{1}{m}\\sum^m_{i=1}b_i^2\n\\end{pmatrix}\n$$\n\n矩阵对角线上的两个元素分别是两个字段的方差，而其它元素是a和b的协方差。\n\n实对称矩阵：一个n行n列的实对称矩阵一定可以找到n个单位正交特征向量。证明略。\n$$\nE = (e_1, e_2, \\cdots, e_n)\n$$\n\n实对称矩阵进行对角化：\n$$\nE^TCE=\\Lambda=\nX = \\begin{pmatrix}\n   \\lambda_1 & 0 & \\cdots & 0 \\\\\\\\\n   0 & \\lambda_2 & \\cdots & 0 \\\\\\\\\n    \\vdots & & \\ddots & \\vdots \\\\\\\\\n   0 & 0 & \\cdots & \\lambda_n\n\\end{pmatrix}\n$$\n\n根据特征值的从大到小，将特征向量从上到下排列，则用前K行组成的矩阵乘以原始数据矩阵X，就得到了我们需要的降维后的数据矩阵Y。","source":"_drafts/PCA.md","raw":"<script type=\"text/javascript\" async src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML\"> </script>\n\n# 1. 向量内积含义\n向量： $(a_1,a_2,\\cdots,a_n)^T\\cdot(b_1,b_2,\\cdots,b_n)^T=a_1b_1+a_2b_2+\\cdots+a_nb_n$\n解释：$A \\cdot B=|A||B|cos(a)$\n\n设向量B的模为1，则A与B的内积值等于A向B所在直线投影的矢量长度。\n\n# 2. 基变换\n\n基是一个向量\n基是正交的（即内积为0，或直观说相互垂直）\n要求：线性无关\n\n变换：数据与第一个基做内积运算，结果作为第一个新的坐标分量，然后与第二个基做内积运算，结果作为第二个新坐标的分量\n\n如坐标点 $(3,2)$ 映射到基\n$$\n\\begin{pmatrix}\n   1/\\sqrt{2} & 1/\\sqrt{2} \\\\\\\\\n   -1/\\sqrt{2} & 1/\\sqrt{2}\n\\end{pmatrix}\n$$\n中的坐标为：\n$$\n\\begin{pmatrix}\n   1/\\sqrt{2} & 1/\\sqrt{2} \\\\\\\\\n   -1/\\sqrt{2} & 1/\\sqrt{2}\n\\end{pmatrix}\n\\begin{pmatrix}\n   3 \\\\\\\\\n   2\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n   5/\\sqrt{2} \\\\\\\\\n   -1/\\sqrt{2}\n\\end{pmatrix}\n$$\n\n# 3. PCA算法\n将一组N维向量降为K维（K大于0，小于N），目标是选择K个单位正交基，使原始数据变换到这组基上，各字段两两间协方差为0，字段的方差则尽可能大。\n\n设有两个特征维度的数据为：\n$$\nX = \\begin{pmatrix}\n   a_1 & a_2 & \\cdots & a_m \\\\\\\\\n   b_1 & b_2 & \\cdots & b_m\n\\end{pmatrix}\n$$\n\n对应的协方差矩阵：\n$$\n\\frac{1}{m} X X^T = \\begin{pmatrix}\n   \\frac{1}{m}\\sum^m_{i=1}a_i^2 & \\frac{1}{m}\\sum^m_{i=1}a_ib_i \\\\\\\\\n   \\frac{1}{m}\\sum^m_{i=1}a_ib_i & \\frac{1}{m}\\sum^m_{i=1}b_i^2\n\\end{pmatrix}\n$$\n\n矩阵对角线上的两个元素分别是两个字段的方差，而其它元素是a和b的协方差。\n\n实对称矩阵：一个n行n列的实对称矩阵一定可以找到n个单位正交特征向量。证明略。\n$$\nE = (e_1, e_2, \\cdots, e_n)\n$$\n\n实对称矩阵进行对角化：\n$$\nE^TCE=\\Lambda=\nX = \\begin{pmatrix}\n   \\lambda_1 & 0 & \\cdots & 0 \\\\\\\\\n   0 & \\lambda_2 & \\cdots & 0 \\\\\\\\\n    \\vdots & & \\ddots & \\vdots \\\\\\\\\n   0 & 0 & \\cdots & \\lambda_n\n\\end{pmatrix}\n$$\n\n根据特征值的从大到小，将特征向量从上到下排列，则用前K行组成的矩阵乘以原始数据矩阵X，就得到了我们需要的降维后的数据矩阵Y。","slug":"PCA","published":0,"date":"2020-01-23T07:05:52.988Z","updated":"2018-06-08T00:03:52.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ck679mtrq0001lbmdrhsstsud","content":"<script type=\"text/javascript\" async src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML\"> </script>\n\n<h1 id=\"1-向量内积含义\"><a href=\"#1-向量内积含义\" class=\"headerlink\" title=\"1. 向量内积含义\"></a>1. 向量内积含义</h1><p>向量： $(a_1,a_2,\\cdots,a_n)^T\\cdot(b_1,b_2,\\cdots,b_n)^T=a_1b_1+a_2b_2+\\cdots+a_nb_n$<br>解释：$A \\cdot B=|A||B|cos(a)$</p>\n<p>设向量B的模为1，则A与B的内积值等于A向B所在直线投影的矢量长度。</p>\n<h1 id=\"2-基变换\"><a href=\"#2-基变换\" class=\"headerlink\" title=\"2. 基变换\"></a>2. 基变换</h1><p>基是一个向量<br>基是正交的（即内积为0，或直观说相互垂直）<br>要求：线性无关</p>\n<p>变换：数据与第一个基做内积运算，结果作为第一个新的坐标分量，然后与第二个基做内积运算，结果作为第二个新坐标的分量</p>\n<p>如坐标点 $(3,2)$ 映射到基<br>$$<br>\\begin{pmatrix}<br>   1/\\sqrt{2} &amp; 1/\\sqrt{2} \\\\<br>   -1/\\sqrt{2} &amp; 1/\\sqrt{2}<br>\\end{pmatrix}<br>$$<br>中的坐标为：<br>$$<br>\\begin{pmatrix}<br>   1/\\sqrt{2} &amp; 1/\\sqrt{2} \\\\<br>   -1/\\sqrt{2} &amp; 1/\\sqrt{2}<br>\\end{pmatrix}<br>\\begin{pmatrix}<br>   3 \\\\<br>   2<br>\\end{pmatrix}<br>=<br>\\begin{pmatrix}<br>   5/\\sqrt{2} \\\\<br>   -1/\\sqrt{2}<br>\\end{pmatrix}<br>$$</p>\n<h1 id=\"3-PCA算法\"><a href=\"#3-PCA算法\" class=\"headerlink\" title=\"3. PCA算法\"></a>3. PCA算法</h1><p>将一组N维向量降为K维（K大于0，小于N），目标是选择K个单位正交基，使原始数据变换到这组基上，各字段两两间协方差为0，字段的方差则尽可能大。</p>\n<p>设有两个特征维度的数据为：<br>$$<br>X = \\begin{pmatrix}<br>   a_1 &amp; a_2 &amp; \\cdots &amp; a_m \\\\<br>   b_1 &amp; b_2 &amp; \\cdots &amp; b_m<br>\\end{pmatrix}<br>$$</p>\n<p>对应的协方差矩阵：<br>$$<br>\\frac{1}{m} X X^T = \\begin{pmatrix}<br>   \\frac{1}{m}\\sum^m_{i=1}a_i^2 &amp; \\frac{1}{m}\\sum^m_{i=1}a_ib_i \\\\<br>   \\frac{1}{m}\\sum^m_{i=1}a_ib_i &amp; \\frac{1}{m}\\sum^m_{i=1}b_i^2<br>\\end{pmatrix}<br>$$</p>\n<p>矩阵对角线上的两个元素分别是两个字段的方差，而其它元素是a和b的协方差。</p>\n<p>实对称矩阵：一个n行n列的实对称矩阵一定可以找到n个单位正交特征向量。证明略。<br>$$<br>E = (e_1, e_2, \\cdots, e_n)<br>$$</p>\n<p>实对称矩阵进行对角化：<br>$$<br>E^TCE=\\Lambda=<br>X = \\begin{pmatrix}<br>   \\lambda_1 &amp; 0 &amp; \\cdots &amp; 0 \\\\<br>   0 &amp; \\lambda_2 &amp; \\cdots &amp; 0 \\\\<br>    \\vdots &amp; &amp; \\ddots &amp; \\vdots \\\\<br>   0 &amp; 0 &amp; \\cdots &amp; \\lambda_n<br>\\end{pmatrix}<br>$$</p>\n<p>根据特征值的从大到小，将特征向量从上到下排列，则用前K行组成的矩阵乘以原始数据矩阵X，就得到了我们需要的降维后的数据矩阵Y。</p>\n","site":{"data":{}},"excerpt":"","more":"<script type=\"text/javascript\" async src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML\"> </script>\n\n<h1 id=\"1-向量内积含义\"><a href=\"#1-向量内积含义\" class=\"headerlink\" title=\"1. 向量内积含义\"></a>1. 向量内积含义</h1><p>向量： $(a_1,a_2,\\cdots,a_n)^T\\cdot(b_1,b_2,\\cdots,b_n)^T=a_1b_1+a_2b_2+\\cdots+a_nb_n$<br>解释：$A \\cdot B=|A||B|cos(a)$</p>\n<p>设向量B的模为1，则A与B的内积值等于A向B所在直线投影的矢量长度。</p>\n<h1 id=\"2-基变换\"><a href=\"#2-基变换\" class=\"headerlink\" title=\"2. 基变换\"></a>2. 基变换</h1><p>基是一个向量<br>基是正交的（即内积为0，或直观说相互垂直）<br>要求：线性无关</p>\n<p>变换：数据与第一个基做内积运算，结果作为第一个新的坐标分量，然后与第二个基做内积运算，结果作为第二个新坐标的分量</p>\n<p>如坐标点 $(3,2)$ 映射到基<br>$$<br>\\begin{pmatrix}<br>   1/\\sqrt{2} &amp; 1/\\sqrt{2} \\\\<br>   -1/\\sqrt{2} &amp; 1/\\sqrt{2}<br>\\end{pmatrix}<br>$$<br>中的坐标为：<br>$$<br>\\begin{pmatrix}<br>   1/\\sqrt{2} &amp; 1/\\sqrt{2} \\\\<br>   -1/\\sqrt{2} &amp; 1/\\sqrt{2}<br>\\end{pmatrix}<br>\\begin{pmatrix}<br>   3 \\\\<br>   2<br>\\end{pmatrix}<br>=<br>\\begin{pmatrix}<br>   5/\\sqrt{2} \\\\<br>   -1/\\sqrt{2}<br>\\end{pmatrix}<br>$$</p>\n<h1 id=\"3-PCA算法\"><a href=\"#3-PCA算法\" class=\"headerlink\" title=\"3. PCA算法\"></a>3. PCA算法</h1><p>将一组N维向量降为K维（K大于0，小于N），目标是选择K个单位正交基，使原始数据变换到这组基上，各字段两两间协方差为0，字段的方差则尽可能大。</p>\n<p>设有两个特征维度的数据为：<br>$$<br>X = \\begin{pmatrix}<br>   a_1 &amp; a_2 &amp; \\cdots &amp; a_m \\\\<br>   b_1 &amp; b_2 &amp; \\cdots &amp; b_m<br>\\end{pmatrix}<br>$$</p>\n<p>对应的协方差矩阵：<br>$$<br>\\frac{1}{m} X X^T = \\begin{pmatrix}<br>   \\frac{1}{m}\\sum^m_{i=1}a_i^2 &amp; \\frac{1}{m}\\sum^m_{i=1}a_ib_i \\\\<br>   \\frac{1}{m}\\sum^m_{i=1}a_ib_i &amp; \\frac{1}{m}\\sum^m_{i=1}b_i^2<br>\\end{pmatrix}<br>$$</p>\n<p>矩阵对角线上的两个元素分别是两个字段的方差，而其它元素是a和b的协方差。</p>\n<p>实对称矩阵：一个n行n列的实对称矩阵一定可以找到n个单位正交特征向量。证明略。<br>$$<br>E = (e_1, e_2, \\cdots, e_n)<br>$$</p>\n<p>实对称矩阵进行对角化：<br>$$<br>E^TCE=\\Lambda=<br>X = \\begin{pmatrix}<br>   \\lambda_1 &amp; 0 &amp; \\cdots &amp; 0 \\\\<br>   0 &amp; \\lambda_2 &amp; \\cdots &amp; 0 \\\\<br>    \\vdots &amp; &amp; \\ddots &amp; \\vdots \\\\<br>   0 &amp; 0 &amp; \\cdots &amp; \\lambda_n<br>\\end{pmatrix}<br>$$</p>\n<p>根据特征值的从大到小，将特征向量从上到下排列，则用前K行组成的矩阵乘以原始数据矩阵X，就得到了我们需要的降维后的数据矩阵Y。</p>\n"},{"title":"Ceph简介","_content":"# Ceph存储类型\nCeph 提供三种存储类型：FS, RBD, Object。三种存储类型各有优劣，满足不同场景的使用。\n\n## Ceph FS\n这种类型与NFS使用方式一致，实现了文件系统抽象接口的存储方式，在linux中看到CephFS以挂载盘形式存在，可以直接以操作文件目录形式操作CephFS的挂载盘。实现成本低，随便一台机器设定一个目录为CephFS服务盘即可。但因为需要经过文件系统抽象接口的调用，相对于Ceph的其它两种存储类型的传输效率较慢。\n\n## Ceph RBD\nRBD全称RADOS block device，以设备形式呈现在linux系统中，通过直接调用底层磁盘设备方式对RBD存取，免去了文件系统接口的调用环节，效率是三种Ceph存储类型中最高的，但必须建立在裸盘或磁盘阵列上。\n\n## Ceph Object\n有原生的API，而且也兼容Swift和S3的API，Ceph最底层的存储单元是Object对象，每个Object包含元数据和原始数据。\n\n# Ceph核心概念\n## Monitor\n一个Ceph集群需要多个Monitor组成的小集群，它们通过Paxos同步数据，用来保存OSD的元数据。\n\n## OSD\nObject Storage Device，负责响应客户端请求返回具体数据的进程。一个Ceph集群一般都有很多个OSD。\n\n## MDS\nCeph Metadata Server，是CephFS服务依赖的元数据服务。\n\n## PG\nPlacement Grouops，是一个逻辑的概念，一个PG包含多个OSD。引入PG这一层其实是为了更好的分配数据和定位数据。\n\n## RADOS\nReliable Autonomic Distributed Object Store，为用户实现数据分配、Failover等集群操作。\n\n## Librados\nLibrados是Rados提供库，因为RADOS是协议很难直接访问，因此上层的RBD、RGW和CephFS都是通过librados访问的，目前提供PHP、Ruby、Java、Python、C和C++支持。\n\n## CRUSH\nCeph使用的数据分布算法，类似一致性哈希，让数据分配到预期的地方。\n\n## RGW\nRADOS gateway，是Ceph对外提供的对象存储服务，接口与S3和Swift兼容。\n\n# Ceph IO流程\n![Ceph IO流程图](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/icNyEYk3VqGk91oZGzW0jMNv73lKibM81Q3Vk69XEF5k7AMHI00TtSyj0KcTL0uibaiczgw4z1gAYSxprypZGTVrmQ/640?wx_fmt=png)\n\n使用CephFS上传文件时：\n1. 会把文件切分成若干小块（默认4M一块）\n2. 将切分的块序号与文件ID的对应关系记录在FS的元数据服务中\n3. 根据文件ID与块序号计算ObjectID\n4. 计算PGID=Hash(ObjectID) & mask，其中Hash函数是Ceph设置好的，mask是PG的总数，这个总数是2的整数幂-1。\n5. 采用CRUSH算法将PGID作为参数得到一组OSD。OSD就是真正存储数据的集群服务。\n\nPG是Placement Group的简称，它充当桶的作用，一个桶下可以有多个Object，这个桶是虚拟划分的，底层存储组件的数目可能不等于PG的数目，在创建池的时候设定PG数目。\n\n# Ceph ObjectStorage\n## Pool\n管理物理结构（匹配哪些OSD）。\n\n## Bucket\n管理逻辑结构，在已有的Pool中管理抽象的对象数据。\n\n# 会纪\n1. 单个Ceph RGW Bucket对应的文件数达到10w时索引文件开始切分，期间无法继续写入，耗时较长。\n2. ","source":"_drafts/ceph.md","raw":"---\ntitle: \"Ceph简介\"\ncategory: Ceph\n---\n# Ceph存储类型\nCeph 提供三种存储类型：FS, RBD, Object。三种存储类型各有优劣，满足不同场景的使用。\n\n## Ceph FS\n这种类型与NFS使用方式一致，实现了文件系统抽象接口的存储方式，在linux中看到CephFS以挂载盘形式存在，可以直接以操作文件目录形式操作CephFS的挂载盘。实现成本低，随便一台机器设定一个目录为CephFS服务盘即可。但因为需要经过文件系统抽象接口的调用，相对于Ceph的其它两种存储类型的传输效率较慢。\n\n## Ceph RBD\nRBD全称RADOS block device，以设备形式呈现在linux系统中，通过直接调用底层磁盘设备方式对RBD存取，免去了文件系统接口的调用环节，效率是三种Ceph存储类型中最高的，但必须建立在裸盘或磁盘阵列上。\n\n## Ceph Object\n有原生的API，而且也兼容Swift和S3的API，Ceph最底层的存储单元是Object对象，每个Object包含元数据和原始数据。\n\n# Ceph核心概念\n## Monitor\n一个Ceph集群需要多个Monitor组成的小集群，它们通过Paxos同步数据，用来保存OSD的元数据。\n\n## OSD\nObject Storage Device，负责响应客户端请求返回具体数据的进程。一个Ceph集群一般都有很多个OSD。\n\n## MDS\nCeph Metadata Server，是CephFS服务依赖的元数据服务。\n\n## PG\nPlacement Grouops，是一个逻辑的概念，一个PG包含多个OSD。引入PG这一层其实是为了更好的分配数据和定位数据。\n\n## RADOS\nReliable Autonomic Distributed Object Store，为用户实现数据分配、Failover等集群操作。\n\n## Librados\nLibrados是Rados提供库，因为RADOS是协议很难直接访问，因此上层的RBD、RGW和CephFS都是通过librados访问的，目前提供PHP、Ruby、Java、Python、C和C++支持。\n\n## CRUSH\nCeph使用的数据分布算法，类似一致性哈希，让数据分配到预期的地方。\n\n## RGW\nRADOS gateway，是Ceph对外提供的对象存储服务，接口与S3和Swift兼容。\n\n# Ceph IO流程\n![Ceph IO流程图](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/icNyEYk3VqGk91oZGzW0jMNv73lKibM81Q3Vk69XEF5k7AMHI00TtSyj0KcTL0uibaiczgw4z1gAYSxprypZGTVrmQ/640?wx_fmt=png)\n\n使用CephFS上传文件时：\n1. 会把文件切分成若干小块（默认4M一块）\n2. 将切分的块序号与文件ID的对应关系记录在FS的元数据服务中\n3. 根据文件ID与块序号计算ObjectID\n4. 计算PGID=Hash(ObjectID) & mask，其中Hash函数是Ceph设置好的，mask是PG的总数，这个总数是2的整数幂-1。\n5. 采用CRUSH算法将PGID作为参数得到一组OSD。OSD就是真正存储数据的集群服务。\n\nPG是Placement Group的简称，它充当桶的作用，一个桶下可以有多个Object，这个桶是虚拟划分的，底层存储组件的数目可能不等于PG的数目，在创建池的时候设定PG数目。\n\n# Ceph ObjectStorage\n## Pool\n管理物理结构（匹配哪些OSD）。\n\n## Bucket\n管理逻辑结构，在已有的Pool中管理抽象的对象数据。\n\n# 会纪\n1. 单个Ceph RGW Bucket对应的文件数达到10w时索引文件开始切分，期间无法继续写入，耗时较长。\n2. ","slug":"ceph","published":0,"date":"2020-01-20T06:43:27.363Z","updated":"2020-01-20T06:43:27.363Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck679mtrs0003lbmdyn5gqd31","content":"<h1 id=\"Ceph存储类型\"><a href=\"#Ceph存储类型\" class=\"headerlink\" title=\"Ceph存储类型\"></a>Ceph存储类型</h1><p>Ceph 提供三种存储类型：FS, RBD, Object。三种存储类型各有优劣，满足不同场景的使用。</p>\n<h2 id=\"Ceph-FS\"><a href=\"#Ceph-FS\" class=\"headerlink\" title=\"Ceph FS\"></a>Ceph FS</h2><p>这种类型与NFS使用方式一致，实现了文件系统抽象接口的存储方式，在linux中看到CephFS以挂载盘形式存在，可以直接以操作文件目录形式操作CephFS的挂载盘。实现成本低，随便一台机器设定一个目录为CephFS服务盘即可。但因为需要经过文件系统抽象接口的调用，相对于Ceph的其它两种存储类型的传输效率较慢。</p>\n<h2 id=\"Ceph-RBD\"><a href=\"#Ceph-RBD\" class=\"headerlink\" title=\"Ceph RBD\"></a>Ceph RBD</h2><p>RBD全称RADOS block device，以设备形式呈现在linux系统中，通过直接调用底层磁盘设备方式对RBD存取，免去了文件系统接口的调用环节，效率是三种Ceph存储类型中最高的，但必须建立在裸盘或磁盘阵列上。</p>\n<h2 id=\"Ceph-Object\"><a href=\"#Ceph-Object\" class=\"headerlink\" title=\"Ceph Object\"></a>Ceph Object</h2><p>有原生的API，而且也兼容Swift和S3的API，Ceph最底层的存储单元是Object对象，每个Object包含元数据和原始数据。</p>\n<h1 id=\"Ceph核心概念\"><a href=\"#Ceph核心概念\" class=\"headerlink\" title=\"Ceph核心概念\"></a>Ceph核心概念</h1><h2 id=\"Monitor\"><a href=\"#Monitor\" class=\"headerlink\" title=\"Monitor\"></a>Monitor</h2><p>一个Ceph集群需要多个Monitor组成的小集群，它们通过Paxos同步数据，用来保存OSD的元数据。</p>\n<h2 id=\"OSD\"><a href=\"#OSD\" class=\"headerlink\" title=\"OSD\"></a>OSD</h2><p>Object Storage Device，负责响应客户端请求返回具体数据的进程。一个Ceph集群一般都有很多个OSD。</p>\n<h2 id=\"MDS\"><a href=\"#MDS\" class=\"headerlink\" title=\"MDS\"></a>MDS</h2><p>Ceph Metadata Server，是CephFS服务依赖的元数据服务。</p>\n<h2 id=\"PG\"><a href=\"#PG\" class=\"headerlink\" title=\"PG\"></a>PG</h2><p>Placement Grouops，是一个逻辑的概念，一个PG包含多个OSD。引入PG这一层其实是为了更好的分配数据和定位数据。</p>\n<h2 id=\"RADOS\"><a href=\"#RADOS\" class=\"headerlink\" title=\"RADOS\"></a>RADOS</h2><p>Reliable Autonomic Distributed Object Store，为用户实现数据分配、Failover等集群操作。</p>\n<h2 id=\"Librados\"><a href=\"#Librados\" class=\"headerlink\" title=\"Librados\"></a>Librados</h2><p>Librados是Rados提供库，因为RADOS是协议很难直接访问，因此上层的RBD、RGW和CephFS都是通过librados访问的，目前提供PHP、Ruby、Java、Python、C和C++支持。</p>\n<h2 id=\"CRUSH\"><a href=\"#CRUSH\" class=\"headerlink\" title=\"CRUSH\"></a>CRUSH</h2><p>Ceph使用的数据分布算法，类似一致性哈希，让数据分配到预期的地方。</p>\n<h2 id=\"RGW\"><a href=\"#RGW\" class=\"headerlink\" title=\"RGW\"></a>RGW</h2><p>RADOS gateway，是Ceph对外提供的对象存储服务，接口与S3和Swift兼容。</p>\n<h1 id=\"Ceph-IO流程\"><a href=\"#Ceph-IO流程\" class=\"headerlink\" title=\"Ceph IO流程\"></a>Ceph IO流程</h1><p><img src=\"https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/icNyEYk3VqGk91oZGzW0jMNv73lKibM81Q3Vk69XEF5k7AMHI00TtSyj0KcTL0uibaiczgw4z1gAYSxprypZGTVrmQ/640?wx_fmt=png\" alt=\"Ceph IO流程图\"></p>\n<p>使用CephFS上传文件时：</p>\n<ol>\n<li>会把文件切分成若干小块（默认4M一块）</li>\n<li>将切分的块序号与文件ID的对应关系记录在FS的元数据服务中</li>\n<li>根据文件ID与块序号计算ObjectID</li>\n<li>计算PGID=Hash(ObjectID) &amp; mask，其中Hash函数是Ceph设置好的，mask是PG的总数，这个总数是2的整数幂-1。</li>\n<li>采用CRUSH算法将PGID作为参数得到一组OSD。OSD就是真正存储数据的集群服务。</li>\n</ol>\n<p>PG是Placement Group的简称，它充当桶的作用，一个桶下可以有多个Object，这个桶是虚拟划分的，底层存储组件的数目可能不等于PG的数目，在创建池的时候设定PG数目。</p>\n<h1 id=\"Ceph-ObjectStorage\"><a href=\"#Ceph-ObjectStorage\" class=\"headerlink\" title=\"Ceph ObjectStorage\"></a>Ceph ObjectStorage</h1><h2 id=\"Pool\"><a href=\"#Pool\" class=\"headerlink\" title=\"Pool\"></a>Pool</h2><p>管理物理结构（匹配哪些OSD）。</p>\n<h2 id=\"Bucket\"><a href=\"#Bucket\" class=\"headerlink\" title=\"Bucket\"></a>Bucket</h2><p>管理逻辑结构，在已有的Pool中管理抽象的对象数据。</p>\n<h1 id=\"会纪\"><a href=\"#会纪\" class=\"headerlink\" title=\"会纪\"></a>会纪</h1><ol>\n<li>单个Ceph RGW Bucket对应的文件数达到10w时索引文件开始切分，期间无法继续写入，耗时较长。</li>\n<li></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Ceph存储类型\"><a href=\"#Ceph存储类型\" class=\"headerlink\" title=\"Ceph存储类型\"></a>Ceph存储类型</h1><p>Ceph 提供三种存储类型：FS, RBD, Object。三种存储类型各有优劣，满足不同场景的使用。</p>\n<h2 id=\"Ceph-FS\"><a href=\"#Ceph-FS\" class=\"headerlink\" title=\"Ceph FS\"></a>Ceph FS</h2><p>这种类型与NFS使用方式一致，实现了文件系统抽象接口的存储方式，在linux中看到CephFS以挂载盘形式存在，可以直接以操作文件目录形式操作CephFS的挂载盘。实现成本低，随便一台机器设定一个目录为CephFS服务盘即可。但因为需要经过文件系统抽象接口的调用，相对于Ceph的其它两种存储类型的传输效率较慢。</p>\n<h2 id=\"Ceph-RBD\"><a href=\"#Ceph-RBD\" class=\"headerlink\" title=\"Ceph RBD\"></a>Ceph RBD</h2><p>RBD全称RADOS block device，以设备形式呈现在linux系统中，通过直接调用底层磁盘设备方式对RBD存取，免去了文件系统接口的调用环节，效率是三种Ceph存储类型中最高的，但必须建立在裸盘或磁盘阵列上。</p>\n<h2 id=\"Ceph-Object\"><a href=\"#Ceph-Object\" class=\"headerlink\" title=\"Ceph Object\"></a>Ceph Object</h2><p>有原生的API，而且也兼容Swift和S3的API，Ceph最底层的存储单元是Object对象，每个Object包含元数据和原始数据。</p>\n<h1 id=\"Ceph核心概念\"><a href=\"#Ceph核心概念\" class=\"headerlink\" title=\"Ceph核心概念\"></a>Ceph核心概念</h1><h2 id=\"Monitor\"><a href=\"#Monitor\" class=\"headerlink\" title=\"Monitor\"></a>Monitor</h2><p>一个Ceph集群需要多个Monitor组成的小集群，它们通过Paxos同步数据，用来保存OSD的元数据。</p>\n<h2 id=\"OSD\"><a href=\"#OSD\" class=\"headerlink\" title=\"OSD\"></a>OSD</h2><p>Object Storage Device，负责响应客户端请求返回具体数据的进程。一个Ceph集群一般都有很多个OSD。</p>\n<h2 id=\"MDS\"><a href=\"#MDS\" class=\"headerlink\" title=\"MDS\"></a>MDS</h2><p>Ceph Metadata Server，是CephFS服务依赖的元数据服务。</p>\n<h2 id=\"PG\"><a href=\"#PG\" class=\"headerlink\" title=\"PG\"></a>PG</h2><p>Placement Grouops，是一个逻辑的概念，一个PG包含多个OSD。引入PG这一层其实是为了更好的分配数据和定位数据。</p>\n<h2 id=\"RADOS\"><a href=\"#RADOS\" class=\"headerlink\" title=\"RADOS\"></a>RADOS</h2><p>Reliable Autonomic Distributed Object Store，为用户实现数据分配、Failover等集群操作。</p>\n<h2 id=\"Librados\"><a href=\"#Librados\" class=\"headerlink\" title=\"Librados\"></a>Librados</h2><p>Librados是Rados提供库，因为RADOS是协议很难直接访问，因此上层的RBD、RGW和CephFS都是通过librados访问的，目前提供PHP、Ruby、Java、Python、C和C++支持。</p>\n<h2 id=\"CRUSH\"><a href=\"#CRUSH\" class=\"headerlink\" title=\"CRUSH\"></a>CRUSH</h2><p>Ceph使用的数据分布算法，类似一致性哈希，让数据分配到预期的地方。</p>\n<h2 id=\"RGW\"><a href=\"#RGW\" class=\"headerlink\" title=\"RGW\"></a>RGW</h2><p>RADOS gateway，是Ceph对外提供的对象存储服务，接口与S3和Swift兼容。</p>\n<h1 id=\"Ceph-IO流程\"><a href=\"#Ceph-IO流程\" class=\"headerlink\" title=\"Ceph IO流程\"></a>Ceph IO流程</h1><p><img src=\"https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/icNyEYk3VqGk91oZGzW0jMNv73lKibM81Q3Vk69XEF5k7AMHI00TtSyj0KcTL0uibaiczgw4z1gAYSxprypZGTVrmQ/640?wx_fmt=png\" alt=\"Ceph IO流程图\"></p>\n<p>使用CephFS上传文件时：</p>\n<ol>\n<li>会把文件切分成若干小块（默认4M一块）</li>\n<li>将切分的块序号与文件ID的对应关系记录在FS的元数据服务中</li>\n<li>根据文件ID与块序号计算ObjectID</li>\n<li>计算PGID=Hash(ObjectID) &amp; mask，其中Hash函数是Ceph设置好的，mask是PG的总数，这个总数是2的整数幂-1。</li>\n<li>采用CRUSH算法将PGID作为参数得到一组OSD。OSD就是真正存储数据的集群服务。</li>\n</ol>\n<p>PG是Placement Group的简称，它充当桶的作用，一个桶下可以有多个Object，这个桶是虚拟划分的，底层存储组件的数目可能不等于PG的数目，在创建池的时候设定PG数目。</p>\n<h1 id=\"Ceph-ObjectStorage\"><a href=\"#Ceph-ObjectStorage\" class=\"headerlink\" title=\"Ceph ObjectStorage\"></a>Ceph ObjectStorage</h1><h2 id=\"Pool\"><a href=\"#Pool\" class=\"headerlink\" title=\"Pool\"></a>Pool</h2><p>管理物理结构（匹配哪些OSD）。</p>\n<h2 id=\"Bucket\"><a href=\"#Bucket\" class=\"headerlink\" title=\"Bucket\"></a>Bucket</h2><p>管理逻辑结构，在已有的Pool中管理抽象的对象数据。</p>\n<h1 id=\"会纪\"><a href=\"#会纪\" class=\"headerlink\" title=\"会纪\"></a>会纪</h1><ol>\n<li>单个Ceph RGW Bucket对应的文件数达到10w时索引文件开始切分，期间无法继续写入，耗时较长。</li>\n<li></li>\n</ol>\n"},{"title":"Docker privileged","_content":"Docker的--privileged参数大约在0.6版被引入，使用该参数，container内的root拥有真正的root权限，否则，container内的root只是外部的一个普通用户权限。\n\n<!--more-->\n\n```sh\n$ docker help run \n...\n--privileged=false         Give extended privileges to this container\n...\n```\n\nprivileged启动的容器，可以看到很多host上的设备，并且可以执行mount，甚至允许你在docker容器中启动docker容器。\n\n## Rancher简单部署K8s\nRancher的自动部署K8s集群正是使用这种机制来实现，宿主机只需要下载rancher-agent镜像并给出正确的参数来启动这个镜像的容器，rancher-agent容器中将会自动下载Rancher K8s集群需要用到的镜像、构建好网络组件、K8s组件容器等一系列操作，整个过程非常简单，一键完成。\n\n```sh\n$ sudo docker run -d --privileged --restart=unless-stopped --net=host -v /etc/kubernetes:/etc/kubernetes -v /var/run:/var/run rancher/rancher-agent:v2.2.8 --server https://192.168.1.1 --token kxbtbs64wwp59zfnc49bdlvhn7x5nbggrl4t9vfnjnhd29b6zdp7jb --ca-checksum 54dc4ecdbcd8b5099693df4a1e4fbc91aca8e41f2cde2431a4a6cc7cddca8524 --etcd --controlplane --worker\nefee4938be7173b59fa242e1bba48879cc03ee17f73567a13fc0fac2c5fa36a9\n```","source":"_drafts/docker-privileged.md","raw":"---\ntitle: \"Docker privileged\"\ncategory: docker\n---\nDocker的--privileged参数大约在0.6版被引入，使用该参数，container内的root拥有真正的root权限，否则，container内的root只是外部的一个普通用户权限。\n\n<!--more-->\n\n```sh\n$ docker help run \n...\n--privileged=false         Give extended privileges to this container\n...\n```\n\nprivileged启动的容器，可以看到很多host上的设备，并且可以执行mount，甚至允许你在docker容器中启动docker容器。\n\n## Rancher简单部署K8s\nRancher的自动部署K8s集群正是使用这种机制来实现，宿主机只需要下载rancher-agent镜像并给出正确的参数来启动这个镜像的容器，rancher-agent容器中将会自动下载Rancher K8s集群需要用到的镜像、构建好网络组件、K8s组件容器等一系列操作，整个过程非常简单，一键完成。\n\n```sh\n$ sudo docker run -d --privileged --restart=unless-stopped --net=host -v /etc/kubernetes:/etc/kubernetes -v /var/run:/var/run rancher/rancher-agent:v2.2.8 --server https://192.168.1.1 --token kxbtbs64wwp59zfnc49bdlvhn7x5nbggrl4t9vfnjnhd29b6zdp7jb --ca-checksum 54dc4ecdbcd8b5099693df4a1e4fbc91aca8e41f2cde2431a4a6cc7cddca8524 --etcd --controlplane --worker\nefee4938be7173b59fa242e1bba48879cc03ee17f73567a13fc0fac2c5fa36a9\n```","slug":"docker-privileged","published":0,"date":"2020-01-16T17:23:25.488Z","updated":"2019-10-31T07:36:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck679mtru0004lbmdpi7pp641","content":"<p>Docker的–privileged参数大约在0.6版被引入，使用该参数，container内的root拥有真正的root权限，否则，container内的root只是外部的一个普通用户权限。</p>\n<a id=\"more\"></a>\n\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker <span class=\"built_in\">help</span> run </span><br><span class=\"line\">...</span><br><span class=\"line\">--privileged=<span class=\"literal\">false</span>         Give extended privileges to this container</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>privileged启动的容器，可以看到很多host上的设备，并且可以执行mount，甚至允许你在docker容器中启动docker容器。</p>\n<h2 id=\"Rancher简单部署K8s\"><a href=\"#Rancher简单部署K8s\" class=\"headerlink\" title=\"Rancher简单部署K8s\"></a>Rancher简单部署K8s</h2><p>Rancher的自动部署K8s集群正是使用这种机制来实现，宿主机只需要下载rancher-agent镜像并给出正确的参数来启动这个镜像的容器，rancher-agent容器中将会自动下载Rancher K8s集群需要用到的镜像、构建好网络组件、K8s组件容器等一系列操作，整个过程非常简单，一键完成。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo docker run -d --privileged --restart=unless-stopped --net=host -v /etc/kubernetes:/etc/kubernetes -v /var/run:/var/run rancher/rancher-agent:v2.2.8 --server https://192.168.1.1 --token kxbtbs64wwp59zfnc49bdlvhn7x5nbggrl4t9vfnjnhd29b6zdp7jb --ca-checksum 54dc4ecdbcd8b5099693df4a1e4fbc91aca8e41f2cde2431a4a6cc7cddca8524 --etcd --controlplane --worker</span><br><span class=\"line\">efee4938be7173b59fa242e1bba48879cc03ee17f73567a13fc0fac2c5fa36a9</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>Docker的–privileged参数大约在0.6版被引入，使用该参数，container内的root拥有真正的root权限，否则，container内的root只是外部的一个普通用户权限。</p>","more":"<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker <span class=\"built_in\">help</span> run </span><br><span class=\"line\">...</span><br><span class=\"line\">--privileged=<span class=\"literal\">false</span>         Give extended privileges to this container</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>privileged启动的容器，可以看到很多host上的设备，并且可以执行mount，甚至允许你在docker容器中启动docker容器。</p>\n<h2 id=\"Rancher简单部署K8s\"><a href=\"#Rancher简单部署K8s\" class=\"headerlink\" title=\"Rancher简单部署K8s\"></a>Rancher简单部署K8s</h2><p>Rancher的自动部署K8s集群正是使用这种机制来实现，宿主机只需要下载rancher-agent镜像并给出正确的参数来启动这个镜像的容器，rancher-agent容器中将会自动下载Rancher K8s集群需要用到的镜像、构建好网络组件、K8s组件容器等一系列操作，整个过程非常简单，一键完成。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo docker run -d --privileged --restart=unless-stopped --net=host -v /etc/kubernetes:/etc/kubernetes -v /var/run:/var/run rancher/rancher-agent:v2.2.8 --server https://192.168.1.1 --token kxbtbs64wwp59zfnc49bdlvhn7x5nbggrl4t9vfnjnhd29b6zdp7jb --ca-checksum 54dc4ecdbcd8b5099693df4a1e4fbc91aca8e41f2cde2431a4a6cc7cddca8524 --etcd --controlplane --worker</span><br><span class=\"line\">efee4938be7173b59fa242e1bba48879cc03ee17f73567a13fc0fac2c5fa36a9</span><br></pre></td></tr></table></figure>"},{"title":"k8s DaemonSet","_content":"\n部署一个DaemonSet会在集群中每一个Node上都创建一个的Pod。DaemonSet常用于Node节点的监控、日志收集、集群存储服务等。\n\n<!--more-->\n\n# DaemonSet定义\n\n","source":"_drafts/k8s-daemonset.md","raw":"---\ntitle: \"k8s DaemonSet\"\ncategory: k8s\n---\n\n部署一个DaemonSet会在集群中每一个Node上都创建一个的Pod。DaemonSet常用于Node节点的监控、日志收集、集群存储服务等。\n\n<!--more-->\n\n# DaemonSet定义\n\n","slug":"k8s-daemonset","published":0,"date":"2020-01-16T17:23:25.488Z","updated":"2019-10-31T02:25:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck679mtru0005lbmd8zjrwjw2","content":"<p>部署一个DaemonSet会在集群中每一个Node上都创建一个的Pod。DaemonSet常用于Node节点的监控、日志收集、集群存储服务等。</p>\n<a id=\"more\"></a>\n\n<h1 id=\"DaemonSet定义\"><a href=\"#DaemonSet定义\" class=\"headerlink\" title=\"DaemonSet定义\"></a>DaemonSet定义</h1>","site":{"data":{}},"excerpt":"<p>部署一个DaemonSet会在集群中每一个Node上都创建一个的Pod。DaemonSet常用于Node节点的监控、日志收集、集群存储服务等。</p>","more":"<h1 id=\"DaemonSet定义\"><a href=\"#DaemonSet定义\" class=\"headerlink\" title=\"DaemonSet定义\"></a>DaemonSet定义</h1>"},{"title":"k8s 自签证书","_content":"\nK8s集群节点间通信以及开放接口都是采用TLS协议的，TLS协议需要用到CA签发证书，而权威机构的CA证书只能根据域名签署，内网IP调用的CA证书就需要自建来实现了。\n\n<!--more-->\n\n组件 | 需要使用的证书\n---|---\netcd | ca.pem server.pem server-key.pem\nflannel | ca.pem server.pem server-key.pem\nkube-apiserver | ca.pem server.pem server-key.pem\nkubelet | ca.pem ca-key.pem\nkube-proxy | ca.pem kube-proxy.pem kube-proxy-key.pem\nkubectl | ca.pem admin.pem admin-key.pem\n\n# 安装证书生成证书工具cfssl\n```sh\nwget -O cfssl https://pkg.cfssl.org/R1.2/cfssl_linux-amd64\nchmod +x cfssl && mv cfssl /usr/bin/\nwget -O cfssljson https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64\nchmod +x cfssljson && mv cfssljson /usr/bin/\n```\n\n# 生成X509证书\n在存放证书的目录下执行下列脚本生成证书：\n\n```sh\necho -e \"\\n开始生成CA自签证书: ca.pem, ca-key.pem, ca.csr\"\ncat > ca-config.json <<EOF\n{\n  \"signing\": {\n    \"default\":{\n      \"expiry\": \"87600h\"\n    },\n    \"profiles\": {\n      \"kubernetes\": {\n        \"expiry\": \"87600h\",\n        \"usages\": [\n           \"signing\",\n           \"key encipherment\",\n           \"server auth\",\n           \"client auth\"\n         ]\n      }\n    }\n  }\n}\nEOF\n\ncat > ca-csr.json <<EOF\n{\n  \"CN\": \"kubernetes\",\n  \"key\": {\n    \"algo\": \"rsa\",\n    \"size\": 2048\n  },\n  \"names\": [\n    {\n      \"C\": \"CN\",\n      \"L\": \"Beijing\",\n      \"ST\": \"Beijing\",\n      \"O\": \"k8s\",\n      \"OU\": \"System\"\n    }\n  ]\n}\nEOF\n\ncfssl gencert -initca ca-csr.json | cfssljson -bare ca -\n\n#-------------------\n\necho -e \"\\n开始生成server证书: server.pem, server-key.pem, server.csr\"\ncat > server-csr.json <<EOF\n{\n  \"CN\": \"kubernetes\",\n  \"hosts\": [\n    \"127.0.0.1\",\n    \"localhost\",\n    <<IPADDRS>>\n    \"kubernetes\",\n    \"kubernetes.default\",\n    \"kubernetes.default.svc\",\n    \"kubernetes.default.svc.cluster\",\n    \"kubernetes.default.svc.cluster.local\"\n  ],\n  \"key\": {\n    \"algo\": \"rsa\",\n    \"size\": 2048\n  },\n  \"names\": [\n    {\n      \"C\": \"CN\",\n      \"L\": \"Beijing\",\n      \"ST\": \"Beijing\",\n      \"O\": \"k8s\",\n      \"OU\": \"System\"\n    }\n  ]\n}\nEOF\n\nsed -i \"s/<<IPADDRS>>/$IP_ADDRS/g\" server-csr.json\n\ncfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes server-csr.json | cfssljson -bare server\n\n#----------------\necho -e \"\\n开始生成admin证书: admin.pem, admin-key.pem, admin.csr\"\ncat > admin-csr.json <<EOF\n{\n  \"CN\": \"admin\",\n  \"hosts\": [],\n  \"key\": {\n    \"algo\": \"rsa\",\n    \"size\": 2048\n  },\n  \"names\": [\n    {\n      \"C\": \"CN\",\n      \"L\": \"Beijing\",\n      \"ST\": \"Beijing\",\n      \"O\": \"system:masters\",\n      \"OU\": \"System\"\n    }\n  ]\n}\nEOF\n\ncfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes admin-csr.json | cfssljson -bare admin\n\n#---------\necho -e \"\\n开始生成kube-proxy证书: kube-proxy.pem, kube-proxy-key.pem, kube-proxy.csr\"\ncat > kube-proxy-csr.json <<EOF\n{\n  \"CN\": \"system:kube-proxy\",\n  \"hosts\": [],\n  \"key\": {\n    \"algo\": \"rsa\",\n    \"size\": 2048\n  },\n  \"names\": [\n    {\n      \"C\": \"CN\",\n      \"L\": \"Beijing\",\n      \"ST\": \"Beijing\",\n      \"O\": \"k8s\",\n      \"OU\": \"System\"\n    }\n  ]\n}\nEOF\n\ncfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-proxy-csr.json | cfssljson -bare kube-proxy\n```\n\n执行完脚本后如果没有任何报错则会在当前目录下生成上述K8s需要的证书文件。\n```sh\n$ ls\nadmin-csr.json\t\tca-key.pem\t\tclient.pem\t\tserver-key.pem\nadmin-key.pem\t\tca.csr\t\t\tkube-proxy-csr.json\tserver.csr\nadmin.csr\t\tca.pem\t\t\tkube-proxy-key.pem\tserver.pem\nadmin.pem\t\tclient-csr.json\t\tkube-proxy.csr\nca-config.json\t\tclient-key.pem\t\tkube-proxy.pem\nca-csr.json\t\tclient.csr\t\tserver-csr.json\n```","source":"_drafts/k8s-ca.md","raw":"---\ntitle: \"k8s 自签证书\"\ncategory: k8s\n---\n\nK8s集群节点间通信以及开放接口都是采用TLS协议的，TLS协议需要用到CA签发证书，而权威机构的CA证书只能根据域名签署，内网IP调用的CA证书就需要自建来实现了。\n\n<!--more-->\n\n组件 | 需要使用的证书\n---|---\netcd | ca.pem server.pem server-key.pem\nflannel | ca.pem server.pem server-key.pem\nkube-apiserver | ca.pem server.pem server-key.pem\nkubelet | ca.pem ca-key.pem\nkube-proxy | ca.pem kube-proxy.pem kube-proxy-key.pem\nkubectl | ca.pem admin.pem admin-key.pem\n\n# 安装证书生成证书工具cfssl\n```sh\nwget -O cfssl https://pkg.cfssl.org/R1.2/cfssl_linux-amd64\nchmod +x cfssl && mv cfssl /usr/bin/\nwget -O cfssljson https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64\nchmod +x cfssljson && mv cfssljson /usr/bin/\n```\n\n# 生成X509证书\n在存放证书的目录下执行下列脚本生成证书：\n\n```sh\necho -e \"\\n开始生成CA自签证书: ca.pem, ca-key.pem, ca.csr\"\ncat > ca-config.json <<EOF\n{\n  \"signing\": {\n    \"default\":{\n      \"expiry\": \"87600h\"\n    },\n    \"profiles\": {\n      \"kubernetes\": {\n        \"expiry\": \"87600h\",\n        \"usages\": [\n           \"signing\",\n           \"key encipherment\",\n           \"server auth\",\n           \"client auth\"\n         ]\n      }\n    }\n  }\n}\nEOF\n\ncat > ca-csr.json <<EOF\n{\n  \"CN\": \"kubernetes\",\n  \"key\": {\n    \"algo\": \"rsa\",\n    \"size\": 2048\n  },\n  \"names\": [\n    {\n      \"C\": \"CN\",\n      \"L\": \"Beijing\",\n      \"ST\": \"Beijing\",\n      \"O\": \"k8s\",\n      \"OU\": \"System\"\n    }\n  ]\n}\nEOF\n\ncfssl gencert -initca ca-csr.json | cfssljson -bare ca -\n\n#-------------------\n\necho -e \"\\n开始生成server证书: server.pem, server-key.pem, server.csr\"\ncat > server-csr.json <<EOF\n{\n  \"CN\": \"kubernetes\",\n  \"hosts\": [\n    \"127.0.0.1\",\n    \"localhost\",\n    <<IPADDRS>>\n    \"kubernetes\",\n    \"kubernetes.default\",\n    \"kubernetes.default.svc\",\n    \"kubernetes.default.svc.cluster\",\n    \"kubernetes.default.svc.cluster.local\"\n  ],\n  \"key\": {\n    \"algo\": \"rsa\",\n    \"size\": 2048\n  },\n  \"names\": [\n    {\n      \"C\": \"CN\",\n      \"L\": \"Beijing\",\n      \"ST\": \"Beijing\",\n      \"O\": \"k8s\",\n      \"OU\": \"System\"\n    }\n  ]\n}\nEOF\n\nsed -i \"s/<<IPADDRS>>/$IP_ADDRS/g\" server-csr.json\n\ncfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes server-csr.json | cfssljson -bare server\n\n#----------------\necho -e \"\\n开始生成admin证书: admin.pem, admin-key.pem, admin.csr\"\ncat > admin-csr.json <<EOF\n{\n  \"CN\": \"admin\",\n  \"hosts\": [],\n  \"key\": {\n    \"algo\": \"rsa\",\n    \"size\": 2048\n  },\n  \"names\": [\n    {\n      \"C\": \"CN\",\n      \"L\": \"Beijing\",\n      \"ST\": \"Beijing\",\n      \"O\": \"system:masters\",\n      \"OU\": \"System\"\n    }\n  ]\n}\nEOF\n\ncfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes admin-csr.json | cfssljson -bare admin\n\n#---------\necho -e \"\\n开始生成kube-proxy证书: kube-proxy.pem, kube-proxy-key.pem, kube-proxy.csr\"\ncat > kube-proxy-csr.json <<EOF\n{\n  \"CN\": \"system:kube-proxy\",\n  \"hosts\": [],\n  \"key\": {\n    \"algo\": \"rsa\",\n    \"size\": 2048\n  },\n  \"names\": [\n    {\n      \"C\": \"CN\",\n      \"L\": \"Beijing\",\n      \"ST\": \"Beijing\",\n      \"O\": \"k8s\",\n      \"OU\": \"System\"\n    }\n  ]\n}\nEOF\n\ncfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-proxy-csr.json | cfssljson -bare kube-proxy\n```\n\n执行完脚本后如果没有任何报错则会在当前目录下生成上述K8s需要的证书文件。\n```sh\n$ ls\nadmin-csr.json\t\tca-key.pem\t\tclient.pem\t\tserver-key.pem\nadmin-key.pem\t\tca.csr\t\t\tkube-proxy-csr.json\tserver.csr\nadmin.csr\t\tca.pem\t\t\tkube-proxy-key.pem\tserver.pem\nadmin.pem\t\tclient-csr.json\t\tkube-proxy.csr\nca-config.json\t\tclient-key.pem\t\tkube-proxy.pem\nca-csr.json\t\tclient.csr\t\tserver-csr.json\n```","slug":"k8s-ca","published":0,"date":"2020-01-16T17:23:25.488Z","updated":"2019-10-31T02:24:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck679mtrv0007lbmdpsp1ftvl","content":"<p>K8s集群节点间通信以及开放接口都是采用TLS协议的，TLS协议需要用到CA签发证书，而权威机构的CA证书只能根据域名签署，内网IP调用的CA证书就需要自建来实现了。</p>\n<a id=\"more\"></a>\n\n<table>\n<thead>\n<tr>\n<th>组件</th>\n<th>需要使用的证书</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>etcd</td>\n<td>ca.pem server.pem server-key.pem</td>\n</tr>\n<tr>\n<td>flannel</td>\n<td>ca.pem server.pem server-key.pem</td>\n</tr>\n<tr>\n<td>kube-apiserver</td>\n<td>ca.pem server.pem server-key.pem</td>\n</tr>\n<tr>\n<td>kubelet</td>\n<td>ca.pem ca-key.pem</td>\n</tr>\n<tr>\n<td>kube-proxy</td>\n<td>ca.pem kube-proxy.pem kube-proxy-key.pem</td>\n</tr>\n<tr>\n<td>kubectl</td>\n<td>ca.pem admin.pem admin-key.pem</td>\n</tr>\n</tbody></table>\n<h1 id=\"安装证书生成证书工具cfssl\"><a href=\"#安装证书生成证书工具cfssl\" class=\"headerlink\" title=\"安装证书生成证书工具cfssl\"></a>安装证书生成证书工具cfssl</h1><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -O cfssl https://pkg.cfssl.org/R1.2/cfssl_linux-amd64</span><br><span class=\"line\">chmod +x cfssl &amp;&amp; mv cfssl /usr/bin/</span><br><span class=\"line\">wget -O cfssljson https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64</span><br><span class=\"line\">chmod +x cfssljson &amp;&amp; mv cfssljson /usr/bin/</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"生成X509证书\"><a href=\"#生成X509证书\" class=\"headerlink\" title=\"生成X509证书\"></a>生成X509证书</h1><p>在存放证书的目录下执行下列脚本生成证书：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"string\">\"\\n开始生成CA自签证书: ca.pem, ca-key.pem, ca.csr\"</span></span><br><span class=\"line\">cat &gt; ca-config.json &lt;&lt;EOF</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"signing\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"default\"</span>:&#123;</span><br><span class=\"line\">      <span class=\"string\">\"expiry\"</span>: <span class=\"string\">\"87600h\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"profiles\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">\"kubernetes\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"expiry\"</span>: <span class=\"string\">\"87600h\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"usages\"</span>: [</span><br><span class=\"line\">           <span class=\"string\">\"signing\"</span>,</span><br><span class=\"line\">           <span class=\"string\">\"key encipherment\"</span>,</span><br><span class=\"line\">           <span class=\"string\">\"server auth\"</span>,</span><br><span class=\"line\">           <span class=\"string\">\"client auth\"</span></span><br><span class=\"line\">         ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EOF</span><br><span class=\"line\"></span><br><span class=\"line\">cat &gt; ca-csr.json &lt;&lt;EOF</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"CN\"</span>: <span class=\"string\">\"kubernetes\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"key\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"algo\"</span>: <span class=\"string\">\"rsa\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"size\"</span>: 2048</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"names\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">\"C\"</span>: <span class=\"string\">\"CN\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"L\"</span>: <span class=\"string\">\"Beijing\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"ST\"</span>: <span class=\"string\">\"Beijing\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"O\"</span>: <span class=\"string\">\"k8s\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"OU\"</span>: <span class=\"string\">\"System\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EOF</span><br><span class=\"line\"></span><br><span class=\"line\">cfssl gencert -initca ca-csr.json | cfssljson -bare ca -</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#-------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"string\">\"\\n开始生成server证书: server.pem, server-key.pem, server.csr\"</span></span><br><span class=\"line\">cat &gt; server-csr.json &lt;&lt;EOF</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"CN\"</span>: <span class=\"string\">\"kubernetes\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"hosts\"</span>: [</span><br><span class=\"line\">    <span class=\"string\">\"127.0.0.1\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"localhost\"</span>,</span><br><span class=\"line\">    &lt;&lt;IPADDRS&gt;&gt;</span><br><span class=\"line\">    <span class=\"string\">\"kubernetes\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"kubernetes.default\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"kubernetes.default.svc\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"kubernetes.default.svc.cluster\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"kubernetes.default.svc.cluster.local\"</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"string\">\"key\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"algo\"</span>: <span class=\"string\">\"rsa\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"size\"</span>: 2048</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"names\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">\"C\"</span>: <span class=\"string\">\"CN\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"L\"</span>: <span class=\"string\">\"Beijing\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"ST\"</span>: <span class=\"string\">\"Beijing\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"O\"</span>: <span class=\"string\">\"k8s\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"OU\"</span>: <span class=\"string\">\"System\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EOF</span><br><span class=\"line\"></span><br><span class=\"line\">sed -i <span class=\"string\">\"s/&lt;&lt;IPADDRS&gt;&gt;/<span class=\"variable\">$IP_ADDRS</span>/g\"</span> server-csr.json</span><br><span class=\"line\"></span><br><span class=\"line\">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes server-csr.json | cfssljson -bare server</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#----------------</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"string\">\"\\n开始生成admin证书: admin.pem, admin-key.pem, admin.csr\"</span></span><br><span class=\"line\">cat &gt; admin-csr.json &lt;&lt;EOF</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"CN\"</span>: <span class=\"string\">\"admin\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"hosts\"</span>: [],</span><br><span class=\"line\">  <span class=\"string\">\"key\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"algo\"</span>: <span class=\"string\">\"rsa\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"size\"</span>: 2048</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"names\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">\"C\"</span>: <span class=\"string\">\"CN\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"L\"</span>: <span class=\"string\">\"Beijing\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"ST\"</span>: <span class=\"string\">\"Beijing\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"O\"</span>: <span class=\"string\">\"system:masters\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"OU\"</span>: <span class=\"string\">\"System\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EOF</span><br><span class=\"line\"></span><br><span class=\"line\">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes admin-csr.json | cfssljson -bare admin</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#---------</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"string\">\"\\n开始生成kube-proxy证书: kube-proxy.pem, kube-proxy-key.pem, kube-proxy.csr\"</span></span><br><span class=\"line\">cat &gt; kube-proxy-csr.json &lt;&lt;EOF</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"CN\"</span>: <span class=\"string\">\"system:kube-proxy\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"hosts\"</span>: [],</span><br><span class=\"line\">  <span class=\"string\">\"key\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"algo\"</span>: <span class=\"string\">\"rsa\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"size\"</span>: 2048</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"names\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">\"C\"</span>: <span class=\"string\">\"CN\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"L\"</span>: <span class=\"string\">\"Beijing\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"ST\"</span>: <span class=\"string\">\"Beijing\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"O\"</span>: <span class=\"string\">\"k8s\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"OU\"</span>: <span class=\"string\">\"System\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EOF</span><br><span class=\"line\"></span><br><span class=\"line\">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-proxy-csr.json | cfssljson -bare kube-proxy</span><br></pre></td></tr></table></figure>\n\n<p>执行完脚本后如果没有任何报错则会在当前目录下生成上述K8s需要的证书文件。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ls</span><br><span class=\"line\">admin-csr.json\t\tca-key.pem\t\tclient.pem\t\tserver-key.pem</span><br><span class=\"line\">admin-key.pem\t\tca.csr\t\t\tkube-proxy-csr.json\tserver.csr</span><br><span class=\"line\">admin.csr\t\tca.pem\t\t\tkube-proxy-key.pem\tserver.pem</span><br><span class=\"line\">admin.pem\t\tclient-csr.json\t\tkube-proxy.csr</span><br><span class=\"line\">ca-config.json\t\tclient-key.pem\t\tkube-proxy.pem</span><br><span class=\"line\">ca-csr.json\t\tclient.csr\t\tserver-csr.json</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>K8s集群节点间通信以及开放接口都是采用TLS协议的，TLS协议需要用到CA签发证书，而权威机构的CA证书只能根据域名签署，内网IP调用的CA证书就需要自建来实现了。</p>","more":"<table>\n<thead>\n<tr>\n<th>组件</th>\n<th>需要使用的证书</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>etcd</td>\n<td>ca.pem server.pem server-key.pem</td>\n</tr>\n<tr>\n<td>flannel</td>\n<td>ca.pem server.pem server-key.pem</td>\n</tr>\n<tr>\n<td>kube-apiserver</td>\n<td>ca.pem server.pem server-key.pem</td>\n</tr>\n<tr>\n<td>kubelet</td>\n<td>ca.pem ca-key.pem</td>\n</tr>\n<tr>\n<td>kube-proxy</td>\n<td>ca.pem kube-proxy.pem kube-proxy-key.pem</td>\n</tr>\n<tr>\n<td>kubectl</td>\n<td>ca.pem admin.pem admin-key.pem</td>\n</tr>\n</tbody></table>\n<h1 id=\"安装证书生成证书工具cfssl\"><a href=\"#安装证书生成证书工具cfssl\" class=\"headerlink\" title=\"安装证书生成证书工具cfssl\"></a>安装证书生成证书工具cfssl</h1><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -O cfssl https://pkg.cfssl.org/R1.2/cfssl_linux-amd64</span><br><span class=\"line\">chmod +x cfssl &amp;&amp; mv cfssl /usr/bin/</span><br><span class=\"line\">wget -O cfssljson https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64</span><br><span class=\"line\">chmod +x cfssljson &amp;&amp; mv cfssljson /usr/bin/</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"生成X509证书\"><a href=\"#生成X509证书\" class=\"headerlink\" title=\"生成X509证书\"></a>生成X509证书</h1><p>在存放证书的目录下执行下列脚本生成证书：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"string\">\"\\n开始生成CA自签证书: ca.pem, ca-key.pem, ca.csr\"</span></span><br><span class=\"line\">cat &gt; ca-config.json &lt;&lt;EOF</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"signing\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"default\"</span>:&#123;</span><br><span class=\"line\">      <span class=\"string\">\"expiry\"</span>: <span class=\"string\">\"87600h\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"profiles\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">\"kubernetes\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"expiry\"</span>: <span class=\"string\">\"87600h\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"usages\"</span>: [</span><br><span class=\"line\">           <span class=\"string\">\"signing\"</span>,</span><br><span class=\"line\">           <span class=\"string\">\"key encipherment\"</span>,</span><br><span class=\"line\">           <span class=\"string\">\"server auth\"</span>,</span><br><span class=\"line\">           <span class=\"string\">\"client auth\"</span></span><br><span class=\"line\">         ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EOF</span><br><span class=\"line\"></span><br><span class=\"line\">cat &gt; ca-csr.json &lt;&lt;EOF</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"CN\"</span>: <span class=\"string\">\"kubernetes\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"key\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"algo\"</span>: <span class=\"string\">\"rsa\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"size\"</span>: 2048</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"names\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">\"C\"</span>: <span class=\"string\">\"CN\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"L\"</span>: <span class=\"string\">\"Beijing\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"ST\"</span>: <span class=\"string\">\"Beijing\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"O\"</span>: <span class=\"string\">\"k8s\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"OU\"</span>: <span class=\"string\">\"System\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EOF</span><br><span class=\"line\"></span><br><span class=\"line\">cfssl gencert -initca ca-csr.json | cfssljson -bare ca -</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#-------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"string\">\"\\n开始生成server证书: server.pem, server-key.pem, server.csr\"</span></span><br><span class=\"line\">cat &gt; server-csr.json &lt;&lt;EOF</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"CN\"</span>: <span class=\"string\">\"kubernetes\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"hosts\"</span>: [</span><br><span class=\"line\">    <span class=\"string\">\"127.0.0.1\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"localhost\"</span>,</span><br><span class=\"line\">    &lt;&lt;IPADDRS&gt;&gt;</span><br><span class=\"line\">    <span class=\"string\">\"kubernetes\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"kubernetes.default\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"kubernetes.default.svc\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"kubernetes.default.svc.cluster\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"kubernetes.default.svc.cluster.local\"</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"string\">\"key\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"algo\"</span>: <span class=\"string\">\"rsa\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"size\"</span>: 2048</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"names\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">\"C\"</span>: <span class=\"string\">\"CN\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"L\"</span>: <span class=\"string\">\"Beijing\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"ST\"</span>: <span class=\"string\">\"Beijing\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"O\"</span>: <span class=\"string\">\"k8s\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"OU\"</span>: <span class=\"string\">\"System\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EOF</span><br><span class=\"line\"></span><br><span class=\"line\">sed -i <span class=\"string\">\"s/&lt;&lt;IPADDRS&gt;&gt;/<span class=\"variable\">$IP_ADDRS</span>/g\"</span> server-csr.json</span><br><span class=\"line\"></span><br><span class=\"line\">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes server-csr.json | cfssljson -bare server</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#----------------</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"string\">\"\\n开始生成admin证书: admin.pem, admin-key.pem, admin.csr\"</span></span><br><span class=\"line\">cat &gt; admin-csr.json &lt;&lt;EOF</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"CN\"</span>: <span class=\"string\">\"admin\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"hosts\"</span>: [],</span><br><span class=\"line\">  <span class=\"string\">\"key\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"algo\"</span>: <span class=\"string\">\"rsa\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"size\"</span>: 2048</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"names\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">\"C\"</span>: <span class=\"string\">\"CN\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"L\"</span>: <span class=\"string\">\"Beijing\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"ST\"</span>: <span class=\"string\">\"Beijing\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"O\"</span>: <span class=\"string\">\"system:masters\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"OU\"</span>: <span class=\"string\">\"System\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EOF</span><br><span class=\"line\"></span><br><span class=\"line\">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes admin-csr.json | cfssljson -bare admin</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#---------</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"string\">\"\\n开始生成kube-proxy证书: kube-proxy.pem, kube-proxy-key.pem, kube-proxy.csr\"</span></span><br><span class=\"line\">cat &gt; kube-proxy-csr.json &lt;&lt;EOF</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"CN\"</span>: <span class=\"string\">\"system:kube-proxy\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"hosts\"</span>: [],</span><br><span class=\"line\">  <span class=\"string\">\"key\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"algo\"</span>: <span class=\"string\">\"rsa\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"size\"</span>: 2048</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"names\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">\"C\"</span>: <span class=\"string\">\"CN\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"L\"</span>: <span class=\"string\">\"Beijing\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"ST\"</span>: <span class=\"string\">\"Beijing\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"O\"</span>: <span class=\"string\">\"k8s\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"OU\"</span>: <span class=\"string\">\"System\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EOF</span><br><span class=\"line\"></span><br><span class=\"line\">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-proxy-csr.json | cfssljson -bare kube-proxy</span><br></pre></td></tr></table></figure>\n\n<p>执行完脚本后如果没有任何报错则会在当前目录下生成上述K8s需要的证书文件。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ls</span><br><span class=\"line\">admin-csr.json\t\tca-key.pem\t\tclient.pem\t\tserver-key.pem</span><br><span class=\"line\">admin-key.pem\t\tca.csr\t\t\tkube-proxy-csr.json\tserver.csr</span><br><span class=\"line\">admin.csr\t\tca.pem\t\t\tkube-proxy-key.pem\tserver.pem</span><br><span class=\"line\">admin.pem\t\tclient-csr.json\t\tkube-proxy.csr</span><br><span class=\"line\">ca-config.json\t\tclient-key.pem\t\tkube-proxy.pem</span><br><span class=\"line\">ca-csr.json\t\tclient.csr\t\tserver-csr.json</span><br></pre></td></tr></table></figure>"},{"title":"etcd安装及证书创建","_content":"本章将介绍etcd的安装以及x509证书的创建，K8s的数据库存储使用的是etcd，为了保证集群K8s各组件都需要使用x509证书对通信进行加密和认证，所以etcd也需要创建x509证书再传给kube-apiserver使用。\n\n<!--more-->\n\n本文使用的etcd版本为__v3.4.2__。\n\n# 安装etcd\netcd是Go语言编写的项目，安装方式十分简单，只需要下载源码然后执行源码目录中的 build 程序就能编译生成二进制文件到源码目录下的./bin目录。源码编译的机器环境必须要先装好Go语言环境，但运行etcd的服务器上并不需要装Go语言环境，下面直接给出Dockerfile：\n\n```Dockerfile\nFROM golang:1.12 as dev\n\nRUN git clone https://github.com/etcd-io/etcd.git -b v3.4.2 /home/etcd\nWORKDIR /home/etcd\nRUN ./build\n\nFROM ubuntu:18.04\n\nCOPY --from=dev /home/etcd/bin /usr/bin\n\nWORKDIR /root\n\nEXPOSE 2379\nENTRYPOINT [\"etcd\"]\n```\n\n# 生成证书\n本文使用CloudFlare的PKI工具集cfssl创建证书。\n\n## 安装cfssl\n```sh\nwget -O cfssl https://pkg.cfssl.org/R1.2/cfssl_linux-amd64\nchmod +x cfssl && mv cfssl /usr/bin/\nwget -O cfssljson https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64\nchmod +x cfssljson && mv cfssljson /usr/bin/\n```\n\n## 创建CA根证书配置文件\n新增 ca-config.json 文件，内容如下：\n```json\n{\n    \"signing\": {\n        \"default\": {\n            \"expiry\": \"8760h\"\n        },\n        \"profiles\": {\n            \"server\": {\n                \"expiry\": \"8760h\",\n                \"usages\": [\n                    \"signing\",\n                    \"key encipherment\",\n                    \"server auth\"\n                ]\n            },\n            \"client\": {\n                \"expiry\": \"8760h\",\n                \"usages\": [\n                    \"signing\",\n                    \"key encipherment\",\n                    \"client auth\"\n                ]\n            },\n            \"peer\": {\n                \"expiry\": \"8760h\",\n                \"usages\": [\n                    \"signing\",\n                    \"key encipherment\",\n                    \"server auth\",\n                    \"client auth\"\n                ]\n            }\n        }\n    }\n}\n```\n\n读者可以根据实际情况修改上述配置。\n* profiles：指定了不同角色的配置信息。服务端使用server，客户端使用client，集群节点间认证使用peer。\n* expiry：指定了证书的过期时间为8760小时（即1年）\n\n## 创建CA根证书证书签名请求\n新增 ca-csr.json 文件，内容如下：\n```json\n{\n    \"CN\": \"kubernetes\",\n    \"key\": {\n        \"algo\": \"rsa\",\n        \"size\": 2048\n    },\n    \"names\": [\n        {\n            \"C\": \"CN\",\n            \"L\": \"BeiJing\",\n            \"O\": \"Ctyun\",\n            \"ST\": \"BeiJing\",\n            \"OU\": \"ops\"\n        }\n    ]\n}\n```\n\n然后执行如下命令生成CA证书：\n```sh\ncfssl gencert -initca ca-csr.json | cfssljson -bare ca\n```\n执行完上述指令后就能在目录下看到新增的ca-key.pem（私钥）、ca.csr（证书签名请求）、ca.pem（证书）文件。\n\n## 创建服务器和客户端证书\n根据默认配置文件进行修改：cfssl print-defaults csr > server-csr.json\n主要修改部分如下：\n```json\n\"CN\": \"test.coreos.com\",\n\"hosts\": [\n\t\"server.coreos.org\",\n\t\"*.coreos.org\"\n],\n```\n\n执行下面的命令生成服务端证书：\n```sh\ncfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=server server-csr.json | cfssljson -bare server\n```\n-profile指定了使用ca-config.json中的profile。  \n执行完指令后会生成server.csr、server-key.pem、server.pem三个文件。\n\n用同样的方法创建客户端证书即可。\n\n# 运行etcd\n创建完证书后，把证书文件同步到Docker容器中，并为etcd启动参数指定证书文件，命令如下：\n```sh\ndocker run -v $PWD/cert:/root/cert -p2379:2379 --name etcd etcd:3.4.2 --cert-file=/root/cert/server.pem --key-file=/root/cert/server-key.pem --advertise-client-urls=https://0.0.0.0:2379 --listen-client-urls=https://0.0.0.0:2379\n```\n\n然后进行本地测试，确保证书认证功能是开启的。\n```sh\n$ docker exec -ti d2a2eca21ffe /bin/sh\n# 客户端不使用证书进行存取操作得到报错信息\n$ etcdctl get foo\n{\"level\":\"warn\",\"ts\":\"2019-10-28T03:18:06.822Z\",\"caller\":\"clientv3/retry_interceptor.go:61\",\"msg\":\"retrying of unary invoker failed\",\"target\":\"endpoint://client-d8d946a9-af43-4824-8d87-16754c8a0c94/127.0.0.1:2379\",\"attempt\":0,\"error\":\"rpc error: code = DeadlineExceeded desc = latest connection error: connection closed\"}\nError: context deadline exceeded\n# 客户端使用证书进行操作，响应成功\n$ etcdctl --cacert=\"/root/cert/ca.pem\" put foo abc\nOK\n$ etcdctl --cacert=\"/root/cert/ca.pem\" get foo\nabc\nok\n```\n\n因为开放的是HTTPS协议，还可以直接通过curl或postman进行测试：\n```sh\n$ curl --cacert cert/ca.crt https://127.0.0.1:2379/v2/keys/foo -XPUT -d value=bar -v\n```","source":"_drafts/etcd.md","raw":"---\ntitle: \"etcd安装及证书创建\"\ncategory: k8s\n---\n本章将介绍etcd的安装以及x509证书的创建，K8s的数据库存储使用的是etcd，为了保证集群K8s各组件都需要使用x509证书对通信进行加密和认证，所以etcd也需要创建x509证书再传给kube-apiserver使用。\n\n<!--more-->\n\n本文使用的etcd版本为__v3.4.2__。\n\n# 安装etcd\netcd是Go语言编写的项目，安装方式十分简单，只需要下载源码然后执行源码目录中的 build 程序就能编译生成二进制文件到源码目录下的./bin目录。源码编译的机器环境必须要先装好Go语言环境，但运行etcd的服务器上并不需要装Go语言环境，下面直接给出Dockerfile：\n\n```Dockerfile\nFROM golang:1.12 as dev\n\nRUN git clone https://github.com/etcd-io/etcd.git -b v3.4.2 /home/etcd\nWORKDIR /home/etcd\nRUN ./build\n\nFROM ubuntu:18.04\n\nCOPY --from=dev /home/etcd/bin /usr/bin\n\nWORKDIR /root\n\nEXPOSE 2379\nENTRYPOINT [\"etcd\"]\n```\n\n# 生成证书\n本文使用CloudFlare的PKI工具集cfssl创建证书。\n\n## 安装cfssl\n```sh\nwget -O cfssl https://pkg.cfssl.org/R1.2/cfssl_linux-amd64\nchmod +x cfssl && mv cfssl /usr/bin/\nwget -O cfssljson https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64\nchmod +x cfssljson && mv cfssljson /usr/bin/\n```\n\n## 创建CA根证书配置文件\n新增 ca-config.json 文件，内容如下：\n```json\n{\n    \"signing\": {\n        \"default\": {\n            \"expiry\": \"8760h\"\n        },\n        \"profiles\": {\n            \"server\": {\n                \"expiry\": \"8760h\",\n                \"usages\": [\n                    \"signing\",\n                    \"key encipherment\",\n                    \"server auth\"\n                ]\n            },\n            \"client\": {\n                \"expiry\": \"8760h\",\n                \"usages\": [\n                    \"signing\",\n                    \"key encipherment\",\n                    \"client auth\"\n                ]\n            },\n            \"peer\": {\n                \"expiry\": \"8760h\",\n                \"usages\": [\n                    \"signing\",\n                    \"key encipherment\",\n                    \"server auth\",\n                    \"client auth\"\n                ]\n            }\n        }\n    }\n}\n```\n\n读者可以根据实际情况修改上述配置。\n* profiles：指定了不同角色的配置信息。服务端使用server，客户端使用client，集群节点间认证使用peer。\n* expiry：指定了证书的过期时间为8760小时（即1年）\n\n## 创建CA根证书证书签名请求\n新增 ca-csr.json 文件，内容如下：\n```json\n{\n    \"CN\": \"kubernetes\",\n    \"key\": {\n        \"algo\": \"rsa\",\n        \"size\": 2048\n    },\n    \"names\": [\n        {\n            \"C\": \"CN\",\n            \"L\": \"BeiJing\",\n            \"O\": \"Ctyun\",\n            \"ST\": \"BeiJing\",\n            \"OU\": \"ops\"\n        }\n    ]\n}\n```\n\n然后执行如下命令生成CA证书：\n```sh\ncfssl gencert -initca ca-csr.json | cfssljson -bare ca\n```\n执行完上述指令后就能在目录下看到新增的ca-key.pem（私钥）、ca.csr（证书签名请求）、ca.pem（证书）文件。\n\n## 创建服务器和客户端证书\n根据默认配置文件进行修改：cfssl print-defaults csr > server-csr.json\n主要修改部分如下：\n```json\n\"CN\": \"test.coreos.com\",\n\"hosts\": [\n\t\"server.coreos.org\",\n\t\"*.coreos.org\"\n],\n```\n\n执行下面的命令生成服务端证书：\n```sh\ncfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=server server-csr.json | cfssljson -bare server\n```\n-profile指定了使用ca-config.json中的profile。  \n执行完指令后会生成server.csr、server-key.pem、server.pem三个文件。\n\n用同样的方法创建客户端证书即可。\n\n# 运行etcd\n创建完证书后，把证书文件同步到Docker容器中，并为etcd启动参数指定证书文件，命令如下：\n```sh\ndocker run -v $PWD/cert:/root/cert -p2379:2379 --name etcd etcd:3.4.2 --cert-file=/root/cert/server.pem --key-file=/root/cert/server-key.pem --advertise-client-urls=https://0.0.0.0:2379 --listen-client-urls=https://0.0.0.0:2379\n```\n\n然后进行本地测试，确保证书认证功能是开启的。\n```sh\n$ docker exec -ti d2a2eca21ffe /bin/sh\n# 客户端不使用证书进行存取操作得到报错信息\n$ etcdctl get foo\n{\"level\":\"warn\",\"ts\":\"2019-10-28T03:18:06.822Z\",\"caller\":\"clientv3/retry_interceptor.go:61\",\"msg\":\"retrying of unary invoker failed\",\"target\":\"endpoint://client-d8d946a9-af43-4824-8d87-16754c8a0c94/127.0.0.1:2379\",\"attempt\":0,\"error\":\"rpc error: code = DeadlineExceeded desc = latest connection error: connection closed\"}\nError: context deadline exceeded\n# 客户端使用证书进行操作，响应成功\n$ etcdctl --cacert=\"/root/cert/ca.pem\" put foo abc\nOK\n$ etcdctl --cacert=\"/root/cert/ca.pem\" get foo\nabc\nok\n```\n\n因为开放的是HTTPS协议，还可以直接通过curl或postman进行测试：\n```sh\n$ curl --cacert cert/ca.crt https://127.0.0.1:2379/v2/keys/foo -XPUT -d value=bar -v\n```","slug":"etcd","published":0,"date":"2020-01-16T17:23:25.488Z","updated":"2019-10-28T08:51:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck679mtrw0008lbmdira9vvo1","content":"<p>本章将介绍etcd的安装以及x509证书的创建，K8s的数据库存储使用的是etcd，为了保证集群K8s各组件都需要使用x509证书对通信进行加密和认证，所以etcd也需要创建x509证书再传给kube-apiserver使用。</p>\n<a id=\"more\"></a>\n\n<p>本文使用的etcd版本为<strong>v3.4.2</strong>。</p>\n<h1 id=\"安装etcd\"><a href=\"#安装etcd\" class=\"headerlink\" title=\"安装etcd\"></a>安装etcd</h1><p>etcd是Go语言编写的项目，安装方式十分简单，只需要下载源码然后执行源码目录中的 build 程序就能编译生成二进制文件到源码目录下的./bin目录。源码编译的机器环境必须要先装好Go语言环境，但运行etcd的服务器上并不需要装Go语言环境，下面直接给出Dockerfile：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> golang:<span class=\"number\">1.12</span> as dev</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> git <span class=\"built_in\">clone</span> https://github.com/etcd-io/etcd.git -b v3.4.2 /home/etcd</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"bash\"> /home/etcd</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> ./build</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> ubuntu:<span class=\"number\">18.04</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"bash\"> --from=dev /home/etcd/bin /usr/bin</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"bash\"> /root</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">2379</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"bash\"> [<span class=\"string\">\"etcd\"</span>]</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"生成证书\"><a href=\"#生成证书\" class=\"headerlink\" title=\"生成证书\"></a>生成证书</h1><p>本文使用CloudFlare的PKI工具集cfssl创建证书。</p>\n<h2 id=\"安装cfssl\"><a href=\"#安装cfssl\" class=\"headerlink\" title=\"安装cfssl\"></a>安装cfssl</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -O cfssl https://pkg.cfssl.org/R1.2/cfssl_linux-amd64</span><br><span class=\"line\">chmod +x cfssl &amp;&amp; mv cfssl /usr/bin/</span><br><span class=\"line\">wget -O cfssljson https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64</span><br><span class=\"line\">chmod +x cfssljson &amp;&amp; mv cfssljson /usr/bin/</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建CA根证书配置文件\"><a href=\"#创建CA根证书配置文件\" class=\"headerlink\" title=\"创建CA根证书配置文件\"></a>创建CA根证书配置文件</h2><p>新增 ca-config.json 文件，内容如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"signing\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"default\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"expiry\"</span>: <span class=\"string\">\"8760h\"</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">\"profiles\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"server\"</span>: &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"expiry\"</span>: <span class=\"string\">\"8760h\"</span>,</span><br><span class=\"line\">                <span class=\"attr\">\"usages\"</span>: [</span><br><span class=\"line\">                    <span class=\"string\">\"signing\"</span>,</span><br><span class=\"line\">                    <span class=\"string\">\"key encipherment\"</span>,</span><br><span class=\"line\">                    <span class=\"string\">\"server auth\"</span></span><br><span class=\"line\">                ]</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"attr\">\"client\"</span>: &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"expiry\"</span>: <span class=\"string\">\"8760h\"</span>,</span><br><span class=\"line\">                <span class=\"attr\">\"usages\"</span>: [</span><br><span class=\"line\">                    <span class=\"string\">\"signing\"</span>,</span><br><span class=\"line\">                    <span class=\"string\">\"key encipherment\"</span>,</span><br><span class=\"line\">                    <span class=\"string\">\"client auth\"</span></span><br><span class=\"line\">                ]</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"attr\">\"peer\"</span>: &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"expiry\"</span>: <span class=\"string\">\"8760h\"</span>,</span><br><span class=\"line\">                <span class=\"attr\">\"usages\"</span>: [</span><br><span class=\"line\">                    <span class=\"string\">\"signing\"</span>,</span><br><span class=\"line\">                    <span class=\"string\">\"key encipherment\"</span>,</span><br><span class=\"line\">                    <span class=\"string\">\"server auth\"</span>,</span><br><span class=\"line\">                    <span class=\"string\">\"client auth\"</span></span><br><span class=\"line\">                ]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>读者可以根据实际情况修改上述配置。</p>\n<ul>\n<li>profiles：指定了不同角色的配置信息。服务端使用server，客户端使用client，集群节点间认证使用peer。</li>\n<li>expiry：指定了证书的过期时间为8760小时（即1年）</li>\n</ul>\n<h2 id=\"创建CA根证书证书签名请求\"><a href=\"#创建CA根证书证书签名请求\" class=\"headerlink\" title=\"创建CA根证书证书签名请求\"></a>创建CA根证书证书签名请求</h2><p>新增 ca-csr.json 文件，内容如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"CN\"</span>: <span class=\"string\">\"kubernetes\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"key\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"algo\"</span>: <span class=\"string\">\"rsa\"</span>,</span><br><span class=\"line\">        <span class=\"attr\">\"size\"</span>: <span class=\"number\">2048</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"names\"</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"C\"</span>: <span class=\"string\">\"CN\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"L\"</span>: <span class=\"string\">\"BeiJing\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"O\"</span>: <span class=\"string\">\"Ctyun\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"ST\"</span>: <span class=\"string\">\"BeiJing\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"OU\"</span>: <span class=\"string\">\"ops\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后执行如下命令生成CA证书：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cfssl gencert -initca ca-csr.json | cfssljson -bare ca</span><br></pre></td></tr></table></figure>\n\n<p>执行完上述指令后就能在目录下看到新增的ca-key.pem（私钥）、ca.csr（证书签名请求）、ca.pem（证书）文件。</p>\n<h2 id=\"创建服务器和客户端证书\"><a href=\"#创建服务器和客户端证书\" class=\"headerlink\" title=\"创建服务器和客户端证书\"></a>创建服务器和客户端证书</h2><p>根据默认配置文件进行修改：cfssl print-defaults csr &gt; server-csr.json<br>主要修改部分如下：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"CN\": \"test.coreos.com\",</span><br><span class=\"line\">\"hosts\": [</span><br><span class=\"line\">\t\"server.coreos.org\",</span><br><span class=\"line\">\t<span class=\"string\">\"*.coreos.org\"</span></span><br><span class=\"line\">],</span><br></pre></td></tr></table></figure>\n\n<p>执行下面的命令生成服务端证书：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=server server-csr.json | cfssljson -bare server</span><br></pre></td></tr></table></figure>\n\n<p>-profile指定了使用ca-config.json中的profile。<br>执行完指令后会生成server.csr、server-key.pem、server.pem三个文件。</p>\n<p>用同样的方法创建客户端证书即可。</p>\n<h1 id=\"运行etcd\"><a href=\"#运行etcd\" class=\"headerlink\" title=\"运行etcd\"></a>运行etcd</h1><p>创建完证书后，把证书文件同步到Docker容器中，并为etcd启动参数指定证书文件，命令如下：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -v <span class=\"variable\">$PWD</span>/cert:/root/cert -p2379:2379 --name etcd etcd:3.4.2 --cert-file=/root/cert/server.pem --key-file=/root/cert/server-key.pem --advertise-client-urls=https://0.0.0.0:2379 --listen-client-urls=https://0.0.0.0:2379</span><br></pre></td></tr></table></figure>\n\n<p>然后进行本地测试，确保证书认证功能是开启的。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker <span class=\"built_in\">exec</span> -ti d2a2eca21ffe /bin/sh</span><br><span class=\"line\"><span class=\"comment\"># 客户端不使用证书进行存取操作得到报错信息</span></span><br><span class=\"line\">$ etcdctl get foo</span><br><span class=\"line\">&#123;<span class=\"string\">\"level\"</span>:<span class=\"string\">\"warn\"</span>,<span class=\"string\">\"ts\"</span>:<span class=\"string\">\"2019-10-28T03:18:06.822Z\"</span>,<span class=\"string\">\"caller\"</span>:<span class=\"string\">\"clientv3/retry_interceptor.go:61\"</span>,<span class=\"string\">\"msg\"</span>:<span class=\"string\">\"retrying of unary invoker failed\"</span>,<span class=\"string\">\"target\"</span>:<span class=\"string\">\"endpoint://client-d8d946a9-af43-4824-8d87-16754c8a0c94/127.0.0.1:2379\"</span>,<span class=\"string\">\"attempt\"</span>:0,<span class=\"string\">\"error\"</span>:<span class=\"string\">\"rpc error: code = DeadlineExceeded desc = latest connection error: connection closed\"</span>&#125;</span><br><span class=\"line\">Error: context deadline exceeded</span><br><span class=\"line\"><span class=\"comment\"># 客户端使用证书进行操作，响应成功</span></span><br><span class=\"line\">$ etcdctl --cacert=<span class=\"string\">\"/root/cert/ca.pem\"</span> put foo abc</span><br><span class=\"line\">OK</span><br><span class=\"line\">$ etcdctl --cacert=<span class=\"string\">\"/root/cert/ca.pem\"</span> get foo</span><br><span class=\"line\">abc</span><br><span class=\"line\">ok</span><br></pre></td></tr></table></figure>\n\n<p>因为开放的是HTTPS协议，还可以直接通过curl或postman进行测试：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl --cacert cert/ca.crt https://127.0.0.1:2379/v2/keys/foo -XPUT -d value=bar -v</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>本章将介绍etcd的安装以及x509证书的创建，K8s的数据库存储使用的是etcd，为了保证集群K8s各组件都需要使用x509证书对通信进行加密和认证，所以etcd也需要创建x509证书再传给kube-apiserver使用。</p>","more":"<p>本文使用的etcd版本为<strong>v3.4.2</strong>。</p>\n<h1 id=\"安装etcd\"><a href=\"#安装etcd\" class=\"headerlink\" title=\"安装etcd\"></a>安装etcd</h1><p>etcd是Go语言编写的项目，安装方式十分简单，只需要下载源码然后执行源码目录中的 build 程序就能编译生成二进制文件到源码目录下的./bin目录。源码编译的机器环境必须要先装好Go语言环境，但运行etcd的服务器上并不需要装Go语言环境，下面直接给出Dockerfile：</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> golang:<span class=\"number\">1.12</span> as dev</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> git <span class=\"built_in\">clone</span> https://github.com/etcd-io/etcd.git -b v3.4.2 /home/etcd</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"bash\"> /home/etcd</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> ./build</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> ubuntu:<span class=\"number\">18.04</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"bash\"> --from=dev /home/etcd/bin /usr/bin</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"bash\"> /root</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">2379</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"bash\"> [<span class=\"string\">\"etcd\"</span>]</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"生成证书\"><a href=\"#生成证书\" class=\"headerlink\" title=\"生成证书\"></a>生成证书</h1><p>本文使用CloudFlare的PKI工具集cfssl创建证书。</p>\n<h2 id=\"安装cfssl\"><a href=\"#安装cfssl\" class=\"headerlink\" title=\"安装cfssl\"></a>安装cfssl</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -O cfssl https://pkg.cfssl.org/R1.2/cfssl_linux-amd64</span><br><span class=\"line\">chmod +x cfssl &amp;&amp; mv cfssl /usr/bin/</span><br><span class=\"line\">wget -O cfssljson https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64</span><br><span class=\"line\">chmod +x cfssljson &amp;&amp; mv cfssljson /usr/bin/</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建CA根证书配置文件\"><a href=\"#创建CA根证书配置文件\" class=\"headerlink\" title=\"创建CA根证书配置文件\"></a>创建CA根证书配置文件</h2><p>新增 ca-config.json 文件，内容如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"signing\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"default\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"expiry\"</span>: <span class=\"string\">\"8760h\"</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">\"profiles\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"server\"</span>: &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"expiry\"</span>: <span class=\"string\">\"8760h\"</span>,</span><br><span class=\"line\">                <span class=\"attr\">\"usages\"</span>: [</span><br><span class=\"line\">                    <span class=\"string\">\"signing\"</span>,</span><br><span class=\"line\">                    <span class=\"string\">\"key encipherment\"</span>,</span><br><span class=\"line\">                    <span class=\"string\">\"server auth\"</span></span><br><span class=\"line\">                ]</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"attr\">\"client\"</span>: &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"expiry\"</span>: <span class=\"string\">\"8760h\"</span>,</span><br><span class=\"line\">                <span class=\"attr\">\"usages\"</span>: [</span><br><span class=\"line\">                    <span class=\"string\">\"signing\"</span>,</span><br><span class=\"line\">                    <span class=\"string\">\"key encipherment\"</span>,</span><br><span class=\"line\">                    <span class=\"string\">\"client auth\"</span></span><br><span class=\"line\">                ]</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"attr\">\"peer\"</span>: &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"expiry\"</span>: <span class=\"string\">\"8760h\"</span>,</span><br><span class=\"line\">                <span class=\"attr\">\"usages\"</span>: [</span><br><span class=\"line\">                    <span class=\"string\">\"signing\"</span>,</span><br><span class=\"line\">                    <span class=\"string\">\"key encipherment\"</span>,</span><br><span class=\"line\">                    <span class=\"string\">\"server auth\"</span>,</span><br><span class=\"line\">                    <span class=\"string\">\"client auth\"</span></span><br><span class=\"line\">                ]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>读者可以根据实际情况修改上述配置。</p>\n<ul>\n<li>profiles：指定了不同角色的配置信息。服务端使用server，客户端使用client，集群节点间认证使用peer。</li>\n<li>expiry：指定了证书的过期时间为8760小时（即1年）</li>\n</ul>\n<h2 id=\"创建CA根证书证书签名请求\"><a href=\"#创建CA根证书证书签名请求\" class=\"headerlink\" title=\"创建CA根证书证书签名请求\"></a>创建CA根证书证书签名请求</h2><p>新增 ca-csr.json 文件，内容如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"CN\"</span>: <span class=\"string\">\"kubernetes\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"key\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"algo\"</span>: <span class=\"string\">\"rsa\"</span>,</span><br><span class=\"line\">        <span class=\"attr\">\"size\"</span>: <span class=\"number\">2048</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"names\"</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"C\"</span>: <span class=\"string\">\"CN\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"L\"</span>: <span class=\"string\">\"BeiJing\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"O\"</span>: <span class=\"string\">\"Ctyun\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"ST\"</span>: <span class=\"string\">\"BeiJing\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"OU\"</span>: <span class=\"string\">\"ops\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后执行如下命令生成CA证书：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cfssl gencert -initca ca-csr.json | cfssljson -bare ca</span><br></pre></td></tr></table></figure>\n\n<p>执行完上述指令后就能在目录下看到新增的ca-key.pem（私钥）、ca.csr（证书签名请求）、ca.pem（证书）文件。</p>\n<h2 id=\"创建服务器和客户端证书\"><a href=\"#创建服务器和客户端证书\" class=\"headerlink\" title=\"创建服务器和客户端证书\"></a>创建服务器和客户端证书</h2><p>根据默认配置文件进行修改：cfssl print-defaults csr &gt; server-csr.json<br>主要修改部分如下：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"CN\": \"test.coreos.com\",</span><br><span class=\"line\">\"hosts\": [</span><br><span class=\"line\">\t\"server.coreos.org\",</span><br><span class=\"line\">\t<span class=\"string\">\"*.coreos.org\"</span></span><br><span class=\"line\">],</span><br></pre></td></tr></table></figure>\n\n<p>执行下面的命令生成服务端证书：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=server server-csr.json | cfssljson -bare server</span><br></pre></td></tr></table></figure>\n\n<p>-profile指定了使用ca-config.json中的profile。<br>执行完指令后会生成server.csr、server-key.pem、server.pem三个文件。</p>\n<p>用同样的方法创建客户端证书即可。</p>\n<h1 id=\"运行etcd\"><a href=\"#运行etcd\" class=\"headerlink\" title=\"运行etcd\"></a>运行etcd</h1><p>创建完证书后，把证书文件同步到Docker容器中，并为etcd启动参数指定证书文件，命令如下：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -v <span class=\"variable\">$PWD</span>/cert:/root/cert -p2379:2379 --name etcd etcd:3.4.2 --cert-file=/root/cert/server.pem --key-file=/root/cert/server-key.pem --advertise-client-urls=https://0.0.0.0:2379 --listen-client-urls=https://0.0.0.0:2379</span><br></pre></td></tr></table></figure>\n\n<p>然后进行本地测试，确保证书认证功能是开启的。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker <span class=\"built_in\">exec</span> -ti d2a2eca21ffe /bin/sh</span><br><span class=\"line\"><span class=\"comment\"># 客户端不使用证书进行存取操作得到报错信息</span></span><br><span class=\"line\">$ etcdctl get foo</span><br><span class=\"line\">&#123;<span class=\"string\">\"level\"</span>:<span class=\"string\">\"warn\"</span>,<span class=\"string\">\"ts\"</span>:<span class=\"string\">\"2019-10-28T03:18:06.822Z\"</span>,<span class=\"string\">\"caller\"</span>:<span class=\"string\">\"clientv3/retry_interceptor.go:61\"</span>,<span class=\"string\">\"msg\"</span>:<span class=\"string\">\"retrying of unary invoker failed\"</span>,<span class=\"string\">\"target\"</span>:<span class=\"string\">\"endpoint://client-d8d946a9-af43-4824-8d87-16754c8a0c94/127.0.0.1:2379\"</span>,<span class=\"string\">\"attempt\"</span>:0,<span class=\"string\">\"error\"</span>:<span class=\"string\">\"rpc error: code = DeadlineExceeded desc = latest connection error: connection closed\"</span>&#125;</span><br><span class=\"line\">Error: context deadline exceeded</span><br><span class=\"line\"><span class=\"comment\"># 客户端使用证书进行操作，响应成功</span></span><br><span class=\"line\">$ etcdctl --cacert=<span class=\"string\">\"/root/cert/ca.pem\"</span> put foo abc</span><br><span class=\"line\">OK</span><br><span class=\"line\">$ etcdctl --cacert=<span class=\"string\">\"/root/cert/ca.pem\"</span> get foo</span><br><span class=\"line\">abc</span><br><span class=\"line\">ok</span><br></pre></td></tr></table></figure>\n\n<p>因为开放的是HTTPS协议，还可以直接通过curl或postman进行测试：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl --cacert cert/ca.crt https://127.0.0.1:2379/v2/keys/foo -XPUT -d value=bar -v</span><br></pre></td></tr></table></figure>"},{"title":"k8s Deployment配置详解","_content":"\n```yaml\napiVersion: extensions/v1beta1   #接口版本\nkind: Deployment                 #接口类型\nmetadata:\n  name: cango-demo               #Deployment名称\n  namespace: cango-prd           #命名空间\n  labels:\n    app: cango-demo              #标签\nspec:\n  replicas: 3\n   strategy:\n    rollingUpdate:  ##由于replicas为3,则整个升级,pod个数在2-4个之间\n      maxSurge: 1      #滚动升级时会先启动1个pod\n      maxUnavailable: 1 #滚动升级时允许的最大Unavailable的pod个数\n  template:         \n    metadata:\n      labels:\n        app: cango-demo  #模板名称必填\n    sepc: #定义容器模板，该模板可以包含多个容器\n      containers:                                                                   \n        - name: cango-demo                                                           #镜像名称\n          image: swr.cn-east-2.myhuaweicloud.com/cango-prd/cango-demo:0.0.1-SNAPSHOT #镜像地址\n          command: [ \"/bin/sh\",\"-c\",\"cat /etc/config/path/to/special-key\" ]    #启动命令\n          args:                                                                #启动参数\n            - '-storage.local.retention=$(STORAGE_RETENTION)'\n            - '-storage.local.memory-chunks=$(STORAGE_MEMORY_CHUNKS)'\n            - '-config.file=/etc/prometheus/prometheus.yml'\n            - '-alertmanager.url=http://alertmanager:9093/alertmanager'\n            - '-web.external-url=$(EXTERNAL_URL)'\n    #如果command和args均没有写，那么用Docker默认的配置。\n    #如果command写了，但args没有写，那么Docker默认的配置会被忽略而且仅仅执行.yaml文件的command（不带任何参数的）。\n    #如果command没写，但args写了，那么Docker默认配置的ENTRYPOINT的命令行会被执行，但是调用的参数是.yaml中的args。\n    #如果如果command和args都写了，那么Docker默认的配置被忽略，使用.yaml的配置。\n          imagePullPolicy: IfNotPresent  #如果不存在则拉取\n          livenessProbe:       #表示container是否处于live状态。如果LivenessProbe失败，LivenessProbe将会通知kubelet对应的container不健康了。随后kubelet将kill掉container，并根据RestarPolicy进行进一步的操作。默认情况下LivenessProbe在第一次检测之前初始化值为Success，如果container没有提供LivenessProbe，则也认为是Success；\n            httpGet:\n              path: /health #如果没有心跳检测接口就为/\n              port: 8080\n              scheme: HTTP\n            initialDelaySeconds: 60 ##启动后延时多久开始运行检测\n            timeoutSeconds: 5\n            successThreshold: 1\n            failureThreshold: 5\n            readinessProbe:\n          readinessProbe:\n            httpGet:\n              path: /health #如果没有心跳检测接口就为/\n              port: 8080\n              scheme: HTTP\n            initialDelaySeconds: 30 ##启动后延时多久开始运行检测\n            timeoutSeconds: 5\n            successThreshold: 1\n            failureThreshold: 5\n          resources:              ##CPU内存限制\n            requests:\n              cpu: 2\n              memory: 2048Mi\n            limits:\n              cpu: 2\n              memory: 2048Mi\n          env:                    ##通过环境变量的方式，直接传递pod=自定义Linux OS环境变量\n            - name: LOCAL_KEY     #本地Key\n              value: value\n            - name: CONFIG_MAP_KEY  #局策略可使用configMap的配置Key，\n              valueFrom:\n                configMapKeyRef:\n                  name: special-config   #configmap中找到name为special-config\n                  key: special.type      #找到name为special-config里data下的key\n          ports:\n            - name: http\n              containerPort: 8080 #对service暴露端口\n          volumeMounts:     #挂载volumes中定义的磁盘\n          - name: log-cache\n            mount: /tmp/log\n          - name: sdb       #普通用法，该卷跟随容器销毁，挂载一个目录\n            mountPath: /data/media    \n          - name: nfs-client-root    #直接挂载硬盘方法，如挂载下面的nfs目录到/mnt/nfs\n            mountPath: /mnt/nfs\n          - name: example-volume-config  #高级用法第1种，将ConfigMap的log-script,backup-script分别挂载到/etc/config目录下的一个相对路径path/to/...下，如果存在同名文件，直接覆盖。\n            mountPath: /etc/config       \n          - name: rbd-pvc                #高级用法第2中，挂载PVC(PresistentVolumeClaim)\n\n#使用volume将ConfigMap作为文件或目录直接挂载，其中每一个key-value键值对都会生成一个文件，key为文件名，value为内容，\n  volumes:  # 定义磁盘给上面volumeMounts挂载\n  - name: log-cache\n    emptyDir: {}\n  - name: sdb  #挂载宿主机上面的目录\n    hostPath:\n      path: /any/path/it/will/be/replaced\n  - name: example-volume-config  # 供ConfigMap文件内容到指定路径使用\n    configMap:\n      name: example-volume-config  #ConfigMap中名称\n      items:\n      - key: log-script           #ConfigMap中的Key\n        path: path/to/log-script  #指定目录下的一个相对路径path/to/log-script\n      - key: backup-script        #ConfigMap中的Key\n        path: path/to/backup-script  #指定目录下的一个相对路径path/to/backup-script\n  - name: nfs-client-root         #供挂载NFS存储类型\n    nfs:\n      server: 10.42.0.55          #NFS服务器地址\n      path: /opt/public           #showmount -e 看一下路径\n  - name: rbd-pvc                 #挂载PVC磁盘\n    persistentVolumeClaim:\n      claimName: rbd-pvc1         #挂载已经申请的pvc磁盘\n```","source":"_drafts/k8s-deploy.md","raw":"---\ntitle: \"k8s Deployment配置详解\"\ncategory: k8s\n---\n\n```yaml\napiVersion: extensions/v1beta1   #接口版本\nkind: Deployment                 #接口类型\nmetadata:\n  name: cango-demo               #Deployment名称\n  namespace: cango-prd           #命名空间\n  labels:\n    app: cango-demo              #标签\nspec:\n  replicas: 3\n   strategy:\n    rollingUpdate:  ##由于replicas为3,则整个升级,pod个数在2-4个之间\n      maxSurge: 1      #滚动升级时会先启动1个pod\n      maxUnavailable: 1 #滚动升级时允许的最大Unavailable的pod个数\n  template:         \n    metadata:\n      labels:\n        app: cango-demo  #模板名称必填\n    sepc: #定义容器模板，该模板可以包含多个容器\n      containers:                                                                   \n        - name: cango-demo                                                           #镜像名称\n          image: swr.cn-east-2.myhuaweicloud.com/cango-prd/cango-demo:0.0.1-SNAPSHOT #镜像地址\n          command: [ \"/bin/sh\",\"-c\",\"cat /etc/config/path/to/special-key\" ]    #启动命令\n          args:                                                                #启动参数\n            - '-storage.local.retention=$(STORAGE_RETENTION)'\n            - '-storage.local.memory-chunks=$(STORAGE_MEMORY_CHUNKS)'\n            - '-config.file=/etc/prometheus/prometheus.yml'\n            - '-alertmanager.url=http://alertmanager:9093/alertmanager'\n            - '-web.external-url=$(EXTERNAL_URL)'\n    #如果command和args均没有写，那么用Docker默认的配置。\n    #如果command写了，但args没有写，那么Docker默认的配置会被忽略而且仅仅执行.yaml文件的command（不带任何参数的）。\n    #如果command没写，但args写了，那么Docker默认配置的ENTRYPOINT的命令行会被执行，但是调用的参数是.yaml中的args。\n    #如果如果command和args都写了，那么Docker默认的配置被忽略，使用.yaml的配置。\n          imagePullPolicy: IfNotPresent  #如果不存在则拉取\n          livenessProbe:       #表示container是否处于live状态。如果LivenessProbe失败，LivenessProbe将会通知kubelet对应的container不健康了。随后kubelet将kill掉container，并根据RestarPolicy进行进一步的操作。默认情况下LivenessProbe在第一次检测之前初始化值为Success，如果container没有提供LivenessProbe，则也认为是Success；\n            httpGet:\n              path: /health #如果没有心跳检测接口就为/\n              port: 8080\n              scheme: HTTP\n            initialDelaySeconds: 60 ##启动后延时多久开始运行检测\n            timeoutSeconds: 5\n            successThreshold: 1\n            failureThreshold: 5\n            readinessProbe:\n          readinessProbe:\n            httpGet:\n              path: /health #如果没有心跳检测接口就为/\n              port: 8080\n              scheme: HTTP\n            initialDelaySeconds: 30 ##启动后延时多久开始运行检测\n            timeoutSeconds: 5\n            successThreshold: 1\n            failureThreshold: 5\n          resources:              ##CPU内存限制\n            requests:\n              cpu: 2\n              memory: 2048Mi\n            limits:\n              cpu: 2\n              memory: 2048Mi\n          env:                    ##通过环境变量的方式，直接传递pod=自定义Linux OS环境变量\n            - name: LOCAL_KEY     #本地Key\n              value: value\n            - name: CONFIG_MAP_KEY  #局策略可使用configMap的配置Key，\n              valueFrom:\n                configMapKeyRef:\n                  name: special-config   #configmap中找到name为special-config\n                  key: special.type      #找到name为special-config里data下的key\n          ports:\n            - name: http\n              containerPort: 8080 #对service暴露端口\n          volumeMounts:     #挂载volumes中定义的磁盘\n          - name: log-cache\n            mount: /tmp/log\n          - name: sdb       #普通用法，该卷跟随容器销毁，挂载一个目录\n            mountPath: /data/media    \n          - name: nfs-client-root    #直接挂载硬盘方法，如挂载下面的nfs目录到/mnt/nfs\n            mountPath: /mnt/nfs\n          - name: example-volume-config  #高级用法第1种，将ConfigMap的log-script,backup-script分别挂载到/etc/config目录下的一个相对路径path/to/...下，如果存在同名文件，直接覆盖。\n            mountPath: /etc/config       \n          - name: rbd-pvc                #高级用法第2中，挂载PVC(PresistentVolumeClaim)\n\n#使用volume将ConfigMap作为文件或目录直接挂载，其中每一个key-value键值对都会生成一个文件，key为文件名，value为内容，\n  volumes:  # 定义磁盘给上面volumeMounts挂载\n  - name: log-cache\n    emptyDir: {}\n  - name: sdb  #挂载宿主机上面的目录\n    hostPath:\n      path: /any/path/it/will/be/replaced\n  - name: example-volume-config  # 供ConfigMap文件内容到指定路径使用\n    configMap:\n      name: example-volume-config  #ConfigMap中名称\n      items:\n      - key: log-script           #ConfigMap中的Key\n        path: path/to/log-script  #指定目录下的一个相对路径path/to/log-script\n      - key: backup-script        #ConfigMap中的Key\n        path: path/to/backup-script  #指定目录下的一个相对路径path/to/backup-script\n  - name: nfs-client-root         #供挂载NFS存储类型\n    nfs:\n      server: 10.42.0.55          #NFS服务器地址\n      path: /opt/public           #showmount -e 看一下路径\n  - name: rbd-pvc                 #挂载PVC磁盘\n    persistentVolumeClaim:\n      claimName: rbd-pvc1         #挂载已经申请的pvc磁盘\n```","slug":"k8s-deploy","published":0,"date":"2020-01-16T17:23:25.488Z","updated":"2019-09-05T12:11:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck679mtrx000blbmdosyk169z","content":"<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">extensions/v1beta1</span>   <span class=\"comment\">#接口版本</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span>                 <span class=\"comment\">#接口类型</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> <span class=\"string\">cango-demo</span>               <span class=\"comment\">#Deployment名称</span></span><br><span class=\"line\"><span class=\"attr\">  namespace:</span> <span class=\"string\">cango-prd</span>           <span class=\"comment\">#命名空间</span></span><br><span class=\"line\"><span class=\"attr\">  labels:</span></span><br><span class=\"line\"><span class=\"attr\">    app:</span> <span class=\"string\">cango-demo</span>              <span class=\"comment\">#标签</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\"><span class=\"attr\">  replicas:</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"attr\">   strategy:</span></span><br><span class=\"line\"><span class=\"attr\">    rollingUpdate:</span>  <span class=\"comment\">##由于replicas为3,则整个升级,pod个数在2-4个之间</span></span><br><span class=\"line\"><span class=\"attr\">      maxSurge:</span> <span class=\"number\">1</span>      <span class=\"comment\">#滚动升级时会先启动1个pod</span></span><br><span class=\"line\"><span class=\"attr\">      maxUnavailable:</span> <span class=\"number\">1</span> <span class=\"comment\">#滚动升级时允许的最大Unavailable的pod个数</span></span><br><span class=\"line\"><span class=\"attr\">  template:</span>         </span><br><span class=\"line\"><span class=\"attr\">    metadata:</span></span><br><span class=\"line\"><span class=\"attr\">      labels:</span></span><br><span class=\"line\"><span class=\"attr\">        app:</span> <span class=\"string\">cango-demo</span>  <span class=\"comment\">#模板名称必填</span></span><br><span class=\"line\"><span class=\"attr\">    sepc:</span> <span class=\"comment\">#定义容器模板，该模板可以包含多个容器</span></span><br><span class=\"line\"><span class=\"attr\">      containers:</span>                                                                   </span><br><span class=\"line\"><span class=\"attr\">        - name:</span> <span class=\"string\">cango-demo</span>                                                           <span class=\"comment\">#镜像名称</span></span><br><span class=\"line\"><span class=\"attr\">          image:</span> <span class=\"string\">swr.cn-east-2.myhuaweicloud.com/cango-prd/cango-demo:0.0.1-SNAPSHOT</span> <span class=\"comment\">#镜像地址</span></span><br><span class=\"line\"><span class=\"attr\">          command:</span> <span class=\"string\">[</span> <span class=\"string\">\"/bin/sh\"</span><span class=\"string\">,\"-c\",\"cat</span> <span class=\"string\">/etc/config/path/to/special-key\"</span> <span class=\"string\">]</span>    <span class=\"comment\">#启动命令</span></span><br><span class=\"line\"><span class=\"attr\">          args:</span>                                                                <span class=\"comment\">#启动参数</span></span><br><span class=\"line\"><span class=\"bullet\">            -</span> <span class=\"string\">'-storage.local.retention=$(STORAGE_RETENTION)'</span></span><br><span class=\"line\"><span class=\"bullet\">            -</span> <span class=\"string\">'-storage.local.memory-chunks=$(STORAGE_MEMORY_CHUNKS)'</span></span><br><span class=\"line\"><span class=\"bullet\">            -</span> <span class=\"string\">'-config.file=/etc/prometheus/prometheus.yml'</span></span><br><span class=\"line\"><span class=\"bullet\">            -</span> <span class=\"string\">'-alertmanager.url=http://alertmanager:9093/alertmanager'</span></span><br><span class=\"line\"><span class=\"bullet\">            -</span> <span class=\"string\">'-web.external-url=$(EXTERNAL_URL)'</span></span><br><span class=\"line\">    <span class=\"comment\">#如果command和args均没有写，那么用Docker默认的配置。</span></span><br><span class=\"line\">    <span class=\"comment\">#如果command写了，但args没有写，那么Docker默认的配置会被忽略而且仅仅执行.yaml文件的command（不带任何参数的）。</span></span><br><span class=\"line\">    <span class=\"comment\">#如果command没写，但args写了，那么Docker默认配置的ENTRYPOINT的命令行会被执行，但是调用的参数是.yaml中的args。</span></span><br><span class=\"line\">    <span class=\"comment\">#如果如果command和args都写了，那么Docker默认的配置被忽略，使用.yaml的配置。</span></span><br><span class=\"line\"><span class=\"attr\">          imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span>  <span class=\"comment\">#如果不存在则拉取</span></span><br><span class=\"line\"><span class=\"attr\">          livenessProbe:</span>       <span class=\"comment\">#表示container是否处于live状态。如果LivenessProbe失败，LivenessProbe将会通知kubelet对应的container不健康了。随后kubelet将kill掉container，并根据RestarPolicy进行进一步的操作。默认情况下LivenessProbe在第一次检测之前初始化值为Success，如果container没有提供LivenessProbe，则也认为是Success；</span></span><br><span class=\"line\"><span class=\"attr\">            httpGet:</span></span><br><span class=\"line\"><span class=\"attr\">              path:</span> <span class=\"string\">/health</span> <span class=\"comment\">#如果没有心跳检测接口就为/</span></span><br><span class=\"line\"><span class=\"attr\">              port:</span> <span class=\"number\">8080</span></span><br><span class=\"line\"><span class=\"attr\">              scheme:</span> <span class=\"string\">HTTP</span></span><br><span class=\"line\"><span class=\"attr\">            initialDelaySeconds:</span> <span class=\"number\">60</span> <span class=\"comment\">##启动后延时多久开始运行检测</span></span><br><span class=\"line\"><span class=\"attr\">            timeoutSeconds:</span> <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"attr\">            successThreshold:</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attr\">            failureThreshold:</span> <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"attr\">            readinessProbe:</span></span><br><span class=\"line\"><span class=\"attr\">          readinessProbe:</span></span><br><span class=\"line\"><span class=\"attr\">            httpGet:</span></span><br><span class=\"line\"><span class=\"attr\">              path:</span> <span class=\"string\">/health</span> <span class=\"comment\">#如果没有心跳检测接口就为/</span></span><br><span class=\"line\"><span class=\"attr\">              port:</span> <span class=\"number\">8080</span></span><br><span class=\"line\"><span class=\"attr\">              scheme:</span> <span class=\"string\">HTTP</span></span><br><span class=\"line\"><span class=\"attr\">            initialDelaySeconds:</span> <span class=\"number\">30</span> <span class=\"comment\">##启动后延时多久开始运行检测</span></span><br><span class=\"line\"><span class=\"attr\">            timeoutSeconds:</span> <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"attr\">            successThreshold:</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attr\">            failureThreshold:</span> <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"attr\">          resources:</span>              <span class=\"comment\">##CPU内存限制</span></span><br><span class=\"line\"><span class=\"attr\">            requests:</span></span><br><span class=\"line\"><span class=\"attr\">              cpu:</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"attr\">              memory:</span> <span class=\"number\">2048</span><span class=\"string\">Mi</span></span><br><span class=\"line\"><span class=\"attr\">            limits:</span></span><br><span class=\"line\"><span class=\"attr\">              cpu:</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"attr\">              memory:</span> <span class=\"number\">2048</span><span class=\"string\">Mi</span></span><br><span class=\"line\"><span class=\"attr\">          env:</span>                    <span class=\"comment\">##通过环境变量的方式，直接传递pod=自定义Linux OS环境变量</span></span><br><span class=\"line\"><span class=\"attr\">            - name:</span> <span class=\"string\">LOCAL_KEY</span>     <span class=\"comment\">#本地Key</span></span><br><span class=\"line\"><span class=\"attr\">              value:</span> <span class=\"string\">value</span></span><br><span class=\"line\"><span class=\"attr\">            - name:</span> <span class=\"string\">CONFIG_MAP_KEY</span>  <span class=\"comment\">#局策略可使用configMap的配置Key，</span></span><br><span class=\"line\"><span class=\"attr\">              valueFrom:</span></span><br><span class=\"line\"><span class=\"attr\">                configMapKeyRef:</span></span><br><span class=\"line\"><span class=\"attr\">                  name:</span> <span class=\"string\">special-config</span>   <span class=\"comment\">#configmap中找到name为special-config</span></span><br><span class=\"line\"><span class=\"attr\">                  key:</span> <span class=\"string\">special.type</span>      <span class=\"comment\">#找到name为special-config里data下的key</span></span><br><span class=\"line\"><span class=\"attr\">          ports:</span></span><br><span class=\"line\"><span class=\"attr\">            - name:</span> <span class=\"string\">http</span></span><br><span class=\"line\"><span class=\"attr\">              containerPort:</span> <span class=\"number\">8080</span> <span class=\"comment\">#对service暴露端口</span></span><br><span class=\"line\"><span class=\"attr\">          volumeMounts:</span>     <span class=\"comment\">#挂载volumes中定义的磁盘</span></span><br><span class=\"line\"><span class=\"attr\">          - name:</span> <span class=\"string\">log-cache</span></span><br><span class=\"line\"><span class=\"attr\">            mount:</span> <span class=\"string\">/tmp/log</span></span><br><span class=\"line\"><span class=\"attr\">          - name:</span> <span class=\"string\">sdb</span>       <span class=\"comment\">#普通用法，该卷跟随容器销毁，挂载一个目录</span></span><br><span class=\"line\"><span class=\"attr\">            mountPath:</span> <span class=\"string\">/data/media</span>    </span><br><span class=\"line\"><span class=\"attr\">          - name:</span> <span class=\"string\">nfs-client-root</span>    <span class=\"comment\">#直接挂载硬盘方法，如挂载下面的nfs目录到/mnt/nfs</span></span><br><span class=\"line\"><span class=\"attr\">            mountPath:</span> <span class=\"string\">/mnt/nfs</span></span><br><span class=\"line\"><span class=\"attr\">          - name:</span> <span class=\"string\">example-volume-config</span>  <span class=\"comment\">#高级用法第1种，将ConfigMap的log-script,backup-script分别挂载到/etc/config目录下的一个相对路径path/to/...下，如果存在同名文件，直接覆盖。</span></span><br><span class=\"line\"><span class=\"attr\">            mountPath:</span> <span class=\"string\">/etc/config</span>       </span><br><span class=\"line\"><span class=\"attr\">          - name:</span> <span class=\"string\">rbd-pvc</span>                <span class=\"comment\">#高级用法第2中，挂载PVC(PresistentVolumeClaim)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#使用volume将ConfigMap作为文件或目录直接挂载，其中每一个key-value键值对都会生成一个文件，key为文件名，value为内容，</span></span><br><span class=\"line\"><span class=\"attr\">  volumes:</span>  <span class=\"comment\"># 定义磁盘给上面volumeMounts挂载</span></span><br><span class=\"line\"><span class=\"attr\">  - name:</span> <span class=\"string\">log-cache</span></span><br><span class=\"line\"><span class=\"attr\">    emptyDir:</span> <span class=\"string\">&#123;&#125;</span></span><br><span class=\"line\"><span class=\"attr\">  - name:</span> <span class=\"string\">sdb</span>  <span class=\"comment\">#挂载宿主机上面的目录</span></span><br><span class=\"line\"><span class=\"attr\">    hostPath:</span></span><br><span class=\"line\"><span class=\"attr\">      path:</span> <span class=\"string\">/any/path/it/will/be/replaced</span></span><br><span class=\"line\"><span class=\"attr\">  - name:</span> <span class=\"string\">example-volume-config</span>  <span class=\"comment\"># 供ConfigMap文件内容到指定路径使用</span></span><br><span class=\"line\"><span class=\"attr\">    configMap:</span></span><br><span class=\"line\"><span class=\"attr\">      name:</span> <span class=\"string\">example-volume-config</span>  <span class=\"comment\">#ConfigMap中名称</span></span><br><span class=\"line\"><span class=\"attr\">      items:</span></span><br><span class=\"line\"><span class=\"attr\">      - key:</span> <span class=\"string\">log-script</span>           <span class=\"comment\">#ConfigMap中的Key</span></span><br><span class=\"line\"><span class=\"attr\">        path:</span> <span class=\"string\">path/to/log-script</span>  <span class=\"comment\">#指定目录下的一个相对路径path/to/log-script</span></span><br><span class=\"line\"><span class=\"attr\">      - key:</span> <span class=\"string\">backup-script</span>        <span class=\"comment\">#ConfigMap中的Key</span></span><br><span class=\"line\"><span class=\"attr\">        path:</span> <span class=\"string\">path/to/backup-script</span>  <span class=\"comment\">#指定目录下的一个相对路径path/to/backup-script</span></span><br><span class=\"line\"><span class=\"attr\">  - name:</span> <span class=\"string\">nfs-client-root</span>         <span class=\"comment\">#供挂载NFS存储类型</span></span><br><span class=\"line\"><span class=\"attr\">    nfs:</span></span><br><span class=\"line\"><span class=\"attr\">      server:</span> <span class=\"number\">10.42</span><span class=\"number\">.0</span><span class=\"number\">.55</span>          <span class=\"comment\">#NFS服务器地址</span></span><br><span class=\"line\"><span class=\"attr\">      path:</span> <span class=\"string\">/opt/public</span>           <span class=\"comment\">#showmount -e 看一下路径</span></span><br><span class=\"line\"><span class=\"attr\">  - name:</span> <span class=\"string\">rbd-pvc</span>                 <span class=\"comment\">#挂载PVC磁盘</span></span><br><span class=\"line\"><span class=\"attr\">    persistentVolumeClaim:</span></span><br><span class=\"line\"><span class=\"attr\">      claimName:</span> <span class=\"string\">rbd-pvc1</span>         <span class=\"comment\">#挂载已经申请的pvc磁盘</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">extensions/v1beta1</span>   <span class=\"comment\">#接口版本</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span>                 <span class=\"comment\">#接口类型</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> <span class=\"string\">cango-demo</span>               <span class=\"comment\">#Deployment名称</span></span><br><span class=\"line\"><span class=\"attr\">  namespace:</span> <span class=\"string\">cango-prd</span>           <span class=\"comment\">#命名空间</span></span><br><span class=\"line\"><span class=\"attr\">  labels:</span></span><br><span class=\"line\"><span class=\"attr\">    app:</span> <span class=\"string\">cango-demo</span>              <span class=\"comment\">#标签</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\"><span class=\"attr\">  replicas:</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"attr\">   strategy:</span></span><br><span class=\"line\"><span class=\"attr\">    rollingUpdate:</span>  <span class=\"comment\">##由于replicas为3,则整个升级,pod个数在2-4个之间</span></span><br><span class=\"line\"><span class=\"attr\">      maxSurge:</span> <span class=\"number\">1</span>      <span class=\"comment\">#滚动升级时会先启动1个pod</span></span><br><span class=\"line\"><span class=\"attr\">      maxUnavailable:</span> <span class=\"number\">1</span> <span class=\"comment\">#滚动升级时允许的最大Unavailable的pod个数</span></span><br><span class=\"line\"><span class=\"attr\">  template:</span>         </span><br><span class=\"line\"><span class=\"attr\">    metadata:</span></span><br><span class=\"line\"><span class=\"attr\">      labels:</span></span><br><span class=\"line\"><span class=\"attr\">        app:</span> <span class=\"string\">cango-demo</span>  <span class=\"comment\">#模板名称必填</span></span><br><span class=\"line\"><span class=\"attr\">    sepc:</span> <span class=\"comment\">#定义容器模板，该模板可以包含多个容器</span></span><br><span class=\"line\"><span class=\"attr\">      containers:</span>                                                                   </span><br><span class=\"line\"><span class=\"attr\">        - name:</span> <span class=\"string\">cango-demo</span>                                                           <span class=\"comment\">#镜像名称</span></span><br><span class=\"line\"><span class=\"attr\">          image:</span> <span class=\"string\">swr.cn-east-2.myhuaweicloud.com/cango-prd/cango-demo:0.0.1-SNAPSHOT</span> <span class=\"comment\">#镜像地址</span></span><br><span class=\"line\"><span class=\"attr\">          command:</span> <span class=\"string\">[</span> <span class=\"string\">\"/bin/sh\"</span><span class=\"string\">,\"-c\",\"cat</span> <span class=\"string\">/etc/config/path/to/special-key\"</span> <span class=\"string\">]</span>    <span class=\"comment\">#启动命令</span></span><br><span class=\"line\"><span class=\"attr\">          args:</span>                                                                <span class=\"comment\">#启动参数</span></span><br><span class=\"line\"><span class=\"bullet\">            -</span> <span class=\"string\">'-storage.local.retention=$(STORAGE_RETENTION)'</span></span><br><span class=\"line\"><span class=\"bullet\">            -</span> <span class=\"string\">'-storage.local.memory-chunks=$(STORAGE_MEMORY_CHUNKS)'</span></span><br><span class=\"line\"><span class=\"bullet\">            -</span> <span class=\"string\">'-config.file=/etc/prometheus/prometheus.yml'</span></span><br><span class=\"line\"><span class=\"bullet\">            -</span> <span class=\"string\">'-alertmanager.url=http://alertmanager:9093/alertmanager'</span></span><br><span class=\"line\"><span class=\"bullet\">            -</span> <span class=\"string\">'-web.external-url=$(EXTERNAL_URL)'</span></span><br><span class=\"line\">    <span class=\"comment\">#如果command和args均没有写，那么用Docker默认的配置。</span></span><br><span class=\"line\">    <span class=\"comment\">#如果command写了，但args没有写，那么Docker默认的配置会被忽略而且仅仅执行.yaml文件的command（不带任何参数的）。</span></span><br><span class=\"line\">    <span class=\"comment\">#如果command没写，但args写了，那么Docker默认配置的ENTRYPOINT的命令行会被执行，但是调用的参数是.yaml中的args。</span></span><br><span class=\"line\">    <span class=\"comment\">#如果如果command和args都写了，那么Docker默认的配置被忽略，使用.yaml的配置。</span></span><br><span class=\"line\"><span class=\"attr\">          imagePullPolicy:</span> <span class=\"string\">IfNotPresent</span>  <span class=\"comment\">#如果不存在则拉取</span></span><br><span class=\"line\"><span class=\"attr\">          livenessProbe:</span>       <span class=\"comment\">#表示container是否处于live状态。如果LivenessProbe失败，LivenessProbe将会通知kubelet对应的container不健康了。随后kubelet将kill掉container，并根据RestarPolicy进行进一步的操作。默认情况下LivenessProbe在第一次检测之前初始化值为Success，如果container没有提供LivenessProbe，则也认为是Success；</span></span><br><span class=\"line\"><span class=\"attr\">            httpGet:</span></span><br><span class=\"line\"><span class=\"attr\">              path:</span> <span class=\"string\">/health</span> <span class=\"comment\">#如果没有心跳检测接口就为/</span></span><br><span class=\"line\"><span class=\"attr\">              port:</span> <span class=\"number\">8080</span></span><br><span class=\"line\"><span class=\"attr\">              scheme:</span> <span class=\"string\">HTTP</span></span><br><span class=\"line\"><span class=\"attr\">            initialDelaySeconds:</span> <span class=\"number\">60</span> <span class=\"comment\">##启动后延时多久开始运行检测</span></span><br><span class=\"line\"><span class=\"attr\">            timeoutSeconds:</span> <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"attr\">            successThreshold:</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attr\">            failureThreshold:</span> <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"attr\">            readinessProbe:</span></span><br><span class=\"line\"><span class=\"attr\">          readinessProbe:</span></span><br><span class=\"line\"><span class=\"attr\">            httpGet:</span></span><br><span class=\"line\"><span class=\"attr\">              path:</span> <span class=\"string\">/health</span> <span class=\"comment\">#如果没有心跳检测接口就为/</span></span><br><span class=\"line\"><span class=\"attr\">              port:</span> <span class=\"number\">8080</span></span><br><span class=\"line\"><span class=\"attr\">              scheme:</span> <span class=\"string\">HTTP</span></span><br><span class=\"line\"><span class=\"attr\">            initialDelaySeconds:</span> <span class=\"number\">30</span> <span class=\"comment\">##启动后延时多久开始运行检测</span></span><br><span class=\"line\"><span class=\"attr\">            timeoutSeconds:</span> <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"attr\">            successThreshold:</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attr\">            failureThreshold:</span> <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"attr\">          resources:</span>              <span class=\"comment\">##CPU内存限制</span></span><br><span class=\"line\"><span class=\"attr\">            requests:</span></span><br><span class=\"line\"><span class=\"attr\">              cpu:</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"attr\">              memory:</span> <span class=\"number\">2048</span><span class=\"string\">Mi</span></span><br><span class=\"line\"><span class=\"attr\">            limits:</span></span><br><span class=\"line\"><span class=\"attr\">              cpu:</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"attr\">              memory:</span> <span class=\"number\">2048</span><span class=\"string\">Mi</span></span><br><span class=\"line\"><span class=\"attr\">          env:</span>                    <span class=\"comment\">##通过环境变量的方式，直接传递pod=自定义Linux OS环境变量</span></span><br><span class=\"line\"><span class=\"attr\">            - name:</span> <span class=\"string\">LOCAL_KEY</span>     <span class=\"comment\">#本地Key</span></span><br><span class=\"line\"><span class=\"attr\">              value:</span> <span class=\"string\">value</span></span><br><span class=\"line\"><span class=\"attr\">            - name:</span> <span class=\"string\">CONFIG_MAP_KEY</span>  <span class=\"comment\">#局策略可使用configMap的配置Key，</span></span><br><span class=\"line\"><span class=\"attr\">              valueFrom:</span></span><br><span class=\"line\"><span class=\"attr\">                configMapKeyRef:</span></span><br><span class=\"line\"><span class=\"attr\">                  name:</span> <span class=\"string\">special-config</span>   <span class=\"comment\">#configmap中找到name为special-config</span></span><br><span class=\"line\"><span class=\"attr\">                  key:</span> <span class=\"string\">special.type</span>      <span class=\"comment\">#找到name为special-config里data下的key</span></span><br><span class=\"line\"><span class=\"attr\">          ports:</span></span><br><span class=\"line\"><span class=\"attr\">            - name:</span> <span class=\"string\">http</span></span><br><span class=\"line\"><span class=\"attr\">              containerPort:</span> <span class=\"number\">8080</span> <span class=\"comment\">#对service暴露端口</span></span><br><span class=\"line\"><span class=\"attr\">          volumeMounts:</span>     <span class=\"comment\">#挂载volumes中定义的磁盘</span></span><br><span class=\"line\"><span class=\"attr\">          - name:</span> <span class=\"string\">log-cache</span></span><br><span class=\"line\"><span class=\"attr\">            mount:</span> <span class=\"string\">/tmp/log</span></span><br><span class=\"line\"><span class=\"attr\">          - name:</span> <span class=\"string\">sdb</span>       <span class=\"comment\">#普通用法，该卷跟随容器销毁，挂载一个目录</span></span><br><span class=\"line\"><span class=\"attr\">            mountPath:</span> <span class=\"string\">/data/media</span>    </span><br><span class=\"line\"><span class=\"attr\">          - name:</span> <span class=\"string\">nfs-client-root</span>    <span class=\"comment\">#直接挂载硬盘方法，如挂载下面的nfs目录到/mnt/nfs</span></span><br><span class=\"line\"><span class=\"attr\">            mountPath:</span> <span class=\"string\">/mnt/nfs</span></span><br><span class=\"line\"><span class=\"attr\">          - name:</span> <span class=\"string\">example-volume-config</span>  <span class=\"comment\">#高级用法第1种，将ConfigMap的log-script,backup-script分别挂载到/etc/config目录下的一个相对路径path/to/...下，如果存在同名文件，直接覆盖。</span></span><br><span class=\"line\"><span class=\"attr\">            mountPath:</span> <span class=\"string\">/etc/config</span>       </span><br><span class=\"line\"><span class=\"attr\">          - name:</span> <span class=\"string\">rbd-pvc</span>                <span class=\"comment\">#高级用法第2中，挂载PVC(PresistentVolumeClaim)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#使用volume将ConfigMap作为文件或目录直接挂载，其中每一个key-value键值对都会生成一个文件，key为文件名，value为内容，</span></span><br><span class=\"line\"><span class=\"attr\">  volumes:</span>  <span class=\"comment\"># 定义磁盘给上面volumeMounts挂载</span></span><br><span class=\"line\"><span class=\"attr\">  - name:</span> <span class=\"string\">log-cache</span></span><br><span class=\"line\"><span class=\"attr\">    emptyDir:</span> <span class=\"string\">&#123;&#125;</span></span><br><span class=\"line\"><span class=\"attr\">  - name:</span> <span class=\"string\">sdb</span>  <span class=\"comment\">#挂载宿主机上面的目录</span></span><br><span class=\"line\"><span class=\"attr\">    hostPath:</span></span><br><span class=\"line\"><span class=\"attr\">      path:</span> <span class=\"string\">/any/path/it/will/be/replaced</span></span><br><span class=\"line\"><span class=\"attr\">  - name:</span> <span class=\"string\">example-volume-config</span>  <span class=\"comment\"># 供ConfigMap文件内容到指定路径使用</span></span><br><span class=\"line\"><span class=\"attr\">    configMap:</span></span><br><span class=\"line\"><span class=\"attr\">      name:</span> <span class=\"string\">example-volume-config</span>  <span class=\"comment\">#ConfigMap中名称</span></span><br><span class=\"line\"><span class=\"attr\">      items:</span></span><br><span class=\"line\"><span class=\"attr\">      - key:</span> <span class=\"string\">log-script</span>           <span class=\"comment\">#ConfigMap中的Key</span></span><br><span class=\"line\"><span class=\"attr\">        path:</span> <span class=\"string\">path/to/log-script</span>  <span class=\"comment\">#指定目录下的一个相对路径path/to/log-script</span></span><br><span class=\"line\"><span class=\"attr\">      - key:</span> <span class=\"string\">backup-script</span>        <span class=\"comment\">#ConfigMap中的Key</span></span><br><span class=\"line\"><span class=\"attr\">        path:</span> <span class=\"string\">path/to/backup-script</span>  <span class=\"comment\">#指定目录下的一个相对路径path/to/backup-script</span></span><br><span class=\"line\"><span class=\"attr\">  - name:</span> <span class=\"string\">nfs-client-root</span>         <span class=\"comment\">#供挂载NFS存储类型</span></span><br><span class=\"line\"><span class=\"attr\">    nfs:</span></span><br><span class=\"line\"><span class=\"attr\">      server:</span> <span class=\"number\">10.42</span><span class=\"number\">.0</span><span class=\"number\">.55</span>          <span class=\"comment\">#NFS服务器地址</span></span><br><span class=\"line\"><span class=\"attr\">      path:</span> <span class=\"string\">/opt/public</span>           <span class=\"comment\">#showmount -e 看一下路径</span></span><br><span class=\"line\"><span class=\"attr\">  - name:</span> <span class=\"string\">rbd-pvc</span>                 <span class=\"comment\">#挂载PVC磁盘</span></span><br><span class=\"line\"><span class=\"attr\">    persistentVolumeClaim:</span></span><br><span class=\"line\"><span class=\"attr\">      claimName:</span> <span class=\"string\">rbd-pvc1</span>         <span class=\"comment\">#挂载已经申请的pvc磁盘</span></span><br></pre></td></tr></table></figure>"},{"title":"k8s kubeconfig","_content":"想要向k8s集群发送指令都是通过kubectl程序进行，kubectl是Go语言编写的应用程序，其功能只是调用k8s集群的API与k8s集群进行通信。kubectl相当于k8s集群的客户端，所以它需要知道服务端的地址、连接证书等信息，kubectl就是通过读取kubeconfig文件获知这些配置。kubectl默认会从$HOME/.kube目录下查找文件名为config的文件，也可以通过设置环境变量$KUBECONFIG或者通过设置--kubeconfig去指定其它kubeconfig文件。\n\n<!--more-->\n\n下面给出配置文件的例子: \n```yaml\ncurrent-context: federal-context\napiVersion: v1\nclusters:\n- cluster:\n    api-version: v1\n    server: http://cow.org:8080\n  name: cow-cluster\n- cluster:\n    certificate-authority: path/to/my/cafile\n    server: https://horse.org:4443\n  name: horse-cluster\n- cluster:\n    insecure-skip-tls-verify: true\n    server: https://pig.org:443\n  name: pig-cluster\ncontexts:\n- context:\n    cluster: horse-cluster\n    namespace: chisel-ns\n    user: green-user\n  name: federal-context\n- context:\n    cluster: pig-cluster\n    namespace: saw-ns\n    user: black-user\n  name: queen-anne-context\nkind: Config\npreferences:\n  colors: true\nusers:\n- name: blue-user\n  user:\n    token: blue-token\n- name: green-user\n  user:\n    client-certificate: path/to/my/client/cert\n    client-key: path/to/my/client/key\n```\n\n## cluster\n```yaml\nclusters:\n- cluster:\n    certificate-authority: path/to/my/cafile\n    server: https://horse.org:4443\n  name: horse-cluster\n- cluster:\n    insecure-skip-tls-verify: true\n    server: https://pig.org:443\n  name: pig-cluster\n```\n配置中 __clusters__ 节点是一个列表，列表中的元素是Map结构，存储了每个集群的信息。__clusters.cluster.server__ 用于配置k8s集群apiserver完整路径，一般采用TLS协议与apiserver进行通信就需要证书验证，__clusters.cluster.certificate-authority__ 用于指定TLS协议的证书路径，若apiserver配置了不需要证书校验这个环境，则通过配置 __clusters.cluster.insecure-skip-tls-verify: true__ 来跳过TLS协议的证书验证。因为可以配置多个集群的信息，我们就需要通过名称来指定访问哪个集群，所以还需要通过 __clusters.name__ 为每个集群命名。\n\n除了读取配置文件之外，还可以通过 __kubectl config set-cluster__ 指令动态配置集群信息，指令定义如下（详情参考[官方文档](http://kubernetes.kansea.com/docs/user-guide/kubectl/kubectl_config_set-cluster/)）：\n```sh\nkubectl config set-cluster NAME [--server=server] [--certificate-authority=path/to/certficate/authority] [--insecure-skip-tls-verify=true]\n```\n\n## user\n```yaml\nusers:\n- name: blue-user\n  user:\n    token: blue-token\n- name: green-user\n  user:\n    client-certificate: path/to/my/client/cert\n    client-key: path/to/my/client/key\n```\n配置中 __users__ 节点是一个列表，列表中的元素是Map结构，存储了每个用户的认证信息。访问k8s集群时都会带上当前用户信息让服务端进行ACL鉴权，每个用户都需要通过 __name__ 节点配置名称。此外，根据服务端的认证方式的不同，通过 __client-certificate__、__client-key__、__token__ 或 __username/password__ 配置用户认证信息。\n\n除了修改配置文件之外，还可以通过 __kubectl config set-credentials__ 指令动态配置用户认证信息，指令定义如下（详情参考[官方文档](http://kubernetes.kansea.com/docs/user-guide/kubectl/kubectl_config_set-credentials)）：\n```sh\nkubectl config set-credentials NAME [--client-certificate=path/to/certfile] [--client-key=path/to/keyfile] [--token=bearer_token] [--username=basic_user] [--password=basic_password]\n```\n\n## context\n```yaml\ncontexts:\n- context:\n    cluster: horse-cluster\n    namespace: chisel-ns\n    user: green-user\n  name: federal-context\n```\n\n正在编写\n\n## current-context\n```yaml\ncurrent-context: federal-context\n```\n\n正在编写\n","source":"_drafts/k8s-kubeconfig.md","raw":"---\ntitle: \"k8s kubeconfig\"\ncategory: k8s\n---\n想要向k8s集群发送指令都是通过kubectl程序进行，kubectl是Go语言编写的应用程序，其功能只是调用k8s集群的API与k8s集群进行通信。kubectl相当于k8s集群的客户端，所以它需要知道服务端的地址、连接证书等信息，kubectl就是通过读取kubeconfig文件获知这些配置。kubectl默认会从$HOME/.kube目录下查找文件名为config的文件，也可以通过设置环境变量$KUBECONFIG或者通过设置--kubeconfig去指定其它kubeconfig文件。\n\n<!--more-->\n\n下面给出配置文件的例子: \n```yaml\ncurrent-context: federal-context\napiVersion: v1\nclusters:\n- cluster:\n    api-version: v1\n    server: http://cow.org:8080\n  name: cow-cluster\n- cluster:\n    certificate-authority: path/to/my/cafile\n    server: https://horse.org:4443\n  name: horse-cluster\n- cluster:\n    insecure-skip-tls-verify: true\n    server: https://pig.org:443\n  name: pig-cluster\ncontexts:\n- context:\n    cluster: horse-cluster\n    namespace: chisel-ns\n    user: green-user\n  name: federal-context\n- context:\n    cluster: pig-cluster\n    namespace: saw-ns\n    user: black-user\n  name: queen-anne-context\nkind: Config\npreferences:\n  colors: true\nusers:\n- name: blue-user\n  user:\n    token: blue-token\n- name: green-user\n  user:\n    client-certificate: path/to/my/client/cert\n    client-key: path/to/my/client/key\n```\n\n## cluster\n```yaml\nclusters:\n- cluster:\n    certificate-authority: path/to/my/cafile\n    server: https://horse.org:4443\n  name: horse-cluster\n- cluster:\n    insecure-skip-tls-verify: true\n    server: https://pig.org:443\n  name: pig-cluster\n```\n配置中 __clusters__ 节点是一个列表，列表中的元素是Map结构，存储了每个集群的信息。__clusters.cluster.server__ 用于配置k8s集群apiserver完整路径，一般采用TLS协议与apiserver进行通信就需要证书验证，__clusters.cluster.certificate-authority__ 用于指定TLS协议的证书路径，若apiserver配置了不需要证书校验这个环境，则通过配置 __clusters.cluster.insecure-skip-tls-verify: true__ 来跳过TLS协议的证书验证。因为可以配置多个集群的信息，我们就需要通过名称来指定访问哪个集群，所以还需要通过 __clusters.name__ 为每个集群命名。\n\n除了读取配置文件之外，还可以通过 __kubectl config set-cluster__ 指令动态配置集群信息，指令定义如下（详情参考[官方文档](http://kubernetes.kansea.com/docs/user-guide/kubectl/kubectl_config_set-cluster/)）：\n```sh\nkubectl config set-cluster NAME [--server=server] [--certificate-authority=path/to/certficate/authority] [--insecure-skip-tls-verify=true]\n```\n\n## user\n```yaml\nusers:\n- name: blue-user\n  user:\n    token: blue-token\n- name: green-user\n  user:\n    client-certificate: path/to/my/client/cert\n    client-key: path/to/my/client/key\n```\n配置中 __users__ 节点是一个列表，列表中的元素是Map结构，存储了每个用户的认证信息。访问k8s集群时都会带上当前用户信息让服务端进行ACL鉴权，每个用户都需要通过 __name__ 节点配置名称。此外，根据服务端的认证方式的不同，通过 __client-certificate__、__client-key__、__token__ 或 __username/password__ 配置用户认证信息。\n\n除了修改配置文件之外，还可以通过 __kubectl config set-credentials__ 指令动态配置用户认证信息，指令定义如下（详情参考[官方文档](http://kubernetes.kansea.com/docs/user-guide/kubectl/kubectl_config_set-credentials)）：\n```sh\nkubectl config set-credentials NAME [--client-certificate=path/to/certfile] [--client-key=path/to/keyfile] [--token=bearer_token] [--username=basic_user] [--password=basic_password]\n```\n\n## context\n```yaml\ncontexts:\n- context:\n    cluster: horse-cluster\n    namespace: chisel-ns\n    user: green-user\n  name: federal-context\n```\n\n正在编写\n\n## current-context\n```yaml\ncurrent-context: federal-context\n```\n\n正在编写\n","slug":"k8s-kubeconfig","published":0,"date":"2020-01-16T17:23:25.488Z","updated":"2019-08-28T05:43:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck679mtry000clbmdmf2cp1fd","content":"<p>想要向k8s集群发送指令都是通过kubectl程序进行，kubectl是Go语言编写的应用程序，其功能只是调用k8s集群的API与k8s集群进行通信。kubectl相当于k8s集群的客户端，所以它需要知道服务端的地址、连接证书等信息，kubectl就是通过读取kubeconfig文件获知这些配置。kubectl默认会从$HOME/.kube目录下查找文件名为config的文件，也可以通过设置环境变量$KUBECONFIG或者通过设置–kubeconfig去指定其它kubeconfig文件。</p>\n<a id=\"more\"></a>\n\n<p>下面给出配置文件的例子: </p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">current-context:</span> <span class=\"string\">federal-context</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">clusters:</span></span><br><span class=\"line\"><span class=\"attr\">- cluster:</span></span><br><span class=\"line\"><span class=\"attr\">    api-version:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">    server:</span> <span class=\"attr\">http://cow.org:8080</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> <span class=\"string\">cow-cluster</span></span><br><span class=\"line\"><span class=\"attr\">- cluster:</span></span><br><span class=\"line\"><span class=\"attr\">    certificate-authority:</span> <span class=\"string\">path/to/my/cafile</span></span><br><span class=\"line\"><span class=\"attr\">    server:</span> <span class=\"attr\">https://horse.org:4443</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> <span class=\"string\">horse-cluster</span></span><br><span class=\"line\"><span class=\"attr\">- cluster:</span></span><br><span class=\"line\"><span class=\"attr\">    insecure-skip-tls-verify:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    server:</span> <span class=\"attr\">https://pig.org:443</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> <span class=\"string\">pig-cluster</span></span><br><span class=\"line\"><span class=\"attr\">contexts:</span></span><br><span class=\"line\"><span class=\"attr\">- context:</span></span><br><span class=\"line\"><span class=\"attr\">    cluster:</span> <span class=\"string\">horse-cluster</span></span><br><span class=\"line\"><span class=\"attr\">    namespace:</span> <span class=\"string\">chisel-ns</span></span><br><span class=\"line\"><span class=\"attr\">    user:</span> <span class=\"string\">green-user</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> <span class=\"string\">federal-context</span></span><br><span class=\"line\"><span class=\"attr\">- context:</span></span><br><span class=\"line\"><span class=\"attr\">    cluster:</span> <span class=\"string\">pig-cluster</span></span><br><span class=\"line\"><span class=\"attr\">    namespace:</span> <span class=\"string\">saw-ns</span></span><br><span class=\"line\"><span class=\"attr\">    user:</span> <span class=\"string\">black-user</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> <span class=\"string\">queen-anne-context</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Config</span></span><br><span class=\"line\"><span class=\"attr\">preferences:</span></span><br><span class=\"line\"><span class=\"attr\">  colors:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">users:</span></span><br><span class=\"line\"><span class=\"attr\">- name:</span> <span class=\"string\">blue-user</span></span><br><span class=\"line\"><span class=\"attr\">  user:</span></span><br><span class=\"line\"><span class=\"attr\">    token:</span> <span class=\"string\">blue-token</span></span><br><span class=\"line\"><span class=\"attr\">- name:</span> <span class=\"string\">green-user</span></span><br><span class=\"line\"><span class=\"attr\">  user:</span></span><br><span class=\"line\"><span class=\"attr\">    client-certificate:</span> <span class=\"string\">path/to/my/client/cert</span></span><br><span class=\"line\"><span class=\"attr\">    client-key:</span> <span class=\"string\">path/to/my/client/key</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"cluster\"><a href=\"#cluster\" class=\"headerlink\" title=\"cluster\"></a>cluster</h2><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">clusters:</span></span><br><span class=\"line\"><span class=\"attr\">- cluster:</span></span><br><span class=\"line\"><span class=\"attr\">    certificate-authority:</span> <span class=\"string\">path/to/my/cafile</span></span><br><span class=\"line\"><span class=\"attr\">    server:</span> <span class=\"attr\">https://horse.org:4443</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> <span class=\"string\">horse-cluster</span></span><br><span class=\"line\"><span class=\"attr\">- cluster:</span></span><br><span class=\"line\"><span class=\"attr\">    insecure-skip-tls-verify:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    server:</span> <span class=\"attr\">https://pig.org:443</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> <span class=\"string\">pig-cluster</span></span><br></pre></td></tr></table></figure>\n\n<p>配置中 <strong>clusters</strong> 节点是一个列表，列表中的元素是Map结构，存储了每个集群的信息。<strong>clusters.cluster.server</strong> 用于配置k8s集群apiserver完整路径，一般采用TLS协议与apiserver进行通信就需要证书验证，<strong>clusters.cluster.certificate-authority</strong> 用于指定TLS协议的证书路径，若apiserver配置了不需要证书校验这个环境，则通过配置 <strong>clusters.cluster.insecure-skip-tls-verify: true</strong> 来跳过TLS协议的证书验证。因为可以配置多个集群的信息，我们就需要通过名称来指定访问哪个集群，所以还需要通过 <strong>clusters.name</strong> 为每个集群命名。</p>\n<p>除了读取配置文件之外，还可以通过 <strong>kubectl config set-cluster</strong> 指令动态配置集群信息，指令定义如下（详情参考<a href=\"http://kubernetes.kansea.com/docs/user-guide/kubectl/kubectl_config_set-cluster/\" target=\"_blank\" rel=\"noopener\">官方文档</a>）：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl config <span class=\"built_in\">set</span>-cluster NAME [--server=server] [--certificate-authority=path/to/certficate/authority] [--insecure-skip-tls-verify=<span class=\"literal\">true</span>]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"user\"><a href=\"#user\" class=\"headerlink\" title=\"user\"></a>user</h2><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">users:</span></span><br><span class=\"line\"><span class=\"attr\">- name:</span> <span class=\"string\">blue-user</span></span><br><span class=\"line\"><span class=\"attr\">  user:</span></span><br><span class=\"line\"><span class=\"attr\">    token:</span> <span class=\"string\">blue-token</span></span><br><span class=\"line\"><span class=\"attr\">- name:</span> <span class=\"string\">green-user</span></span><br><span class=\"line\"><span class=\"attr\">  user:</span></span><br><span class=\"line\"><span class=\"attr\">    client-certificate:</span> <span class=\"string\">path/to/my/client/cert</span></span><br><span class=\"line\"><span class=\"attr\">    client-key:</span> <span class=\"string\">path/to/my/client/key</span></span><br></pre></td></tr></table></figure>\n\n<p>配置中 <strong>users</strong> 节点是一个列表，列表中的元素是Map结构，存储了每个用户的认证信息。访问k8s集群时都会带上当前用户信息让服务端进行ACL鉴权，每个用户都需要通过 <strong>name</strong> 节点配置名称。此外，根据服务端的认证方式的不同，通过 <strong>client-certificate</strong>、<strong>client-key</strong>、<strong>token</strong> 或 <strong>username/password</strong> 配置用户认证信息。</p>\n<p>除了修改配置文件之外，还可以通过 <strong>kubectl config set-credentials</strong> 指令动态配置用户认证信息，指令定义如下（详情参考<a href=\"http://kubernetes.kansea.com/docs/user-guide/kubectl/kubectl_config_set-credentials\" target=\"_blank\" rel=\"noopener\">官方文档</a>）：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl config <span class=\"built_in\">set</span>-credentials NAME [--client-certificate=path/to/certfile] [--client-key=path/to/keyfile] [--token=bearer_token] [--username=basic_user] [--password=basic_password]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"context\"><a href=\"#context\" class=\"headerlink\" title=\"context\"></a>context</h2><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">contexts:</span></span><br><span class=\"line\"><span class=\"attr\">- context:</span></span><br><span class=\"line\"><span class=\"attr\">    cluster:</span> <span class=\"string\">horse-cluster</span></span><br><span class=\"line\"><span class=\"attr\">    namespace:</span> <span class=\"string\">chisel-ns</span></span><br><span class=\"line\"><span class=\"attr\">    user:</span> <span class=\"string\">green-user</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> <span class=\"string\">federal-context</span></span><br></pre></td></tr></table></figure>\n\n<p>正在编写</p>\n<h2 id=\"current-context\"><a href=\"#current-context\" class=\"headerlink\" title=\"current-context\"></a>current-context</h2><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">current-context:</span> <span class=\"string\">federal-context</span></span><br></pre></td></tr></table></figure>\n\n<p>正在编写</p>\n","site":{"data":{}},"excerpt":"<p>想要向k8s集群发送指令都是通过kubectl程序进行，kubectl是Go语言编写的应用程序，其功能只是调用k8s集群的API与k8s集群进行通信。kubectl相当于k8s集群的客户端，所以它需要知道服务端的地址、连接证书等信息，kubectl就是通过读取kubeconfig文件获知这些配置。kubectl默认会从$HOME/.kube目录下查找文件名为config的文件，也可以通过设置环境变量$KUBECONFIG或者通过设置–kubeconfig去指定其它kubeconfig文件。</p>","more":"<p>下面给出配置文件的例子: </p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">current-context:</span> <span class=\"string\">federal-context</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">clusters:</span></span><br><span class=\"line\"><span class=\"attr\">- cluster:</span></span><br><span class=\"line\"><span class=\"attr\">    api-version:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">    server:</span> <span class=\"attr\">http://cow.org:8080</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> <span class=\"string\">cow-cluster</span></span><br><span class=\"line\"><span class=\"attr\">- cluster:</span></span><br><span class=\"line\"><span class=\"attr\">    certificate-authority:</span> <span class=\"string\">path/to/my/cafile</span></span><br><span class=\"line\"><span class=\"attr\">    server:</span> <span class=\"attr\">https://horse.org:4443</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> <span class=\"string\">horse-cluster</span></span><br><span class=\"line\"><span class=\"attr\">- cluster:</span></span><br><span class=\"line\"><span class=\"attr\">    insecure-skip-tls-verify:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    server:</span> <span class=\"attr\">https://pig.org:443</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> <span class=\"string\">pig-cluster</span></span><br><span class=\"line\"><span class=\"attr\">contexts:</span></span><br><span class=\"line\"><span class=\"attr\">- context:</span></span><br><span class=\"line\"><span class=\"attr\">    cluster:</span> <span class=\"string\">horse-cluster</span></span><br><span class=\"line\"><span class=\"attr\">    namespace:</span> <span class=\"string\">chisel-ns</span></span><br><span class=\"line\"><span class=\"attr\">    user:</span> <span class=\"string\">green-user</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> <span class=\"string\">federal-context</span></span><br><span class=\"line\"><span class=\"attr\">- context:</span></span><br><span class=\"line\"><span class=\"attr\">    cluster:</span> <span class=\"string\">pig-cluster</span></span><br><span class=\"line\"><span class=\"attr\">    namespace:</span> <span class=\"string\">saw-ns</span></span><br><span class=\"line\"><span class=\"attr\">    user:</span> <span class=\"string\">black-user</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> <span class=\"string\">queen-anne-context</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Config</span></span><br><span class=\"line\"><span class=\"attr\">preferences:</span></span><br><span class=\"line\"><span class=\"attr\">  colors:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">users:</span></span><br><span class=\"line\"><span class=\"attr\">- name:</span> <span class=\"string\">blue-user</span></span><br><span class=\"line\"><span class=\"attr\">  user:</span></span><br><span class=\"line\"><span class=\"attr\">    token:</span> <span class=\"string\">blue-token</span></span><br><span class=\"line\"><span class=\"attr\">- name:</span> <span class=\"string\">green-user</span></span><br><span class=\"line\"><span class=\"attr\">  user:</span></span><br><span class=\"line\"><span class=\"attr\">    client-certificate:</span> <span class=\"string\">path/to/my/client/cert</span></span><br><span class=\"line\"><span class=\"attr\">    client-key:</span> <span class=\"string\">path/to/my/client/key</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"cluster\"><a href=\"#cluster\" class=\"headerlink\" title=\"cluster\"></a>cluster</h2><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">clusters:</span></span><br><span class=\"line\"><span class=\"attr\">- cluster:</span></span><br><span class=\"line\"><span class=\"attr\">    certificate-authority:</span> <span class=\"string\">path/to/my/cafile</span></span><br><span class=\"line\"><span class=\"attr\">    server:</span> <span class=\"attr\">https://horse.org:4443</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> <span class=\"string\">horse-cluster</span></span><br><span class=\"line\"><span class=\"attr\">- cluster:</span></span><br><span class=\"line\"><span class=\"attr\">    insecure-skip-tls-verify:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    server:</span> <span class=\"attr\">https://pig.org:443</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> <span class=\"string\">pig-cluster</span></span><br></pre></td></tr></table></figure>\n\n<p>配置中 <strong>clusters</strong> 节点是一个列表，列表中的元素是Map结构，存储了每个集群的信息。<strong>clusters.cluster.server</strong> 用于配置k8s集群apiserver完整路径，一般采用TLS协议与apiserver进行通信就需要证书验证，<strong>clusters.cluster.certificate-authority</strong> 用于指定TLS协议的证书路径，若apiserver配置了不需要证书校验这个环境，则通过配置 <strong>clusters.cluster.insecure-skip-tls-verify: true</strong> 来跳过TLS协议的证书验证。因为可以配置多个集群的信息，我们就需要通过名称来指定访问哪个集群，所以还需要通过 <strong>clusters.name</strong> 为每个集群命名。</p>\n<p>除了读取配置文件之外，还可以通过 <strong>kubectl config set-cluster</strong> 指令动态配置集群信息，指令定义如下（详情参考<a href=\"http://kubernetes.kansea.com/docs/user-guide/kubectl/kubectl_config_set-cluster/\" target=\"_blank\" rel=\"noopener\">官方文档</a>）：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl config <span class=\"built_in\">set</span>-cluster NAME [--server=server] [--certificate-authority=path/to/certficate/authority] [--insecure-skip-tls-verify=<span class=\"literal\">true</span>]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"user\"><a href=\"#user\" class=\"headerlink\" title=\"user\"></a>user</h2><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">users:</span></span><br><span class=\"line\"><span class=\"attr\">- name:</span> <span class=\"string\">blue-user</span></span><br><span class=\"line\"><span class=\"attr\">  user:</span></span><br><span class=\"line\"><span class=\"attr\">    token:</span> <span class=\"string\">blue-token</span></span><br><span class=\"line\"><span class=\"attr\">- name:</span> <span class=\"string\">green-user</span></span><br><span class=\"line\"><span class=\"attr\">  user:</span></span><br><span class=\"line\"><span class=\"attr\">    client-certificate:</span> <span class=\"string\">path/to/my/client/cert</span></span><br><span class=\"line\"><span class=\"attr\">    client-key:</span> <span class=\"string\">path/to/my/client/key</span></span><br></pre></td></tr></table></figure>\n\n<p>配置中 <strong>users</strong> 节点是一个列表，列表中的元素是Map结构，存储了每个用户的认证信息。访问k8s集群时都会带上当前用户信息让服务端进行ACL鉴权，每个用户都需要通过 <strong>name</strong> 节点配置名称。此外，根据服务端的认证方式的不同，通过 <strong>client-certificate</strong>、<strong>client-key</strong>、<strong>token</strong> 或 <strong>username/password</strong> 配置用户认证信息。</p>\n<p>除了修改配置文件之外，还可以通过 <strong>kubectl config set-credentials</strong> 指令动态配置用户认证信息，指令定义如下（详情参考<a href=\"http://kubernetes.kansea.com/docs/user-guide/kubectl/kubectl_config_set-credentials\" target=\"_blank\" rel=\"noopener\">官方文档</a>）：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl config <span class=\"built_in\">set</span>-credentials NAME [--client-certificate=path/to/certfile] [--client-key=path/to/keyfile] [--token=bearer_token] [--username=basic_user] [--password=basic_password]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"context\"><a href=\"#context\" class=\"headerlink\" title=\"context\"></a>context</h2><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">contexts:</span></span><br><span class=\"line\"><span class=\"attr\">- context:</span></span><br><span class=\"line\"><span class=\"attr\">    cluster:</span> <span class=\"string\">horse-cluster</span></span><br><span class=\"line\"><span class=\"attr\">    namespace:</span> <span class=\"string\">chisel-ns</span></span><br><span class=\"line\"><span class=\"attr\">    user:</span> <span class=\"string\">green-user</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> <span class=\"string\">federal-context</span></span><br></pre></td></tr></table></figure>\n\n<p>正在编写</p>\n<h2 id=\"current-context\"><a href=\"#current-context\" class=\"headerlink\" title=\"current-context\"></a>current-context</h2><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">current-context:</span> <span class=\"string\">federal-context</span></span><br></pre></td></tr></table></figure>\n\n<p>正在编写</p>"},{"title":"K8s ServiceAccount","_content":"ServiceAccount 用于限制 Pod 的权限，K8s 创建一个 Pod 时会为这个 Pod 赋予一个 ServiceAccount。\n\n<!--more-->\n\nServiceAccount 属于命名空间资源，每个命名空间默认都会创建一个名为 default 的 ServiceAccount，创建工作负载时如果没有为这个工作负载指定 ServiceAccount 则会把默认的 default 授予给它。创建自定义 ServiceAccount 的简单例子如下：\n\n```sh\n$ cat custom-service-account.yml\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n    name: custom-service-account\n$ kubectl create -f custom-service-account.yml\nserviceaccount/custom-service-account created\n$ kubectl get serviceaccounts\nNAME                     SECRETS   AGE\ncustom-service-account   1         46s\ndefault                  1         2m21s\n```\n\n每个 ServiceAccount 都带有一个 CA 证书文件和一个 Token。\n\n```sh\n# 新建的 serviceaccount 中记录了与之对应的 secret 名称\n$ kubectl get serviceaccounts/custom-service-account -o yaml\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  creationTimestamp: \"2019-11-23T04:21:13Z\"\n  name: custom-service-account\n  namespace: default\n  resourceVersion: \"670\"\n  selfLink: /api/v1/namespaces/default/serviceaccounts/custom-service-account\n  uid: af96387b-0da8-11ea-9131-000c294c8d1a\nsecrets:\n- name: custom-service-account-token-pfs2v\n# 查询这个 secret 拿到 CA 证书文件以及 Token。\n$ kubectl get secret custom-service-account-token-pfs2v -o yaml\napiVersion: v1\ndata:\n  ca.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUN3akNDQWFxZ0F3SUJBZ0lCQURBTkJna3Foa2lHOXcwQkFRc0ZBREFTTVJBd0RnWURWUVFERXdkcmRXSmwKTFdOaE1CNFhEVEU1TVRFeU16QTBNVGcwTTFvWERUSTVNVEV5TURBME1UZzBNMW93RWpFUU1BNEdBMVVFQXhNSAphM1ZpWlMxallUQ0NBU0l3RFFZSktvWklodmNOQVFFQkJRQURnZ0VQQURDQ0FRb0NnZ0VCQUw5QStWQUl6UHRzCklBYXVYMEFYZm9jNjNETU8vQ0NYZVprbkorakJNK2U1SWsxQk52RzR3eFFyaHJySUx5eWM5YmxDYnQyZFVQZU0KUURwdm1kZHNYSU5CWWhTZTZKS2NLbmp5SXl4bGU4QUlGVGlKNlphcEdkUVlYOVNucXBiN1dwOStOcW12di9CVgpGR05ENlUrWG5jZTlidG1uaXE1ZEdoL1kycjdGSVlkaGt3TCs4Y0JxWGJkRVV1bjhuY1dpa2lFMXZybVZZS1BpClpQcjNQaFNKdmJYNkhnbmd1VkJ5dzNQSlFabWpJQjZHcWtOcFA5VTVaY2JELzJIVmNaajdOaEEyWWlMQUN0MnMKMEFxdmlOejJXeXB4TUZuN2RROUhjRmFFVXV6MkM3RVFZdDMrL0g0UnVwU3dEV05YQlcxY1ZEdzZrY2E5dml6TQowN2hISjZWa0JwTUNBd0VBQWFNak1DRXdEZ1lEVlIwUEFRSC9CQVFEQWdLa01BOEdBMVVkRXdFQi93UUZNQU1CCkFmOHdEUVlKS29aSWh2Y05BUUVMQlFBRGdnRUJBRmZlTTB6dFZaMHQ4VFhZRXNId3hndGFYZnMva0FYbUUrcXQKa0hxNnIxU0haMG5LazZXQ0JCUmtzUFpqVnZuR1NJRnJ5c0E2R2hISlJmdWM2alFWdjExV3o3QjgrNkNpWEF1UApWZk1FbUg1QjAzaXJkZlRoemtBZlhPaC9EcXUwS2Yxc0p2UUxVUmxBREh4VUdzVEVIRHQrWndRR3poZHdudnZhCkJuZ3FlTXJuUmlnVjRzcWlES2FoYlh6WHFSUk5tN3dRMnRCZWxqeXkzYnBlbDZST2E3Skc5QXBBd3Ardm1ZUmsKV0NpU3dpeTUxcHdaQmRnR0k0RDIrd0ZVN21YTi90dHd6SmIvd2tXSUR4R2lyV0tZQ0htSC9kKzYrTlJzUVhWdAo2QXZDVHdCOVI1THo1NG05S2pNRGJNNVU3TFlQVmh3REF4REM0ajB1dUU5THRhR1ZlWEE9Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K\n  namespace: ZGVmYXVsdA==\n  token: ZXlKaGJHY2lPaUpTVXpJMU5pSXNJbXRwWkNJNklpSjkuZXlKcGMzTWlPaUpyZFdKbGNtNWxkR1Z6TDNObGNuWnBZMlZoWTJOdmRXNTBJaXdpYTNWaVpYSnVaWFJsY3k1cGJ5OXpaWEoyYVdObFlXTmpiM1Z1ZEM5dVlXMWxjM0JoWTJVaU9pSmtaV1poZFd4MElpd2lhM1ZpWlhKdVpYUmxjeTVwYnk5elpYSjJhV05sWVdOamIzVnVkQzl6WldOeVpYUXVibUZ0WlNJNkltTjFjM1J2YlMxelpYSjJhV05sTFdGalkyOTFiblF0ZEc5clpXNHRjR1p6TW5ZaUxDSnJkV0psY201bGRHVnpMbWx2TDNObGNuWnBZMlZoWTJOdmRXNTBMM05sY25acFkyVXRZV05qYjNWdWRDNXVZVzFsSWpvaVkzVnpkRzl0TFhObGNuWnBZMlV0WVdOamIzVnVkQ0lzSW10MVltVnlibVYwWlhNdWFXOHZjMlZ5ZG1salpXRmpZMjkxYm5RdmMyVnlkbWxqWlMxaFkyTnZkVzUwTG5WcFpDSTZJbUZtT1RZek9EZGlMVEJrWVRndE1URmxZUzA1TVRNeExUQXdNR015T1RSak9HUXhZU0lzSW5OMVlpSTZJbk41YzNSbGJUcHpaWEoyYVdObFlXTmpiM1Z1ZERwa1pXWmhkV3gwT21OMWMzUnZiUzF6WlhKMmFXTmxMV0ZqWTI5MWJuUWlmUS5pckFOUU1yTTNjSGdqX2hvUmp3RUtxZDd4TC1QSDZta09scEw4c1FUWDJWSWExYW4tYzk2UUFRVjFTb0JwWElaWjBfSjhCMkhkSWljeVVtYmV6bW1uLTZJdDhHVFRDbUxNeWd5bFZkMUdIRU9PYlBxYzdIQVNyeG5YQTgxUzM4eTRhVlRGWVM2VU1YSzg5dVNKRmZNdnpqYVE5ek5IRTlaYU9XcUdYNTAwbGMxYUdwSVZBeURJN253WEh3Z3NPYUdQQ1RIZXdveFMzczh5a2ZPbWJaMHE5aUJjNXlsVVI3MjFSSHcwdXRDVHJDYm1VVk9XbU40bU5IYlR5ejlkb2tISDBIcHZrYnBGMVdBdzhsejhUdFJYN1daODVIMTVnSGZ4M21ncG00QTJ6OW5xcnpMN25hTENRb2ZmR1VFdENheUlSaUJicnY2Z1BhMm9zMTBvUm54Vmc=\nkind: Secret\nmetadata:\n  annotations:\n    kubernetes.io/service-account.name: custom-service-account\n    kubernetes.io/service-account.uid: af96387b-0da8-11ea-9131-000c294c8d1a\n  creationTimestamp: \"2019-11-23T04:21:13Z\"\n  name: custom-service-account-token-pfs2v\n  namespace: default\n  resourceVersion: \"669\"\n  selfLink: /api/v1/namespaces/default/secrets/custom-service-account-token-pfs2v\n  uid: af988508-0da8-11ea-9131-000c294c8d1a\ntype: kubernetes.io/service-account-token\n```\n\nServiceAccountAdmissionController 会将这些 ServiceAccount 的信息会以卷的形式自动挂载在容器的 /var/run/secrets/kubernetes.io/serviceaccount 目录中。宕容器想要访问 K8s 的其它资源时就会用到这些证书信息，例如：自定义Controller需要实时监控集群的资源变化情况，需要根据证书来通过apiserver的认证才能获取到资源信息。\nTokenController 除了监控 Secret 资源外，还会监控 ServiceAccount 资源，当新增（或删除） ServiceAccount 时，TokenController 会为之新建（或删除）对应的 API Token。\nServiceAccountController 则确保每个命名空间中都由一个名为 default 的 ServiceAccount。\n\n# ApiServer 安全校验\nApiServer 的请求限制由3部分组成：鉴权(authentication)、授权(authorization)、访问控制(admission control)。每一个组件中包含若干个插件链，当请求通过了一个组件下的所有插件后会将请求传递给下一部分组件的插件链继续校验，直到访问控制(admission control)组件的最后一个插件也通过了这个请求才算是校验通过。\n![ApiServer 安全](../../../../images/k8s-security.jpg)\n\n## 鉴权(Authentication)\nkubectl 是通过获取客户端的 ~/.kube/config 文件来得到证书以及Token，再把这些信息发送给 ApiServer。","source":"_drafts/k8s-serviceAccount.md","raw":"---\ntitle: \"K8s ServiceAccount\"\ncategory: k8s\n---\nServiceAccount 用于限制 Pod 的权限，K8s 创建一个 Pod 时会为这个 Pod 赋予一个 ServiceAccount。\n\n<!--more-->\n\nServiceAccount 属于命名空间资源，每个命名空间默认都会创建一个名为 default 的 ServiceAccount，创建工作负载时如果没有为这个工作负载指定 ServiceAccount 则会把默认的 default 授予给它。创建自定义 ServiceAccount 的简单例子如下：\n\n```sh\n$ cat custom-service-account.yml\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n    name: custom-service-account\n$ kubectl create -f custom-service-account.yml\nserviceaccount/custom-service-account created\n$ kubectl get serviceaccounts\nNAME                     SECRETS   AGE\ncustom-service-account   1         46s\ndefault                  1         2m21s\n```\n\n每个 ServiceAccount 都带有一个 CA 证书文件和一个 Token。\n\n```sh\n# 新建的 serviceaccount 中记录了与之对应的 secret 名称\n$ kubectl get serviceaccounts/custom-service-account -o yaml\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  creationTimestamp: \"2019-11-23T04:21:13Z\"\n  name: custom-service-account\n  namespace: default\n  resourceVersion: \"670\"\n  selfLink: /api/v1/namespaces/default/serviceaccounts/custom-service-account\n  uid: af96387b-0da8-11ea-9131-000c294c8d1a\nsecrets:\n- name: custom-service-account-token-pfs2v\n# 查询这个 secret 拿到 CA 证书文件以及 Token。\n$ kubectl get secret custom-service-account-token-pfs2v -o yaml\napiVersion: v1\ndata:\n  ca.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUN3akNDQWFxZ0F3SUJBZ0lCQURBTkJna3Foa2lHOXcwQkFRc0ZBREFTTVJBd0RnWURWUVFERXdkcmRXSmwKTFdOaE1CNFhEVEU1TVRFeU16QTBNVGcwTTFvWERUSTVNVEV5TURBME1UZzBNMW93RWpFUU1BNEdBMVVFQXhNSAphM1ZpWlMxallUQ0NBU0l3RFFZSktvWklodmNOQVFFQkJRQURnZ0VQQURDQ0FRb0NnZ0VCQUw5QStWQUl6UHRzCklBYXVYMEFYZm9jNjNETU8vQ0NYZVprbkorakJNK2U1SWsxQk52RzR3eFFyaHJySUx5eWM5YmxDYnQyZFVQZU0KUURwdm1kZHNYSU5CWWhTZTZKS2NLbmp5SXl4bGU4QUlGVGlKNlphcEdkUVlYOVNucXBiN1dwOStOcW12di9CVgpGR05ENlUrWG5jZTlidG1uaXE1ZEdoL1kycjdGSVlkaGt3TCs4Y0JxWGJkRVV1bjhuY1dpa2lFMXZybVZZS1BpClpQcjNQaFNKdmJYNkhnbmd1VkJ5dzNQSlFabWpJQjZHcWtOcFA5VTVaY2JELzJIVmNaajdOaEEyWWlMQUN0MnMKMEFxdmlOejJXeXB4TUZuN2RROUhjRmFFVXV6MkM3RVFZdDMrL0g0UnVwU3dEV05YQlcxY1ZEdzZrY2E5dml6TQowN2hISjZWa0JwTUNBd0VBQWFNak1DRXdEZ1lEVlIwUEFRSC9CQVFEQWdLa01BOEdBMVVkRXdFQi93UUZNQU1CCkFmOHdEUVlKS29aSWh2Y05BUUVMQlFBRGdnRUJBRmZlTTB6dFZaMHQ4VFhZRXNId3hndGFYZnMva0FYbUUrcXQKa0hxNnIxU0haMG5LazZXQ0JCUmtzUFpqVnZuR1NJRnJ5c0E2R2hISlJmdWM2alFWdjExV3o3QjgrNkNpWEF1UApWZk1FbUg1QjAzaXJkZlRoemtBZlhPaC9EcXUwS2Yxc0p2UUxVUmxBREh4VUdzVEVIRHQrWndRR3poZHdudnZhCkJuZ3FlTXJuUmlnVjRzcWlES2FoYlh6WHFSUk5tN3dRMnRCZWxqeXkzYnBlbDZST2E3Skc5QXBBd3Ardm1ZUmsKV0NpU3dpeTUxcHdaQmRnR0k0RDIrd0ZVN21YTi90dHd6SmIvd2tXSUR4R2lyV0tZQ0htSC9kKzYrTlJzUVhWdAo2QXZDVHdCOVI1THo1NG05S2pNRGJNNVU3TFlQVmh3REF4REM0ajB1dUU5THRhR1ZlWEE9Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K\n  namespace: ZGVmYXVsdA==\n  token: ZXlKaGJHY2lPaUpTVXpJMU5pSXNJbXRwWkNJNklpSjkuZXlKcGMzTWlPaUpyZFdKbGNtNWxkR1Z6TDNObGNuWnBZMlZoWTJOdmRXNTBJaXdpYTNWaVpYSnVaWFJsY3k1cGJ5OXpaWEoyYVdObFlXTmpiM1Z1ZEM5dVlXMWxjM0JoWTJVaU9pSmtaV1poZFd4MElpd2lhM1ZpWlhKdVpYUmxjeTVwYnk5elpYSjJhV05sWVdOamIzVnVkQzl6WldOeVpYUXVibUZ0WlNJNkltTjFjM1J2YlMxelpYSjJhV05sTFdGalkyOTFiblF0ZEc5clpXNHRjR1p6TW5ZaUxDSnJkV0psY201bGRHVnpMbWx2TDNObGNuWnBZMlZoWTJOdmRXNTBMM05sY25acFkyVXRZV05qYjNWdWRDNXVZVzFsSWpvaVkzVnpkRzl0TFhObGNuWnBZMlV0WVdOamIzVnVkQ0lzSW10MVltVnlibVYwWlhNdWFXOHZjMlZ5ZG1salpXRmpZMjkxYm5RdmMyVnlkbWxqWlMxaFkyTnZkVzUwTG5WcFpDSTZJbUZtT1RZek9EZGlMVEJrWVRndE1URmxZUzA1TVRNeExUQXdNR015T1RSak9HUXhZU0lzSW5OMVlpSTZJbk41YzNSbGJUcHpaWEoyYVdObFlXTmpiM1Z1ZERwa1pXWmhkV3gwT21OMWMzUnZiUzF6WlhKMmFXTmxMV0ZqWTI5MWJuUWlmUS5pckFOUU1yTTNjSGdqX2hvUmp3RUtxZDd4TC1QSDZta09scEw4c1FUWDJWSWExYW4tYzk2UUFRVjFTb0JwWElaWjBfSjhCMkhkSWljeVVtYmV6bW1uLTZJdDhHVFRDbUxNeWd5bFZkMUdIRU9PYlBxYzdIQVNyeG5YQTgxUzM4eTRhVlRGWVM2VU1YSzg5dVNKRmZNdnpqYVE5ek5IRTlaYU9XcUdYNTAwbGMxYUdwSVZBeURJN253WEh3Z3NPYUdQQ1RIZXdveFMzczh5a2ZPbWJaMHE5aUJjNXlsVVI3MjFSSHcwdXRDVHJDYm1VVk9XbU40bU5IYlR5ejlkb2tISDBIcHZrYnBGMVdBdzhsejhUdFJYN1daODVIMTVnSGZ4M21ncG00QTJ6OW5xcnpMN25hTENRb2ZmR1VFdENheUlSaUJicnY2Z1BhMm9zMTBvUm54Vmc=\nkind: Secret\nmetadata:\n  annotations:\n    kubernetes.io/service-account.name: custom-service-account\n    kubernetes.io/service-account.uid: af96387b-0da8-11ea-9131-000c294c8d1a\n  creationTimestamp: \"2019-11-23T04:21:13Z\"\n  name: custom-service-account-token-pfs2v\n  namespace: default\n  resourceVersion: \"669\"\n  selfLink: /api/v1/namespaces/default/secrets/custom-service-account-token-pfs2v\n  uid: af988508-0da8-11ea-9131-000c294c8d1a\ntype: kubernetes.io/service-account-token\n```\n\nServiceAccountAdmissionController 会将这些 ServiceAccount 的信息会以卷的形式自动挂载在容器的 /var/run/secrets/kubernetes.io/serviceaccount 目录中。宕容器想要访问 K8s 的其它资源时就会用到这些证书信息，例如：自定义Controller需要实时监控集群的资源变化情况，需要根据证书来通过apiserver的认证才能获取到资源信息。\nTokenController 除了监控 Secret 资源外，还会监控 ServiceAccount 资源，当新增（或删除） ServiceAccount 时，TokenController 会为之新建（或删除）对应的 API Token。\nServiceAccountController 则确保每个命名空间中都由一个名为 default 的 ServiceAccount。\n\n# ApiServer 安全校验\nApiServer 的请求限制由3部分组成：鉴权(authentication)、授权(authorization)、访问控制(admission control)。每一个组件中包含若干个插件链，当请求通过了一个组件下的所有插件后会将请求传递给下一部分组件的插件链继续校验，直到访问控制(admission control)组件的最后一个插件也通过了这个请求才算是校验通过。\n![ApiServer 安全](../../../../images/k8s-security.jpg)\n\n## 鉴权(Authentication)\nkubectl 是通过获取客户端的 ~/.kube/config 文件来得到证书以及Token，再把这些信息发送给 ApiServer。","slug":"k8s-serviceAccount","published":0,"date":"2020-02-04T02:33:56.146Z","updated":"2020-02-04T02:33:56.146Z","_id":"ck679mtrz000flbmdqno9mt94","comments":1,"layout":"post","photos":[],"link":"","content":"<p>ServiceAccount 用于限制 Pod 的权限，K8s 创建一个 Pod 时会为这个 Pod 赋予一个 ServiceAccount。</p>\n<a id=\"more\"></a>\n\n<p>ServiceAccount 属于命名空间资源，每个命名空间默认都会创建一个名为 default 的 ServiceAccount，创建工作负载时如果没有为这个工作负载指定 ServiceAccount 则会把默认的 default 授予给它。创建自定义 ServiceAccount 的简单例子如下：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cat custom-service-account.yml</span><br><span class=\"line\">apiVersion: v1</span><br><span class=\"line\">kind: ServiceAccount</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">    name: custom-service-account</span><br><span class=\"line\">$ kubectl create -f custom-service-account.yml</span><br><span class=\"line\">serviceaccount/custom-service-account created</span><br><span class=\"line\">$ kubectl get serviceaccounts</span><br><span class=\"line\">NAME                     SECRETS   AGE</span><br><span class=\"line\">custom-service-account   1         46s</span><br><span class=\"line\">default                  1         2m21s</span><br></pre></td></tr></table></figure>\n\n<p>每个 ServiceAccount 都带有一个 CA 证书文件和一个 Token。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 新建的 serviceaccount 中记录了与之对应的 secret 名称</span></span><br><span class=\"line\">$ kubectl get serviceaccounts/custom-service-account -o yaml</span><br><span class=\"line\">apiVersion: v1</span><br><span class=\"line\">kind: ServiceAccount</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  creationTimestamp: <span class=\"string\">\"2019-11-23T04:21:13Z\"</span></span><br><span class=\"line\">  name: custom-service-account</span><br><span class=\"line\">  namespace: default</span><br><span class=\"line\">  resourceVersion: <span class=\"string\">\"670\"</span></span><br><span class=\"line\">  selfLink: /api/v1/namespaces/default/serviceaccounts/custom-service-account</span><br><span class=\"line\">  uid: af96387b-0da8-11ea-9131-000c294c8d1a</span><br><span class=\"line\">secrets:</span><br><span class=\"line\">- name: custom-service-account-token-pfs2v</span><br><span class=\"line\"><span class=\"comment\"># 查询这个 secret 拿到 CA 证书文件以及 Token。</span></span><br><span class=\"line\">$ kubectl get secret custom-service-account-token-pfs2v -o yaml</span><br><span class=\"line\">apiVersion: v1</span><br><span class=\"line\">data:</span><br><span class=\"line\">  ca.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUN3akNDQWFxZ0F3SUJBZ0lCQURBTkJna3Foa2lHOXcwQkFRc0ZBREFTTVJBd0RnWURWUVFERXdkcmRXSmwKTFdOaE1CNFhEVEU1TVRFeU16QTBNVGcwTTFvWERUSTVNVEV5TURBME1UZzBNMW93RWpFUU1BNEdBMVVFQXhNSAphM1ZpWlMxallUQ0NBU0l3RFFZSktvWklodmNOQVFFQkJRQURnZ0VQQURDQ0FRb0NnZ0VCQUw5QStWQUl6UHRzCklBYXVYMEFYZm9jNjNETU8vQ0NYZVprbkorakJNK2U1SWsxQk52RzR3eFFyaHJySUx5eWM5YmxDYnQyZFVQZU0KUURwdm1kZHNYSU5CWWhTZTZKS2NLbmp5SXl4bGU4QUlGVGlKNlphcEdkUVlYOVNucXBiN1dwOStOcW12di9CVgpGR05ENlUrWG5jZTlidG1uaXE1ZEdoL1kycjdGSVlkaGt3TCs4Y0JxWGJkRVV1bjhuY1dpa2lFMXZybVZZS1BpClpQcjNQaFNKdmJYNkhnbmd1VkJ5dzNQSlFabWpJQjZHcWtOcFA5VTVaY2JELzJIVmNaajdOaEEyWWlMQUN0MnMKMEFxdmlOejJXeXB4TUZuN2RROUhjRmFFVXV6MkM3RVFZdDMrL0g0UnVwU3dEV05YQlcxY1ZEdzZrY2E5dml6TQowN2hISjZWa0JwTUNBd0VBQWFNak1DRXdEZ1lEVlIwUEFRSC9CQVFEQWdLa01BOEdBMVVkRXdFQi93UUZNQU1CCkFmOHdEUVlKS29aSWh2Y05BUUVMQlFBRGdnRUJBRmZlTTB6dFZaMHQ4VFhZRXNId3hndGFYZnMva0FYbUUrcXQKa0hxNnIxU0haMG5LazZXQ0JCUmtzUFpqVnZuR1NJRnJ5c0E2R2hISlJmdWM2alFWdjExV3o3QjgrNkNpWEF1UApWZk1FbUg1QjAzaXJkZlRoemtBZlhPaC9EcXUwS2Yxc0p2UUxVUmxBREh4VUdzVEVIRHQrWndRR3poZHdudnZhCkJuZ3FlTXJuUmlnVjRzcWlES2FoYlh6WHFSUk5tN3dRMnRCZWxqeXkzYnBlbDZST2E3Skc5QXBBd3Ardm1ZUmsKV0NpU3dpeTUxcHdaQmRnR0k0RDIrd0ZVN21YTi90dHd6SmIvd2tXSUR4R2lyV0tZQ0htSC9kKzYrTlJzUVhWdAo2QXZDVHdCOVI1THo1NG05S2pNRGJNNVU3TFlQVmh3REF4REM0ajB1dUU5THRhR1ZlWEE9Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K</span><br><span class=\"line\">  namespace: ZGVmYXVsdA==</span><br><span class=\"line\">  token: ZXlKaGJHY2lPaUpTVXpJMU5pSXNJbXRwWkNJNklpSjkuZXlKcGMzTWlPaUpyZFdKbGNtNWxkR1Z6TDNObGNuWnBZMlZoWTJOdmRXNTBJaXdpYTNWaVpYSnVaWFJsY3k1cGJ5OXpaWEoyYVdObFlXTmpiM1Z1ZEM5dVlXMWxjM0JoWTJVaU9pSmtaV1poZFd4MElpd2lhM1ZpWlhKdVpYUmxjeTVwYnk5elpYSjJhV05sWVdOamIzVnVkQzl6WldOeVpYUXVibUZ0WlNJNkltTjFjM1J2YlMxelpYSjJhV05sTFdGalkyOTFiblF0ZEc5clpXNHRjR1p6TW5ZaUxDSnJkV0psY201bGRHVnpMbWx2TDNObGNuWnBZMlZoWTJOdmRXNTBMM05sY25acFkyVXRZV05qYjNWdWRDNXVZVzFsSWpvaVkzVnpkRzl0TFhObGNuWnBZMlV0WVdOamIzVnVkQ0lzSW10MVltVnlibVYwWlhNdWFXOHZjMlZ5ZG1salpXRmpZMjkxYm5RdmMyVnlkbWxqWlMxaFkyTnZkVzUwTG5WcFpDSTZJbUZtT1RZek9EZGlMVEJrWVRndE1URmxZUzA1TVRNeExUQXdNR015T1RSak9HUXhZU0lzSW5OMVlpSTZJbk41YzNSbGJUcHpaWEoyYVdObFlXTmpiM1Z1ZERwa1pXWmhkV3gwT21OMWMzUnZiUzF6WlhKMmFXTmxMV0ZqWTI5MWJuUWlmUS5pckFOUU1yTTNjSGdqX2hvUmp3RUtxZDd4TC1QSDZta09scEw4c1FUWDJWSWExYW4tYzk2UUFRVjFTb0JwWElaWjBfSjhCMkhkSWljeVVtYmV6bW1uLTZJdDhHVFRDbUxNeWd5bFZkMUdIRU9PYlBxYzdIQVNyeG5YQTgxUzM4eTRhVlRGWVM2VU1YSzg5dVNKRmZNdnpqYVE5ek5IRTlaYU9XcUdYNTAwbGMxYUdwSVZBeURJN253WEh3Z3NPYUdQQ1RIZXdveFMzczh5a2ZPbWJaMHE5aUJjNXlsVVI3MjFSSHcwdXRDVHJDYm1VVk9XbU40bU5IYlR5ejlkb2tISDBIcHZrYnBGMVdBdzhsejhUdFJYN1daODVIMTVnSGZ4M21ncG00QTJ6OW5xcnpMN25hTENRb2ZmR1VFdENheUlSaUJicnY2Z1BhMm9zMTBvUm54Vmc=</span><br><span class=\"line\">kind: Secret</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  annotations:</span><br><span class=\"line\">    kubernetes.io/service-account.name: custom-service-account</span><br><span class=\"line\">    kubernetes.io/service-account.uid: af96387b-0da8-11ea-9131-000c294c8d1a</span><br><span class=\"line\">  creationTimestamp: <span class=\"string\">\"2019-11-23T04:21:13Z\"</span></span><br><span class=\"line\">  name: custom-service-account-token-pfs2v</span><br><span class=\"line\">  namespace: default</span><br><span class=\"line\">  resourceVersion: <span class=\"string\">\"669\"</span></span><br><span class=\"line\">  selfLink: /api/v1/namespaces/default/secrets/custom-service-account-token-pfs2v</span><br><span class=\"line\">  uid: af988508-0da8-11ea-9131-000c294c8d1a</span><br><span class=\"line\"><span class=\"built_in\">type</span>: kubernetes.io/service-account-token</span><br></pre></td></tr></table></figure>\n\n<p>ServiceAccountAdmissionController 会将这些 ServiceAccount 的信息会以卷的形式自动挂载在容器的 /var/run/secrets/kubernetes.io/serviceaccount 目录中。宕容器想要访问 K8s 的其它资源时就会用到这些证书信息，例如：自定义Controller需要实时监控集群的资源变化情况，需要根据证书来通过apiserver的认证才能获取到资源信息。<br>TokenController 除了监控 Secret 资源外，还会监控 ServiceAccount 资源，当新增（或删除） ServiceAccount 时，TokenController 会为之新建（或删除）对应的 API Token。<br>ServiceAccountController 则确保每个命名空间中都由一个名为 default 的 ServiceAccount。</p>\n<h1 id=\"ApiServer-安全校验\"><a href=\"#ApiServer-安全校验\" class=\"headerlink\" title=\"ApiServer 安全校验\"></a>ApiServer 安全校验</h1><p>ApiServer 的请求限制由3部分组成：鉴权(authentication)、授权(authorization)、访问控制(admission control)。每一个组件中包含若干个插件链，当请求通过了一个组件下的所有插件后会将请求传递给下一部分组件的插件链继续校验，直到访问控制(admission control)组件的最后一个插件也通过了这个请求才算是校验通过。<br><img src=\"../../../../images/k8s-security.jpg\" alt=\"ApiServer 安全\"></p>\n<h2 id=\"鉴权-Authentication\"><a href=\"#鉴权-Authentication\" class=\"headerlink\" title=\"鉴权(Authentication)\"></a>鉴权(Authentication)</h2><p>kubectl 是通过获取客户端的 ~/.kube/config 文件来得到证书以及Token，再把这些信息发送给 ApiServer。</p>\n","site":{"data":{}},"excerpt":"<p>ServiceAccount 用于限制 Pod 的权限，K8s 创建一个 Pod 时会为这个 Pod 赋予一个 ServiceAccount。</p>","more":"<p>ServiceAccount 属于命名空间资源，每个命名空间默认都会创建一个名为 default 的 ServiceAccount，创建工作负载时如果没有为这个工作负载指定 ServiceAccount 则会把默认的 default 授予给它。创建自定义 ServiceAccount 的简单例子如下：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cat custom-service-account.yml</span><br><span class=\"line\">apiVersion: v1</span><br><span class=\"line\">kind: ServiceAccount</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">    name: custom-service-account</span><br><span class=\"line\">$ kubectl create -f custom-service-account.yml</span><br><span class=\"line\">serviceaccount/custom-service-account created</span><br><span class=\"line\">$ kubectl get serviceaccounts</span><br><span class=\"line\">NAME                     SECRETS   AGE</span><br><span class=\"line\">custom-service-account   1         46s</span><br><span class=\"line\">default                  1         2m21s</span><br></pre></td></tr></table></figure>\n\n<p>每个 ServiceAccount 都带有一个 CA 证书文件和一个 Token。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 新建的 serviceaccount 中记录了与之对应的 secret 名称</span></span><br><span class=\"line\">$ kubectl get serviceaccounts/custom-service-account -o yaml</span><br><span class=\"line\">apiVersion: v1</span><br><span class=\"line\">kind: ServiceAccount</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  creationTimestamp: <span class=\"string\">\"2019-11-23T04:21:13Z\"</span></span><br><span class=\"line\">  name: custom-service-account</span><br><span class=\"line\">  namespace: default</span><br><span class=\"line\">  resourceVersion: <span class=\"string\">\"670\"</span></span><br><span class=\"line\">  selfLink: /api/v1/namespaces/default/serviceaccounts/custom-service-account</span><br><span class=\"line\">  uid: af96387b-0da8-11ea-9131-000c294c8d1a</span><br><span class=\"line\">secrets:</span><br><span class=\"line\">- name: custom-service-account-token-pfs2v</span><br><span class=\"line\"><span class=\"comment\"># 查询这个 secret 拿到 CA 证书文件以及 Token。</span></span><br><span class=\"line\">$ kubectl get secret custom-service-account-token-pfs2v -o yaml</span><br><span class=\"line\">apiVersion: v1</span><br><span class=\"line\">data:</span><br><span class=\"line\">  ca.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUN3akNDQWFxZ0F3SUJBZ0lCQURBTkJna3Foa2lHOXcwQkFRc0ZBREFTTVJBd0RnWURWUVFERXdkcmRXSmwKTFdOaE1CNFhEVEU1TVRFeU16QTBNVGcwTTFvWERUSTVNVEV5TURBME1UZzBNMW93RWpFUU1BNEdBMVVFQXhNSAphM1ZpWlMxallUQ0NBU0l3RFFZSktvWklodmNOQVFFQkJRQURnZ0VQQURDQ0FRb0NnZ0VCQUw5QStWQUl6UHRzCklBYXVYMEFYZm9jNjNETU8vQ0NYZVprbkorakJNK2U1SWsxQk52RzR3eFFyaHJySUx5eWM5YmxDYnQyZFVQZU0KUURwdm1kZHNYSU5CWWhTZTZKS2NLbmp5SXl4bGU4QUlGVGlKNlphcEdkUVlYOVNucXBiN1dwOStOcW12di9CVgpGR05ENlUrWG5jZTlidG1uaXE1ZEdoL1kycjdGSVlkaGt3TCs4Y0JxWGJkRVV1bjhuY1dpa2lFMXZybVZZS1BpClpQcjNQaFNKdmJYNkhnbmd1VkJ5dzNQSlFabWpJQjZHcWtOcFA5VTVaY2JELzJIVmNaajdOaEEyWWlMQUN0MnMKMEFxdmlOejJXeXB4TUZuN2RROUhjRmFFVXV6MkM3RVFZdDMrL0g0UnVwU3dEV05YQlcxY1ZEdzZrY2E5dml6TQowN2hISjZWa0JwTUNBd0VBQWFNak1DRXdEZ1lEVlIwUEFRSC9CQVFEQWdLa01BOEdBMVVkRXdFQi93UUZNQU1CCkFmOHdEUVlKS29aSWh2Y05BUUVMQlFBRGdnRUJBRmZlTTB6dFZaMHQ4VFhZRXNId3hndGFYZnMva0FYbUUrcXQKa0hxNnIxU0haMG5LazZXQ0JCUmtzUFpqVnZuR1NJRnJ5c0E2R2hISlJmdWM2alFWdjExV3o3QjgrNkNpWEF1UApWZk1FbUg1QjAzaXJkZlRoemtBZlhPaC9EcXUwS2Yxc0p2UUxVUmxBREh4VUdzVEVIRHQrWndRR3poZHdudnZhCkJuZ3FlTXJuUmlnVjRzcWlES2FoYlh6WHFSUk5tN3dRMnRCZWxqeXkzYnBlbDZST2E3Skc5QXBBd3Ardm1ZUmsKV0NpU3dpeTUxcHdaQmRnR0k0RDIrd0ZVN21YTi90dHd6SmIvd2tXSUR4R2lyV0tZQ0htSC9kKzYrTlJzUVhWdAo2QXZDVHdCOVI1THo1NG05S2pNRGJNNVU3TFlQVmh3REF4REM0ajB1dUU5THRhR1ZlWEE9Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K</span><br><span class=\"line\">  namespace: ZGVmYXVsdA==</span><br><span class=\"line\">  token: ZXlKaGJHY2lPaUpTVXpJMU5pSXNJbXRwWkNJNklpSjkuZXlKcGMzTWlPaUpyZFdKbGNtNWxkR1Z6TDNObGNuWnBZMlZoWTJOdmRXNTBJaXdpYTNWaVpYSnVaWFJsY3k1cGJ5OXpaWEoyYVdObFlXTmpiM1Z1ZEM5dVlXMWxjM0JoWTJVaU9pSmtaV1poZFd4MElpd2lhM1ZpWlhKdVpYUmxjeTVwYnk5elpYSjJhV05sWVdOamIzVnVkQzl6WldOeVpYUXVibUZ0WlNJNkltTjFjM1J2YlMxelpYSjJhV05sTFdGalkyOTFiblF0ZEc5clpXNHRjR1p6TW5ZaUxDSnJkV0psY201bGRHVnpMbWx2TDNObGNuWnBZMlZoWTJOdmRXNTBMM05sY25acFkyVXRZV05qYjNWdWRDNXVZVzFsSWpvaVkzVnpkRzl0TFhObGNuWnBZMlV0WVdOamIzVnVkQ0lzSW10MVltVnlibVYwWlhNdWFXOHZjMlZ5ZG1salpXRmpZMjkxYm5RdmMyVnlkbWxqWlMxaFkyTnZkVzUwTG5WcFpDSTZJbUZtT1RZek9EZGlMVEJrWVRndE1URmxZUzA1TVRNeExUQXdNR015T1RSak9HUXhZU0lzSW5OMVlpSTZJbk41YzNSbGJUcHpaWEoyYVdObFlXTmpiM1Z1ZERwa1pXWmhkV3gwT21OMWMzUnZiUzF6WlhKMmFXTmxMV0ZqWTI5MWJuUWlmUS5pckFOUU1yTTNjSGdqX2hvUmp3RUtxZDd4TC1QSDZta09scEw4c1FUWDJWSWExYW4tYzk2UUFRVjFTb0JwWElaWjBfSjhCMkhkSWljeVVtYmV6bW1uLTZJdDhHVFRDbUxNeWd5bFZkMUdIRU9PYlBxYzdIQVNyeG5YQTgxUzM4eTRhVlRGWVM2VU1YSzg5dVNKRmZNdnpqYVE5ek5IRTlaYU9XcUdYNTAwbGMxYUdwSVZBeURJN253WEh3Z3NPYUdQQ1RIZXdveFMzczh5a2ZPbWJaMHE5aUJjNXlsVVI3MjFSSHcwdXRDVHJDYm1VVk9XbU40bU5IYlR5ejlkb2tISDBIcHZrYnBGMVdBdzhsejhUdFJYN1daODVIMTVnSGZ4M21ncG00QTJ6OW5xcnpMN25hTENRb2ZmR1VFdENheUlSaUJicnY2Z1BhMm9zMTBvUm54Vmc=</span><br><span class=\"line\">kind: Secret</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  annotations:</span><br><span class=\"line\">    kubernetes.io/service-account.name: custom-service-account</span><br><span class=\"line\">    kubernetes.io/service-account.uid: af96387b-0da8-11ea-9131-000c294c8d1a</span><br><span class=\"line\">  creationTimestamp: <span class=\"string\">\"2019-11-23T04:21:13Z\"</span></span><br><span class=\"line\">  name: custom-service-account-token-pfs2v</span><br><span class=\"line\">  namespace: default</span><br><span class=\"line\">  resourceVersion: <span class=\"string\">\"669\"</span></span><br><span class=\"line\">  selfLink: /api/v1/namespaces/default/secrets/custom-service-account-token-pfs2v</span><br><span class=\"line\">  uid: af988508-0da8-11ea-9131-000c294c8d1a</span><br><span class=\"line\"><span class=\"built_in\">type</span>: kubernetes.io/service-account-token</span><br></pre></td></tr></table></figure>\n\n<p>ServiceAccountAdmissionController 会将这些 ServiceAccount 的信息会以卷的形式自动挂载在容器的 /var/run/secrets/kubernetes.io/serviceaccount 目录中。宕容器想要访问 K8s 的其它资源时就会用到这些证书信息，例如：自定义Controller需要实时监控集群的资源变化情况，需要根据证书来通过apiserver的认证才能获取到资源信息。<br>TokenController 除了监控 Secret 资源外，还会监控 ServiceAccount 资源，当新增（或删除） ServiceAccount 时，TokenController 会为之新建（或删除）对应的 API Token。<br>ServiceAccountController 则确保每个命名空间中都由一个名为 default 的 ServiceAccount。</p>\n<h1 id=\"ApiServer-安全校验\"><a href=\"#ApiServer-安全校验\" class=\"headerlink\" title=\"ApiServer 安全校验\"></a>ApiServer 安全校验</h1><p>ApiServer 的请求限制由3部分组成：鉴权(authentication)、授权(authorization)、访问控制(admission control)。每一个组件中包含若干个插件链，当请求通过了一个组件下的所有插件后会将请求传递给下一部分组件的插件链继续校验，直到访问控制(admission control)组件的最后一个插件也通过了这个请求才算是校验通过。<br><img src=\"../../../../images/k8s-security.jpg\" alt=\"ApiServer 安全\"></p>\n<h2 id=\"鉴权-Authentication\"><a href=\"#鉴权-Authentication\" class=\"headerlink\" title=\"鉴权(Authentication)\"></a>鉴权(Authentication)</h2><p>kubectl 是通过获取客户端的 ~/.kube/config 文件来得到证书以及Token，再把这些信息发送给 ApiServer。</p>"},{"title":"k8s Pod","_content":"Pod是在K8s集群中运行部署应用或服务的最小单元，它是可以支持多容器的。支持多个容器在一个Pod中共享网络地址和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。\n\n<!--more-->\n\n下面是Pod构建配置文件的完整模板：\n```yaml\napiVersion: v1        　　          #必选，版本号，例如v1,版本号必须可以用 kubectl api-versions 查询到 .\nkind: Pod       　　　　　　         #必选，Pod\nmetadata:       　　　　　　         #必选，元数据\n  name: string        　　          #必选，Pod名称\n  namespace: string     　　        #必选，Pod所属的命名空间,默认为\"default\"\n  labels:       　　　　　　          #自定义标签\n    - name: string      　          #自定义标签名字\n  annotations:        　　                 #自定义注释列表\n    - name: string\nspec:         　　　　　　　            #必选，Pod中容器的详细定义\n  containers:       　　　　            #必选，Pod中容器列表\n  - name: string      　　                #必选，容器名称,需符合RFC 1035规范\n    image: string     　　                #必选，容器的镜像名称\n    imagePullPolicy: [ Always|Never|IfNotPresent ]  #获取镜像的策略 Alawys表示下载镜像 IfnotPresent表示优先使用本地镜像,否则下载镜像，Nerver表示仅使用本地镜像\n    command: [string]     　　        #容器的启动命令列表，如不指定，使用打包时使用的启动命令\n    args: [string]      　　             #容器的启动命令参数列表\n    workingDir: string                     #容器的工作目录\n    volumeMounts:     　　　　        #挂载到容器内部的存储卷配置\n    - name: string      　　　        #引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名\n      mountPath: string                 #存储卷在容器内mount的绝对路径，应少于512字符\n      readOnly: boolean                 #是否为只读模式\n    ports:        　　　　　　        #需要暴露的端口库号列表\n    - name: string      　　　        #端口的名称\n      containerPort: int                #容器需要监听的端口号\n      hostPort: int     　　             #容器所在主机需要监听的端口号，默认与Container相同\n      protocol: string                  #端口协议，支持TCP和UDP，默认TCP\n    env:        　　　　　　            #容器运行前需设置的环境变量列表\n    - name: string      　　            #环境变量名称\n      value: string     　　            #环境变量的值\n    resources:        　　                #资源限制和请求的设置\n      limits:       　　　　            #资源限制的设置\n        cpu: string     　　            #Cpu的限制，单位为core数，将用于docker run --cpu-shares参数\n        memory: string                  #内存限制，单位可以为Mib/Gib，将用于docker run --memory参数\n      requests:       　　                #资源请求的设置\n        cpu: string     　　            #Cpu请求，容器启动的初始可用数量\n        memory: string                    #内存请求,容器启动的初始可用数量\n    livenessProbe:      　　            #对Pod内各容器健康检查的设置，当探测无响应几次后将自动重启该容器，检查方法有exec、httpGet和tcpSocket，对一个容器只需设置其中一种方法即可\n      exec:       　　　　　　        #对Pod容器内检查方式设置为exec方式\n        command: [string]               #exec方式需要制定的命令或脚本\n      httpGet:        　　　　        #对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port\n        path: string\n        port: number\n        host: string\n        scheme: string\n        HttpHeaders:\n        - name: string\n          value: string\n      tcpSocket:      　　　　　　#对Pod内个容器健康检查方式设置为tcpSocket方式\n         port: number\n       initialDelaySeconds: 0       #容器启动完成后首次探测的时间，单位为秒\n       timeoutSeconds: 0    　　    #对容器健康检查探测等待响应的超时时间，单位秒，默认1秒\n       periodSeconds: 0     　　    #对容器监控检查的定期探测时间设置，单位秒，默认10秒一次\n       successThreshold: 0\n       failureThreshold: 0\n       securityContext:\n         privileged: false\n    restartPolicy: [Always | Never | OnFailure] #Pod的重启策略，Always表示一旦不管以何种方式终止运行，kubelet都将重启，OnFailure表示只有Pod以非0退出码退出才重启，Nerver表示不再重启该Pod\n    nodeSelector: obeject   　　    #设置NodeSelector表示将该Pod调度到包含这个label的node上，以key：value的格式指定\n    imagePullSecrets:     　　　　#Pull镜像时使用的secret名称，以key：secretkey格式指定\n    - name: string\n    hostNetwork: false      　　    #是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络\n    volumes:        　　　　　　    #在该pod上定义共享存储卷列表\n    - name: string     　　 　　    #共享存储卷名称 （volumes类型有很多种）\n      emptyDir: {}      　　　　    #类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值\n      hostPath: string      　　    #类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录\n        path: string      　　        #Pod所在宿主机的目录，将被用于同期中mount的目录\n      secret:       　　　　　　    #类型为secret的存储卷，挂载集群与定义的secre对象到容器内部\n        scretname: string  \n        items:     \n        - key: string\n          path: string\n      configMap:      　　　　            #类型为configMap的存储卷，挂载预定义的configMap对象到容器内部\n        name: string\n        items:\n        - key: string\n          path: string\n```","source":"_drafts/k8s-pod.md","raw":"---\ntitle: \"k8s Pod\"\ncategory: k8s\n---\nPod是在K8s集群中运行部署应用或服务的最小单元，它是可以支持多容器的。支持多个容器在一个Pod中共享网络地址和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。\n\n<!--more-->\n\n下面是Pod构建配置文件的完整模板：\n```yaml\napiVersion: v1        　　          #必选，版本号，例如v1,版本号必须可以用 kubectl api-versions 查询到 .\nkind: Pod       　　　　　　         #必选，Pod\nmetadata:       　　　　　　         #必选，元数据\n  name: string        　　          #必选，Pod名称\n  namespace: string     　　        #必选，Pod所属的命名空间,默认为\"default\"\n  labels:       　　　　　　          #自定义标签\n    - name: string      　          #自定义标签名字\n  annotations:        　　                 #自定义注释列表\n    - name: string\nspec:         　　　　　　　            #必选，Pod中容器的详细定义\n  containers:       　　　　            #必选，Pod中容器列表\n  - name: string      　　                #必选，容器名称,需符合RFC 1035规范\n    image: string     　　                #必选，容器的镜像名称\n    imagePullPolicy: [ Always|Never|IfNotPresent ]  #获取镜像的策略 Alawys表示下载镜像 IfnotPresent表示优先使用本地镜像,否则下载镜像，Nerver表示仅使用本地镜像\n    command: [string]     　　        #容器的启动命令列表，如不指定，使用打包时使用的启动命令\n    args: [string]      　　             #容器的启动命令参数列表\n    workingDir: string                     #容器的工作目录\n    volumeMounts:     　　　　        #挂载到容器内部的存储卷配置\n    - name: string      　　　        #引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名\n      mountPath: string                 #存储卷在容器内mount的绝对路径，应少于512字符\n      readOnly: boolean                 #是否为只读模式\n    ports:        　　　　　　        #需要暴露的端口库号列表\n    - name: string      　　　        #端口的名称\n      containerPort: int                #容器需要监听的端口号\n      hostPort: int     　　             #容器所在主机需要监听的端口号，默认与Container相同\n      protocol: string                  #端口协议，支持TCP和UDP，默认TCP\n    env:        　　　　　　            #容器运行前需设置的环境变量列表\n    - name: string      　　            #环境变量名称\n      value: string     　　            #环境变量的值\n    resources:        　　                #资源限制和请求的设置\n      limits:       　　　　            #资源限制的设置\n        cpu: string     　　            #Cpu的限制，单位为core数，将用于docker run --cpu-shares参数\n        memory: string                  #内存限制，单位可以为Mib/Gib，将用于docker run --memory参数\n      requests:       　　                #资源请求的设置\n        cpu: string     　　            #Cpu请求，容器启动的初始可用数量\n        memory: string                    #内存请求,容器启动的初始可用数量\n    livenessProbe:      　　            #对Pod内各容器健康检查的设置，当探测无响应几次后将自动重启该容器，检查方法有exec、httpGet和tcpSocket，对一个容器只需设置其中一种方法即可\n      exec:       　　　　　　        #对Pod容器内检查方式设置为exec方式\n        command: [string]               #exec方式需要制定的命令或脚本\n      httpGet:        　　　　        #对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port\n        path: string\n        port: number\n        host: string\n        scheme: string\n        HttpHeaders:\n        - name: string\n          value: string\n      tcpSocket:      　　　　　　#对Pod内个容器健康检查方式设置为tcpSocket方式\n         port: number\n       initialDelaySeconds: 0       #容器启动完成后首次探测的时间，单位为秒\n       timeoutSeconds: 0    　　    #对容器健康检查探测等待响应的超时时间，单位秒，默认1秒\n       periodSeconds: 0     　　    #对容器监控检查的定期探测时间设置，单位秒，默认10秒一次\n       successThreshold: 0\n       failureThreshold: 0\n       securityContext:\n         privileged: false\n    restartPolicy: [Always | Never | OnFailure] #Pod的重启策略，Always表示一旦不管以何种方式终止运行，kubelet都将重启，OnFailure表示只有Pod以非0退出码退出才重启，Nerver表示不再重启该Pod\n    nodeSelector: obeject   　　    #设置NodeSelector表示将该Pod调度到包含这个label的node上，以key：value的格式指定\n    imagePullSecrets:     　　　　#Pull镜像时使用的secret名称，以key：secretkey格式指定\n    - name: string\n    hostNetwork: false      　　    #是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络\n    volumes:        　　　　　　    #在该pod上定义共享存储卷列表\n    - name: string     　　 　　    #共享存储卷名称 （volumes类型有很多种）\n      emptyDir: {}      　　　　    #类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值\n      hostPath: string      　　    #类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录\n        path: string      　　        #Pod所在宿主机的目录，将被用于同期中mount的目录\n      secret:       　　　　　　    #类型为secret的存储卷，挂载集群与定义的secre对象到容器内部\n        scretname: string  \n        items:     \n        - key: string\n          path: string\n      configMap:      　　　　            #类型为configMap的存储卷，挂载预定义的configMap对象到容器内部\n        name: string\n        items:\n        - key: string\n          path: string\n```","slug":"k8s-pod","published":0,"date":"2020-01-16T17:23:25.488Z","updated":"2019-10-17T12:18:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck679mts0000glbmdbpaswj0h","content":"<p>Pod是在K8s集群中运行部署应用或服务的最小单元，它是可以支持多容器的。支持多个容器在一个Pod中共享网络地址和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。</p>\n<a id=\"more\"></a>\n\n<p>下面是Pod构建配置文件的完整模板：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span>        　　          <span class=\"comment\">#必选，版本号，例如v1,版本号必须可以用 kubectl api-versions 查询到 .</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span>       　　　　　　         <span class=\"comment\">#必选，Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span>       　　　　　　         <span class=\"comment\">#必选，元数据</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> <span class=\"string\">string</span>        　　          <span class=\"comment\">#必选，Pod名称</span></span><br><span class=\"line\"><span class=\"attr\">  namespace:</span> <span class=\"string\">string</span>     　　        <span class=\"comment\">#必选，Pod所属的命名空间,默认为\"default\"</span></span><br><span class=\"line\"><span class=\"attr\">  labels:</span>       　　　　　　          <span class=\"comment\">#自定义标签</span></span><br><span class=\"line\"><span class=\"attr\">    - name:</span> <span class=\"string\">string</span>      　          <span class=\"comment\">#自定义标签名字</span></span><br><span class=\"line\"><span class=\"attr\">  annotations:</span>        　　                 <span class=\"comment\">#自定义注释列表</span></span><br><span class=\"line\"><span class=\"attr\">    - name:</span> <span class=\"string\">string</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span>         　　　　　　　            <span class=\"comment\">#必选，Pod中容器的详细定义</span></span><br><span class=\"line\"><span class=\"attr\">  containers:</span>       　　　　            <span class=\"comment\">#必选，Pod中容器列表</span></span><br><span class=\"line\"><span class=\"attr\">  - name:</span> <span class=\"string\">string</span>      　　                <span class=\"comment\">#必选，容器名称,需符合RFC 1035规范</span></span><br><span class=\"line\"><span class=\"attr\">    image:</span> <span class=\"string\">string</span>     　　                <span class=\"comment\">#必选，容器的镜像名称</span></span><br><span class=\"line\"><span class=\"attr\">    imagePullPolicy:</span> <span class=\"string\">[</span> <span class=\"string\">Always|Never|IfNotPresent</span> <span class=\"string\">]</span>  <span class=\"comment\">#获取镜像的策略 Alawys表示下载镜像 IfnotPresent表示优先使用本地镜像,否则下载镜像，Nerver表示仅使用本地镜像</span></span><br><span class=\"line\"><span class=\"attr\">    command:</span> <span class=\"string\">[string]</span>     　　        <span class=\"comment\">#容器的启动命令列表，如不指定，使用打包时使用的启动命令</span></span><br><span class=\"line\"><span class=\"attr\">    args:</span> <span class=\"string\">[string]</span>      　　             <span class=\"comment\">#容器的启动命令参数列表</span></span><br><span class=\"line\"><span class=\"attr\">    workingDir:</span> <span class=\"string\">string</span>                     <span class=\"comment\">#容器的工作目录</span></span><br><span class=\"line\"><span class=\"attr\">    volumeMounts:</span>     　　　　        <span class=\"comment\">#挂载到容器内部的存储卷配置</span></span><br><span class=\"line\"><span class=\"attr\">    - name:</span> <span class=\"string\">string</span>      　　　        <span class=\"comment\">#引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名</span></span><br><span class=\"line\"><span class=\"attr\">      mountPath:</span> <span class=\"string\">string</span>                 <span class=\"comment\">#存储卷在容器内mount的绝对路径，应少于512字符</span></span><br><span class=\"line\"><span class=\"attr\">      readOnly:</span> <span class=\"string\">boolean</span>                 <span class=\"comment\">#是否为只读模式</span></span><br><span class=\"line\"><span class=\"attr\">    ports:</span>        　　　　　　        <span class=\"comment\">#需要暴露的端口库号列表</span></span><br><span class=\"line\"><span class=\"attr\">    - name:</span> <span class=\"string\">string</span>      　　　        <span class=\"comment\">#端口的名称</span></span><br><span class=\"line\"><span class=\"attr\">      containerPort:</span> <span class=\"string\">int</span>                <span class=\"comment\">#容器需要监听的端口号</span></span><br><span class=\"line\"><span class=\"attr\">      hostPort:</span> <span class=\"string\">int</span>     　　             <span class=\"comment\">#容器所在主机需要监听的端口号，默认与Container相同</span></span><br><span class=\"line\"><span class=\"attr\">      protocol:</span> <span class=\"string\">string</span>                  <span class=\"comment\">#端口协议，支持TCP和UDP，默认TCP</span></span><br><span class=\"line\"><span class=\"attr\">    env:</span>        　　　　　　            <span class=\"comment\">#容器运行前需设置的环境变量列表</span></span><br><span class=\"line\"><span class=\"attr\">    - name:</span> <span class=\"string\">string</span>      　　            <span class=\"comment\">#环境变量名称</span></span><br><span class=\"line\"><span class=\"attr\">      value:</span> <span class=\"string\">string</span>     　　            <span class=\"comment\">#环境变量的值</span></span><br><span class=\"line\"><span class=\"attr\">    resources:</span>        　　                <span class=\"comment\">#资源限制和请求的设置</span></span><br><span class=\"line\"><span class=\"attr\">      limits:</span>       　　　　            <span class=\"comment\">#资源限制的设置</span></span><br><span class=\"line\"><span class=\"attr\">        cpu:</span> <span class=\"string\">string</span>     　　            <span class=\"comment\">#Cpu的限制，单位为core数，将用于docker run --cpu-shares参数</span></span><br><span class=\"line\"><span class=\"attr\">        memory:</span> <span class=\"string\">string</span>                  <span class=\"comment\">#内存限制，单位可以为Mib/Gib，将用于docker run --memory参数</span></span><br><span class=\"line\"><span class=\"attr\">      requests:</span>       　　                <span class=\"comment\">#资源请求的设置</span></span><br><span class=\"line\"><span class=\"attr\">        cpu:</span> <span class=\"string\">string</span>     　　            <span class=\"comment\">#Cpu请求，容器启动的初始可用数量</span></span><br><span class=\"line\"><span class=\"attr\">        memory:</span> <span class=\"string\">string</span>                    <span class=\"comment\">#内存请求,容器启动的初始可用数量</span></span><br><span class=\"line\"><span class=\"attr\">    livenessProbe:</span>      　　            <span class=\"comment\">#对Pod内各容器健康检查的设置，当探测无响应几次后将自动重启该容器，检查方法有exec、httpGet和tcpSocket，对一个容器只需设置其中一种方法即可</span></span><br><span class=\"line\"><span class=\"attr\">      exec:</span>       　　　　　　        <span class=\"comment\">#对Pod容器内检查方式设置为exec方式</span></span><br><span class=\"line\"><span class=\"attr\">        command:</span> <span class=\"string\">[string]</span>               <span class=\"comment\">#exec方式需要制定的命令或脚本</span></span><br><span class=\"line\"><span class=\"attr\">      httpGet:</span>        　　　　        <span class=\"comment\">#对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port</span></span><br><span class=\"line\"><span class=\"attr\">        path:</span> <span class=\"string\">string</span></span><br><span class=\"line\"><span class=\"attr\">        port:</span> <span class=\"string\">number</span></span><br><span class=\"line\"><span class=\"attr\">        host:</span> <span class=\"string\">string</span></span><br><span class=\"line\"><span class=\"attr\">        scheme:</span> <span class=\"string\">string</span></span><br><span class=\"line\"><span class=\"attr\">        HttpHeaders:</span></span><br><span class=\"line\"><span class=\"attr\">        - name:</span> <span class=\"string\">string</span></span><br><span class=\"line\"><span class=\"attr\">          value:</span> <span class=\"string\">string</span></span><br><span class=\"line\"><span class=\"attr\">      tcpSocket:</span>      　　　　　　<span class=\"comment\">#对Pod内个容器健康检查方式设置为tcpSocket方式</span></span><br><span class=\"line\"><span class=\"attr\">         port:</span> <span class=\"string\">number</span></span><br><span class=\"line\"><span class=\"attr\">       initialDelaySeconds:</span> <span class=\"number\">0</span>       <span class=\"comment\">#容器启动完成后首次探测的时间，单位为秒</span></span><br><span class=\"line\"><span class=\"attr\">       timeoutSeconds:</span> <span class=\"number\">0</span>    　　    <span class=\"comment\">#对容器健康检查探测等待响应的超时时间，单位秒，默认1秒</span></span><br><span class=\"line\"><span class=\"attr\">       periodSeconds:</span> <span class=\"number\">0</span>     　　    <span class=\"comment\">#对容器监控检查的定期探测时间设置，单位秒，默认10秒一次</span></span><br><span class=\"line\"><span class=\"attr\">       successThreshold:</span> <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"attr\">       failureThreshold:</span> <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"attr\">       securityContext:</span></span><br><span class=\"line\"><span class=\"attr\">         privileged:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    restartPolicy:</span> <span class=\"string\">[Always</span> <span class=\"string\">| Never | OnFailure] #Pod的重启策略，Always表示一旦不管以何种方式终止运行，kubelet都将重启，OnFailure表示只有Pod以非0退出码退出才重启，Nerver表示不再重启该Pod</span></span><br><span class=\"line\"><span class=\"string\"></span><span class=\"attr\">    nodeSelector:</span> <span class=\"string\">obeject</span>   　　    <span class=\"comment\">#设置NodeSelector表示将该Pod调度到包含这个label的node上，以key：value的格式指定</span></span><br><span class=\"line\"><span class=\"attr\">    imagePullSecrets:</span>     　　　　<span class=\"comment\">#Pull镜像时使用的secret名称，以key：secretkey格式指定</span></span><br><span class=\"line\"><span class=\"attr\">    - name:</span> <span class=\"string\">string</span></span><br><span class=\"line\"><span class=\"attr\">    hostNetwork:</span> <span class=\"literal\">false</span>      　　    <span class=\"comment\">#是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络</span></span><br><span class=\"line\"><span class=\"attr\">    volumes:</span>        　　　　　　    <span class=\"comment\">#在该pod上定义共享存储卷列表</span></span><br><span class=\"line\"><span class=\"attr\">    - name:</span> <span class=\"string\">string</span>     　　 　　    <span class=\"comment\">#共享存储卷名称 （volumes类型有很多种）</span></span><br><span class=\"line\"><span class=\"attr\">      emptyDir:</span> <span class=\"string\">&#123;&#125;</span>      　　　　    <span class=\"comment\">#类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值</span></span><br><span class=\"line\"><span class=\"attr\">      hostPath:</span> <span class=\"string\">string</span>      　　    <span class=\"comment\">#类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录</span></span><br><span class=\"line\"><span class=\"attr\">        path:</span> <span class=\"string\">string</span>      　　        <span class=\"comment\">#Pod所在宿主机的目录，将被用于同期中mount的目录</span></span><br><span class=\"line\"><span class=\"attr\">      secret:</span>       　　　　　　    <span class=\"comment\">#类型为secret的存储卷，挂载集群与定义的secre对象到容器内部</span></span><br><span class=\"line\"><span class=\"attr\">        scretname:</span> <span class=\"string\">string</span>  </span><br><span class=\"line\"><span class=\"attr\">        items:</span>     </span><br><span class=\"line\"><span class=\"attr\">        - key:</span> <span class=\"string\">string</span></span><br><span class=\"line\"><span class=\"attr\">          path:</span> <span class=\"string\">string</span></span><br><span class=\"line\"><span class=\"attr\">      configMap:</span>      　　　　            <span class=\"comment\">#类型为configMap的存储卷，挂载预定义的configMap对象到容器内部</span></span><br><span class=\"line\"><span class=\"attr\">        name:</span> <span class=\"string\">string</span></span><br><span class=\"line\"><span class=\"attr\">        items:</span></span><br><span class=\"line\"><span class=\"attr\">        - key:</span> <span class=\"string\">string</span></span><br><span class=\"line\"><span class=\"attr\">          path:</span> <span class=\"string\">string</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>Pod是在K8s集群中运行部署应用或服务的最小单元，它是可以支持多容器的。支持多个容器在一个Pod中共享网络地址和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。</p>","more":"<p>下面是Pod构建配置文件的完整模板：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span>        　　          <span class=\"comment\">#必选，版本号，例如v1,版本号必须可以用 kubectl api-versions 查询到 .</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span>       　　　　　　         <span class=\"comment\">#必选，Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span>       　　　　　　         <span class=\"comment\">#必选，元数据</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> <span class=\"string\">string</span>        　　          <span class=\"comment\">#必选，Pod名称</span></span><br><span class=\"line\"><span class=\"attr\">  namespace:</span> <span class=\"string\">string</span>     　　        <span class=\"comment\">#必选，Pod所属的命名空间,默认为\"default\"</span></span><br><span class=\"line\"><span class=\"attr\">  labels:</span>       　　　　　　          <span class=\"comment\">#自定义标签</span></span><br><span class=\"line\"><span class=\"attr\">    - name:</span> <span class=\"string\">string</span>      　          <span class=\"comment\">#自定义标签名字</span></span><br><span class=\"line\"><span class=\"attr\">  annotations:</span>        　　                 <span class=\"comment\">#自定义注释列表</span></span><br><span class=\"line\"><span class=\"attr\">    - name:</span> <span class=\"string\">string</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span>         　　　　　　　            <span class=\"comment\">#必选，Pod中容器的详细定义</span></span><br><span class=\"line\"><span class=\"attr\">  containers:</span>       　　　　            <span class=\"comment\">#必选，Pod中容器列表</span></span><br><span class=\"line\"><span class=\"attr\">  - name:</span> <span class=\"string\">string</span>      　　                <span class=\"comment\">#必选，容器名称,需符合RFC 1035规范</span></span><br><span class=\"line\"><span class=\"attr\">    image:</span> <span class=\"string\">string</span>     　　                <span class=\"comment\">#必选，容器的镜像名称</span></span><br><span class=\"line\"><span class=\"attr\">    imagePullPolicy:</span> <span class=\"string\">[</span> <span class=\"string\">Always|Never|IfNotPresent</span> <span class=\"string\">]</span>  <span class=\"comment\">#获取镜像的策略 Alawys表示下载镜像 IfnotPresent表示优先使用本地镜像,否则下载镜像，Nerver表示仅使用本地镜像</span></span><br><span class=\"line\"><span class=\"attr\">    command:</span> <span class=\"string\">[string]</span>     　　        <span class=\"comment\">#容器的启动命令列表，如不指定，使用打包时使用的启动命令</span></span><br><span class=\"line\"><span class=\"attr\">    args:</span> <span class=\"string\">[string]</span>      　　             <span class=\"comment\">#容器的启动命令参数列表</span></span><br><span class=\"line\"><span class=\"attr\">    workingDir:</span> <span class=\"string\">string</span>                     <span class=\"comment\">#容器的工作目录</span></span><br><span class=\"line\"><span class=\"attr\">    volumeMounts:</span>     　　　　        <span class=\"comment\">#挂载到容器内部的存储卷配置</span></span><br><span class=\"line\"><span class=\"attr\">    - name:</span> <span class=\"string\">string</span>      　　　        <span class=\"comment\">#引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名</span></span><br><span class=\"line\"><span class=\"attr\">      mountPath:</span> <span class=\"string\">string</span>                 <span class=\"comment\">#存储卷在容器内mount的绝对路径，应少于512字符</span></span><br><span class=\"line\"><span class=\"attr\">      readOnly:</span> <span class=\"string\">boolean</span>                 <span class=\"comment\">#是否为只读模式</span></span><br><span class=\"line\"><span class=\"attr\">    ports:</span>        　　　　　　        <span class=\"comment\">#需要暴露的端口库号列表</span></span><br><span class=\"line\"><span class=\"attr\">    - name:</span> <span class=\"string\">string</span>      　　　        <span class=\"comment\">#端口的名称</span></span><br><span class=\"line\"><span class=\"attr\">      containerPort:</span> <span class=\"string\">int</span>                <span class=\"comment\">#容器需要监听的端口号</span></span><br><span class=\"line\"><span class=\"attr\">      hostPort:</span> <span class=\"string\">int</span>     　　             <span class=\"comment\">#容器所在主机需要监听的端口号，默认与Container相同</span></span><br><span class=\"line\"><span class=\"attr\">      protocol:</span> <span class=\"string\">string</span>                  <span class=\"comment\">#端口协议，支持TCP和UDP，默认TCP</span></span><br><span class=\"line\"><span class=\"attr\">    env:</span>        　　　　　　            <span class=\"comment\">#容器运行前需设置的环境变量列表</span></span><br><span class=\"line\"><span class=\"attr\">    - name:</span> <span class=\"string\">string</span>      　　            <span class=\"comment\">#环境变量名称</span></span><br><span class=\"line\"><span class=\"attr\">      value:</span> <span class=\"string\">string</span>     　　            <span class=\"comment\">#环境变量的值</span></span><br><span class=\"line\"><span class=\"attr\">    resources:</span>        　　                <span class=\"comment\">#资源限制和请求的设置</span></span><br><span class=\"line\"><span class=\"attr\">      limits:</span>       　　　　            <span class=\"comment\">#资源限制的设置</span></span><br><span class=\"line\"><span class=\"attr\">        cpu:</span> <span class=\"string\">string</span>     　　            <span class=\"comment\">#Cpu的限制，单位为core数，将用于docker run --cpu-shares参数</span></span><br><span class=\"line\"><span class=\"attr\">        memory:</span> <span class=\"string\">string</span>                  <span class=\"comment\">#内存限制，单位可以为Mib/Gib，将用于docker run --memory参数</span></span><br><span class=\"line\"><span class=\"attr\">      requests:</span>       　　                <span class=\"comment\">#资源请求的设置</span></span><br><span class=\"line\"><span class=\"attr\">        cpu:</span> <span class=\"string\">string</span>     　　            <span class=\"comment\">#Cpu请求，容器启动的初始可用数量</span></span><br><span class=\"line\"><span class=\"attr\">        memory:</span> <span class=\"string\">string</span>                    <span class=\"comment\">#内存请求,容器启动的初始可用数量</span></span><br><span class=\"line\"><span class=\"attr\">    livenessProbe:</span>      　　            <span class=\"comment\">#对Pod内各容器健康检查的设置，当探测无响应几次后将自动重启该容器，检查方法有exec、httpGet和tcpSocket，对一个容器只需设置其中一种方法即可</span></span><br><span class=\"line\"><span class=\"attr\">      exec:</span>       　　　　　　        <span class=\"comment\">#对Pod容器内检查方式设置为exec方式</span></span><br><span class=\"line\"><span class=\"attr\">        command:</span> <span class=\"string\">[string]</span>               <span class=\"comment\">#exec方式需要制定的命令或脚本</span></span><br><span class=\"line\"><span class=\"attr\">      httpGet:</span>        　　　　        <span class=\"comment\">#对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port</span></span><br><span class=\"line\"><span class=\"attr\">        path:</span> <span class=\"string\">string</span></span><br><span class=\"line\"><span class=\"attr\">        port:</span> <span class=\"string\">number</span></span><br><span class=\"line\"><span class=\"attr\">        host:</span> <span class=\"string\">string</span></span><br><span class=\"line\"><span class=\"attr\">        scheme:</span> <span class=\"string\">string</span></span><br><span class=\"line\"><span class=\"attr\">        HttpHeaders:</span></span><br><span class=\"line\"><span class=\"attr\">        - name:</span> <span class=\"string\">string</span></span><br><span class=\"line\"><span class=\"attr\">          value:</span> <span class=\"string\">string</span></span><br><span class=\"line\"><span class=\"attr\">      tcpSocket:</span>      　　　　　　<span class=\"comment\">#对Pod内个容器健康检查方式设置为tcpSocket方式</span></span><br><span class=\"line\"><span class=\"attr\">         port:</span> <span class=\"string\">number</span></span><br><span class=\"line\"><span class=\"attr\">       initialDelaySeconds:</span> <span class=\"number\">0</span>       <span class=\"comment\">#容器启动完成后首次探测的时间，单位为秒</span></span><br><span class=\"line\"><span class=\"attr\">       timeoutSeconds:</span> <span class=\"number\">0</span>    　　    <span class=\"comment\">#对容器健康检查探测等待响应的超时时间，单位秒，默认1秒</span></span><br><span class=\"line\"><span class=\"attr\">       periodSeconds:</span> <span class=\"number\">0</span>     　　    <span class=\"comment\">#对容器监控检查的定期探测时间设置，单位秒，默认10秒一次</span></span><br><span class=\"line\"><span class=\"attr\">       successThreshold:</span> <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"attr\">       failureThreshold:</span> <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"attr\">       securityContext:</span></span><br><span class=\"line\"><span class=\"attr\">         privileged:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    restartPolicy:</span> <span class=\"string\">[Always</span> <span class=\"string\">| Never | OnFailure] #Pod的重启策略，Always表示一旦不管以何种方式终止运行，kubelet都将重启，OnFailure表示只有Pod以非0退出码退出才重启，Nerver表示不再重启该Pod</span></span><br><span class=\"line\"><span class=\"string\"></span><span class=\"attr\">    nodeSelector:</span> <span class=\"string\">obeject</span>   　　    <span class=\"comment\">#设置NodeSelector表示将该Pod调度到包含这个label的node上，以key：value的格式指定</span></span><br><span class=\"line\"><span class=\"attr\">    imagePullSecrets:</span>     　　　　<span class=\"comment\">#Pull镜像时使用的secret名称，以key：secretkey格式指定</span></span><br><span class=\"line\"><span class=\"attr\">    - name:</span> <span class=\"string\">string</span></span><br><span class=\"line\"><span class=\"attr\">    hostNetwork:</span> <span class=\"literal\">false</span>      　　    <span class=\"comment\">#是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络</span></span><br><span class=\"line\"><span class=\"attr\">    volumes:</span>        　　　　　　    <span class=\"comment\">#在该pod上定义共享存储卷列表</span></span><br><span class=\"line\"><span class=\"attr\">    - name:</span> <span class=\"string\">string</span>     　　 　　    <span class=\"comment\">#共享存储卷名称 （volumes类型有很多种）</span></span><br><span class=\"line\"><span class=\"attr\">      emptyDir:</span> <span class=\"string\">&#123;&#125;</span>      　　　　    <span class=\"comment\">#类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值</span></span><br><span class=\"line\"><span class=\"attr\">      hostPath:</span> <span class=\"string\">string</span>      　　    <span class=\"comment\">#类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录</span></span><br><span class=\"line\"><span class=\"attr\">        path:</span> <span class=\"string\">string</span>      　　        <span class=\"comment\">#Pod所在宿主机的目录，将被用于同期中mount的目录</span></span><br><span class=\"line\"><span class=\"attr\">      secret:</span>       　　　　　　    <span class=\"comment\">#类型为secret的存储卷，挂载集群与定义的secre对象到容器内部</span></span><br><span class=\"line\"><span class=\"attr\">        scretname:</span> <span class=\"string\">string</span>  </span><br><span class=\"line\"><span class=\"attr\">        items:</span>     </span><br><span class=\"line\"><span class=\"attr\">        - key:</span> <span class=\"string\">string</span></span><br><span class=\"line\"><span class=\"attr\">          path:</span> <span class=\"string\">string</span></span><br><span class=\"line\"><span class=\"attr\">      configMap:</span>      　　　　            <span class=\"comment\">#类型为configMap的存储卷，挂载预定义的configMap对象到容器内部</span></span><br><span class=\"line\"><span class=\"attr\">        name:</span> <span class=\"string\">string</span></span><br><span class=\"line\"><span class=\"attr\">        items:</span></span><br><span class=\"line\"><span class=\"attr\">        - key:</span> <span class=\"string\">string</span></span><br><span class=\"line\"><span class=\"attr\">          path:</span> <span class=\"string\">string</span></span><br></pre></td></tr></table></figure>"},{"title":"k8s 存储","_content":"# K8s存储概述\n## Persistent volumes(PV)\n下面是NFS的PV配置：\n```yaml\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: pv-1\n  labels:\n    release: stable\n    capacity: 100Gi\nspec:\n  capacity:\n    storage: 100Gi\n  volumeMode: Filesystem\n  accessMode:\n  - ReadWriteOnece\n  - ReadOnlyMany\n  storageClassName: normal\n  persistentVolumeReclaimPolicy: Recycle\n  nfs:\n    path: /tmp\n    server: 127.17.0.8\n```\n\n字段解析：\n* capacity: 指定这个PV的总容量。\n* volumeMode: 可选值有\"Filesystem\"和\"Block\"，默认是\"Filesystem\"。\n* accessMode: 可选值有\"ReadOnlyMany\",\"ReadWriteOnce\",\"ReadWriteMany\"。Once指的是同时只能被一个节点操作，Many指的是同时可被多个节点操作。\n* persistentVolumeReclaimPolicy: 指定一个PVC被删除时当前PV需要执行的操作。可选值有\"Retain\",\"Delete\",\"Recycle\"。不同卷类型的PV可选的值稍微有些不同，比如只有NFS与HostPath模式提供\"Recycle\"策略。\n* storageClassName: 这个字段是可选值，字符串类型。只有带有相同storageClassName的PVC才能索取这个PV，并且需要注意的是若当前PV没有设置storageClassName字段值，则只有那些同样没有设置storageClassName字段值的PVC能索取这个PV。\n* 卷类型：卷类型可选值有很多，将会在后续注意说明。设置的方式是把卷类型名称（如nfs）作为spec下的一个key，对应的值类型是对象，美中卷类型对象都有不同的字段。\n\n## Persistent volume claims(PVC)\n生成PV后还不能立刻应用到容器中，需要创建一个PVC对象来配置对这个PV的索取方式，例子如下：\n```yaml\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: storage-claim\nspec:\n  accessMode:\n  - ReadWriteOnce\n  resources:\n    requests:\n      storage: 80Gi\n  storageClassName: normal\n  selector:\n    matchLabels:\n      release: stable\n    matchExpressions:\n    - {key: capacity, operator: In, values: [80Gi, 1000Gi]}\n```\n\nPVC匹配PV的方式并不是使用name指定，而是通过storageClassName, capacity, selector字段进行筛选匹配。PVC与PV都是命名空间域下的资源，PVC只能索取相同命名空间下的PV。\n\n字段解析：\n* accessMode: TODO。\n* resources: 指定申请PV的空间大小，上面指定了80Gi，若是向100Gi的PV索取则剩下的20Gi将会浪费掉。\n* storageClassName: 上一节提到过，这个PVC只能索取带有相同storageClassName的PV。\n* selector: 相当于PV的过滤器，matchLabels指定只能索取带有这些标签的PV。matchExpressions可以指定筛选表达式，例子中筛选容量为80Gi或100Gi的PV。假设实际中还存在200Gi或500Gi的PV，而这个只需要80Gi的PVC去申请了这些PV将会是极大的资源浪费，通过这个selector的筛选可以禁止这个PVC索取这些大容量的PV。但即使没有这个selector的限制，K8s还是会索取现有容量最小且能满足PVC申请容量的PV。\n\n生成了PVC后，创建部署时就可以通过PVC的“名称”来挂载卷到容器中，例子如下：\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: the-pod\nspec:\n  containers:\n  - name: the-container\n    image: some-image\n    volumeMounts:\n    - mountPath: /mnt/data\n      name: persistent-volume\n  volumes:\n  - name: persistent-volume\n    persistentVolumeClaim:\n      claimName: storage-claim\n```\n\nPVC的卷就会挂载到容器中的 /mnt/data 目录下。\n\n## 块存储\nKubernetes v1.9 新增了 Alpha 版的 Raw Block Volume，使用前需要为 kube-apiserver、kube-controller-manager 和 kubelet 开启 BlockVolume 特性，即添加命令行选项 --feature-gates=BlockVolume=true。\n\n块存储为应用程序提供了直接对底层存储设备进行操作的方式而不用经过文件系统抽象层接口，这样可以达到更高的存储效率。\n\n支持块存储的 PV 插件包括：\n* Local Volume\n* fc\n* iSCSI\n* Ceph RBD\n* AWS EBS\n* GCE PD\n* AzureDisk\n* Cinder\n\n下面给出块存储的例子：\n\n```yaml\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: block-pv\nspec:\n  capacity:\n    storage: 10Gi\n  accessModes:\n  - ReadWriteOnece\n  volumeMode: Block # 块存储\n  persistentVolumeReclaimPolicy: Retain\n  fc:\n    targetWWNs: [\"50060e801049cfd1\"]\n    lun: 0\n    readOnly: false\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: block-pvc\nspec:\n  accessMode:\n  - ReadWriteOnce\n  volumeMode: Block # 块存储\n  resources:\n    requests:\n      storage: 10Gi\n```\n\n块存储在机器上应该是以“设备”形式呈现，不同于文件系统的目录形式。部署应用时需要指定块设备同步到容器中 /dev 目录下的一个设备文件。\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-with-block-volume\nspec:\n  containers:\n  - name: fc-container\n    image: fedora:26\n    command: [\"/bin/sh\", \"-c\"]\n    args: [\"tail -f /dev/null\"]\n    volumeDevices:  # 块存储以设备文件形式存放到容器中的 /dev/xvda\n    - name: data\n      devicePath: /dev/xvda\n  volumes:\n  - name: data\n    persistentVolumeClaim:\n      claimName: block-pvc\n```\n\n# 各种卷类型\nK8s提供的卷类型非常丰富，包括（[详情参考官网](https://kubernetes.io/docs/concepts/storage/)）：\n* awsElasticBlockStore\n* azureDisk\n* azureFile\n* cephfs\n* cinder\n* configMap\n* csi\n* downwardAPI\n* emptyDir\n* fc (fibre channel)\n* flexVolume\n* flocker\n* gcePersistentDisk\n* gitRepo (deprecated)\n* glusterfs\n* hostPath\n* iscsi\n* local\n* nfs\n* persistentVolumeClaim\n* projected\n* portworxVolume\n* quobyte\n* rbd\n* scaleIO\n* secret\n* storageos\n* vsphereVolume\n\n接下来将详细介绍部分存储类型的使用。\n\n## emptyDir\n用于同一个Pod下不同容器之间共用的卷，当Pod被销毁时都会删除旧卷，这意味着emptyDir卷不能持久化Pod的信息，只用于Pod中不同容器之间以文件系统的方式通信。\n\nemptyDir的存储媒介可以选择：内存或磁盘。使用内存作为存储媒介时会以tmpfs类型的卷挂载到容器目录下，该目录下的数据都会保存在宿主机的内存中。使用磁盘作为存储媒介时会将会挂载宿主机 \"/var/lib/kubelet/pods/**{podUid}**/volumes/kubernetes.io~empty-dir/**{volumeName}**\" 目录到容器中。\n\n下面给出emptyDir的例子：\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  labels:\n    name: test-emptypath\n  name: test-emptypath\nspec:\n  containers:\n    - name: emptydir-producer\n      image: busybox\n      volumeMounts:\n       - name: log-storage\n         mountPath: /home/log/\n      command:\n      - /bin/sh\n      - -c\n      - \"while [ true ]; do echo $(date) >> /home/log/test.log; sleep 5; done\"\n    - name: emptydir-consumer\n      image: busybox\n      volumeMounts:\n       - name: log-storage\n         mountPath: /home/log/\n      command:\n      - tail\n      - -f\n      - /home/log/test.log\n  volumes:\n  - name: log-storage\n    emptyDir:\n      # medium: Memory    # 卷媒介采用内存存储，不指定这个属性则表示采用磁盘作为存储媒介\n      sizeLimit: 300Mi  # 卷容量为300Mb\n```\n\n这个Pod中包含了两个容器，第一个容器用于产生日志输出到emptydir卷目录(/home/log)下的test.log文件中，另一个容器负责读取emptydir卷目录下的test.log文件内容，采用磁盘作为卷存储媒介，限制卷容量为300Mb。\n\n先进入第一个容器中确认容器中的日志已输出/home/log/test.log文件中。\n\n```sh\n$ kubectl exec test-emptypath -c emptydir-producer cat /home/log/test.log\nWed Jan 1 15:21:21 UTC 2020\nWed Jan 1 15:21:26 UTC 2020\nWed Jan 1 15:21:31 UTC 2020\nWed Jan 1 15:21:36 UTC 2020\nWed Jan 1 15:21:41 UTC 2020\n# 确认emptydir挂载到/home/log目录下，并且是以磁盘作为存储媒介\n$ kubectl exec test-emptypath -c emptydir-producer df\nFilesystem           1K-blocks      Used Available Use% Mounted on\noverlay              478375712  69699844 408675868  15% /\ntmpfs                    65536         0     65536   0% /dev\ntmpfs                 32695936         0  32695936   0% /sys/fs/cgroup\n/dev/mapper/centos-root 478375712  69699812 408675900  15% /dev/termination-log\n/dev/mapper/centos-root 478375712  69699812 408675900  15% /home/log\n/dev/mapper/centos-root 478375712  69699812 408675900  15% /etc/resolv.conf\n/dev/mapper/centos-root 478375712  69699812 408675900  15% /etc/hostname\n/dev/mapper/centos-root 478375712  69699812 408675900  15% /etc/hosts\nshm                      65536         0     65536   0% /dev/shm\ntmpfs                 32695936        12  32695924   0% /var/run/secrets/kubernetes.io/serviceaccount\ntmpfs                 32695936         0  32695936   0% /proc/acpi\ntmpfs                    65536         0     65536   0% /proc/kcore\ntmpfs                    65536         0     65536   0% /proc/keys\ntmpfs                    65536         0     65536   0% /proc/timer_list\ntmpfs                    65536         0     65536   0% /proc/timer_stats\ntmpfs                    65536         0     65536   0% /proc/sched_debug\ntmpfs                 32695936         0  32695936   0% /proc/scsi\ntmpfs                 32695936         0  32695936   0% /sys/firmware\n```\n\n然后查看第二个容器的输出日志确实得到同样的内容。\n\n```sh\n$ kubectl logs -f test-emptypath emptydir-consumer\nWed Jan 1 15:21:21 UTC 2020\nWed Jan 1 15:21:26 UTC 2020\nWed Jan 1 15:21:31 UTC 2020\nWed Jan 1 15:21:36 UTC 2020\nWed Jan 1 15:21:41 UTC 2020\n```\n\n接着我们尝试在宿主机查看这个emptydir卷对应的目录文件。\n```sh\n\n```\n\n## hostPath\n## local\n## secret\n## configMap\n## persistentVolumeClaim\n一个persistentVolumeClaim卷需要绑定一个PersistentVolume后才能被Pod挂载。PersistentVolumes提供存储的抽象概念，它记录复杂的存储细节（使用的存储驱动及相关配置信息）。这样一来用户只需直接与persistentVolumeClaim卷打交道，无需了解后面绑定PersistentVolumes的存储细节。\n\n上面已对PVC做过详细介绍，这里不在阐述。\n## glusterFS\n\n## cephRBD\nCeph RBD是基于Ceph的Block类型存储模式，优点是应用直接调用底层存储设备能力，不需要经过文件系统抽象接口，存取效率更高。缺点是只能挂载ReadWriteOnce模式的PVC，不适合做多应用文件共享。\n\n## cephFS\n## projected","source":"_drafts/k8s-storage.md","raw":"---\ntitle: \"k8s 存储\"\ncategory: k8s\n---\n# K8s存储概述\n## Persistent volumes(PV)\n下面是NFS的PV配置：\n```yaml\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: pv-1\n  labels:\n    release: stable\n    capacity: 100Gi\nspec:\n  capacity:\n    storage: 100Gi\n  volumeMode: Filesystem\n  accessMode:\n  - ReadWriteOnece\n  - ReadOnlyMany\n  storageClassName: normal\n  persistentVolumeReclaimPolicy: Recycle\n  nfs:\n    path: /tmp\n    server: 127.17.0.8\n```\n\n字段解析：\n* capacity: 指定这个PV的总容量。\n* volumeMode: 可选值有\"Filesystem\"和\"Block\"，默认是\"Filesystem\"。\n* accessMode: 可选值有\"ReadOnlyMany\",\"ReadWriteOnce\",\"ReadWriteMany\"。Once指的是同时只能被一个节点操作，Many指的是同时可被多个节点操作。\n* persistentVolumeReclaimPolicy: 指定一个PVC被删除时当前PV需要执行的操作。可选值有\"Retain\",\"Delete\",\"Recycle\"。不同卷类型的PV可选的值稍微有些不同，比如只有NFS与HostPath模式提供\"Recycle\"策略。\n* storageClassName: 这个字段是可选值，字符串类型。只有带有相同storageClassName的PVC才能索取这个PV，并且需要注意的是若当前PV没有设置storageClassName字段值，则只有那些同样没有设置storageClassName字段值的PVC能索取这个PV。\n* 卷类型：卷类型可选值有很多，将会在后续注意说明。设置的方式是把卷类型名称（如nfs）作为spec下的一个key，对应的值类型是对象，美中卷类型对象都有不同的字段。\n\n## Persistent volume claims(PVC)\n生成PV后还不能立刻应用到容器中，需要创建一个PVC对象来配置对这个PV的索取方式，例子如下：\n```yaml\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: storage-claim\nspec:\n  accessMode:\n  - ReadWriteOnce\n  resources:\n    requests:\n      storage: 80Gi\n  storageClassName: normal\n  selector:\n    matchLabels:\n      release: stable\n    matchExpressions:\n    - {key: capacity, operator: In, values: [80Gi, 1000Gi]}\n```\n\nPVC匹配PV的方式并不是使用name指定，而是通过storageClassName, capacity, selector字段进行筛选匹配。PVC与PV都是命名空间域下的资源，PVC只能索取相同命名空间下的PV。\n\n字段解析：\n* accessMode: TODO。\n* resources: 指定申请PV的空间大小，上面指定了80Gi，若是向100Gi的PV索取则剩下的20Gi将会浪费掉。\n* storageClassName: 上一节提到过，这个PVC只能索取带有相同storageClassName的PV。\n* selector: 相当于PV的过滤器，matchLabels指定只能索取带有这些标签的PV。matchExpressions可以指定筛选表达式，例子中筛选容量为80Gi或100Gi的PV。假设实际中还存在200Gi或500Gi的PV，而这个只需要80Gi的PVC去申请了这些PV将会是极大的资源浪费，通过这个selector的筛选可以禁止这个PVC索取这些大容量的PV。但即使没有这个selector的限制，K8s还是会索取现有容量最小且能满足PVC申请容量的PV。\n\n生成了PVC后，创建部署时就可以通过PVC的“名称”来挂载卷到容器中，例子如下：\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: the-pod\nspec:\n  containers:\n  - name: the-container\n    image: some-image\n    volumeMounts:\n    - mountPath: /mnt/data\n      name: persistent-volume\n  volumes:\n  - name: persistent-volume\n    persistentVolumeClaim:\n      claimName: storage-claim\n```\n\nPVC的卷就会挂载到容器中的 /mnt/data 目录下。\n\n## 块存储\nKubernetes v1.9 新增了 Alpha 版的 Raw Block Volume，使用前需要为 kube-apiserver、kube-controller-manager 和 kubelet 开启 BlockVolume 特性，即添加命令行选项 --feature-gates=BlockVolume=true。\n\n块存储为应用程序提供了直接对底层存储设备进行操作的方式而不用经过文件系统抽象层接口，这样可以达到更高的存储效率。\n\n支持块存储的 PV 插件包括：\n* Local Volume\n* fc\n* iSCSI\n* Ceph RBD\n* AWS EBS\n* GCE PD\n* AzureDisk\n* Cinder\n\n下面给出块存储的例子：\n\n```yaml\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: block-pv\nspec:\n  capacity:\n    storage: 10Gi\n  accessModes:\n  - ReadWriteOnece\n  volumeMode: Block # 块存储\n  persistentVolumeReclaimPolicy: Retain\n  fc:\n    targetWWNs: [\"50060e801049cfd1\"]\n    lun: 0\n    readOnly: false\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: block-pvc\nspec:\n  accessMode:\n  - ReadWriteOnce\n  volumeMode: Block # 块存储\n  resources:\n    requests:\n      storage: 10Gi\n```\n\n块存储在机器上应该是以“设备”形式呈现，不同于文件系统的目录形式。部署应用时需要指定块设备同步到容器中 /dev 目录下的一个设备文件。\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-with-block-volume\nspec:\n  containers:\n  - name: fc-container\n    image: fedora:26\n    command: [\"/bin/sh\", \"-c\"]\n    args: [\"tail -f /dev/null\"]\n    volumeDevices:  # 块存储以设备文件形式存放到容器中的 /dev/xvda\n    - name: data\n      devicePath: /dev/xvda\n  volumes:\n  - name: data\n    persistentVolumeClaim:\n      claimName: block-pvc\n```\n\n# 各种卷类型\nK8s提供的卷类型非常丰富，包括（[详情参考官网](https://kubernetes.io/docs/concepts/storage/)）：\n* awsElasticBlockStore\n* azureDisk\n* azureFile\n* cephfs\n* cinder\n* configMap\n* csi\n* downwardAPI\n* emptyDir\n* fc (fibre channel)\n* flexVolume\n* flocker\n* gcePersistentDisk\n* gitRepo (deprecated)\n* glusterfs\n* hostPath\n* iscsi\n* local\n* nfs\n* persistentVolumeClaim\n* projected\n* portworxVolume\n* quobyte\n* rbd\n* scaleIO\n* secret\n* storageos\n* vsphereVolume\n\n接下来将详细介绍部分存储类型的使用。\n\n## emptyDir\n用于同一个Pod下不同容器之间共用的卷，当Pod被销毁时都会删除旧卷，这意味着emptyDir卷不能持久化Pod的信息，只用于Pod中不同容器之间以文件系统的方式通信。\n\nemptyDir的存储媒介可以选择：内存或磁盘。使用内存作为存储媒介时会以tmpfs类型的卷挂载到容器目录下，该目录下的数据都会保存在宿主机的内存中。使用磁盘作为存储媒介时会将会挂载宿主机 \"/var/lib/kubelet/pods/**{podUid}**/volumes/kubernetes.io~empty-dir/**{volumeName}**\" 目录到容器中。\n\n下面给出emptyDir的例子：\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  labels:\n    name: test-emptypath\n  name: test-emptypath\nspec:\n  containers:\n    - name: emptydir-producer\n      image: busybox\n      volumeMounts:\n       - name: log-storage\n         mountPath: /home/log/\n      command:\n      - /bin/sh\n      - -c\n      - \"while [ true ]; do echo $(date) >> /home/log/test.log; sleep 5; done\"\n    - name: emptydir-consumer\n      image: busybox\n      volumeMounts:\n       - name: log-storage\n         mountPath: /home/log/\n      command:\n      - tail\n      - -f\n      - /home/log/test.log\n  volumes:\n  - name: log-storage\n    emptyDir:\n      # medium: Memory    # 卷媒介采用内存存储，不指定这个属性则表示采用磁盘作为存储媒介\n      sizeLimit: 300Mi  # 卷容量为300Mb\n```\n\n这个Pod中包含了两个容器，第一个容器用于产生日志输出到emptydir卷目录(/home/log)下的test.log文件中，另一个容器负责读取emptydir卷目录下的test.log文件内容，采用磁盘作为卷存储媒介，限制卷容量为300Mb。\n\n先进入第一个容器中确认容器中的日志已输出/home/log/test.log文件中。\n\n```sh\n$ kubectl exec test-emptypath -c emptydir-producer cat /home/log/test.log\nWed Jan 1 15:21:21 UTC 2020\nWed Jan 1 15:21:26 UTC 2020\nWed Jan 1 15:21:31 UTC 2020\nWed Jan 1 15:21:36 UTC 2020\nWed Jan 1 15:21:41 UTC 2020\n# 确认emptydir挂载到/home/log目录下，并且是以磁盘作为存储媒介\n$ kubectl exec test-emptypath -c emptydir-producer df\nFilesystem           1K-blocks      Used Available Use% Mounted on\noverlay              478375712  69699844 408675868  15% /\ntmpfs                    65536         0     65536   0% /dev\ntmpfs                 32695936         0  32695936   0% /sys/fs/cgroup\n/dev/mapper/centos-root 478375712  69699812 408675900  15% /dev/termination-log\n/dev/mapper/centos-root 478375712  69699812 408675900  15% /home/log\n/dev/mapper/centos-root 478375712  69699812 408675900  15% /etc/resolv.conf\n/dev/mapper/centos-root 478375712  69699812 408675900  15% /etc/hostname\n/dev/mapper/centos-root 478375712  69699812 408675900  15% /etc/hosts\nshm                      65536         0     65536   0% /dev/shm\ntmpfs                 32695936        12  32695924   0% /var/run/secrets/kubernetes.io/serviceaccount\ntmpfs                 32695936         0  32695936   0% /proc/acpi\ntmpfs                    65536         0     65536   0% /proc/kcore\ntmpfs                    65536         0     65536   0% /proc/keys\ntmpfs                    65536         0     65536   0% /proc/timer_list\ntmpfs                    65536         0     65536   0% /proc/timer_stats\ntmpfs                    65536         0     65536   0% /proc/sched_debug\ntmpfs                 32695936         0  32695936   0% /proc/scsi\ntmpfs                 32695936         0  32695936   0% /sys/firmware\n```\n\n然后查看第二个容器的输出日志确实得到同样的内容。\n\n```sh\n$ kubectl logs -f test-emptypath emptydir-consumer\nWed Jan 1 15:21:21 UTC 2020\nWed Jan 1 15:21:26 UTC 2020\nWed Jan 1 15:21:31 UTC 2020\nWed Jan 1 15:21:36 UTC 2020\nWed Jan 1 15:21:41 UTC 2020\n```\n\n接着我们尝试在宿主机查看这个emptydir卷对应的目录文件。\n```sh\n\n```\n\n## hostPath\n## local\n## secret\n## configMap\n## persistentVolumeClaim\n一个persistentVolumeClaim卷需要绑定一个PersistentVolume后才能被Pod挂载。PersistentVolumes提供存储的抽象概念，它记录复杂的存储细节（使用的存储驱动及相关配置信息）。这样一来用户只需直接与persistentVolumeClaim卷打交道，无需了解后面绑定PersistentVolumes的存储细节。\n\n上面已对PVC做过详细介绍，这里不在阐述。\n## glusterFS\n\n## cephRBD\nCeph RBD是基于Ceph的Block类型存储模式，优点是应用直接调用底层存储设备能力，不需要经过文件系统抽象接口，存取效率更高。缺点是只能挂载ReadWriteOnce模式的PVC，不适合做多应用文件共享。\n\n## cephFS\n## projected","slug":"k8s-storage","published":0,"date":"2020-01-16T17:23:25.488Z","updated":"2020-01-07T05:36:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck679mts1000jlbmdq4ea9bxl","content":"<h1 id=\"K8s存储概述\"><a href=\"#K8s存储概述\" class=\"headerlink\" title=\"K8s存储概述\"></a>K8s存储概述</h1><h2 id=\"Persistent-volumes-PV\"><a href=\"#Persistent-volumes-PV\" class=\"headerlink\" title=\"Persistent volumes(PV)\"></a>Persistent volumes(PV)</h2><p>下面是NFS的PV配置：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolume</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> <span class=\"string\">pv-1</span></span><br><span class=\"line\"><span class=\"attr\">  labels:</span></span><br><span class=\"line\"><span class=\"attr\">    release:</span> <span class=\"string\">stable</span></span><br><span class=\"line\"><span class=\"attr\">    capacity:</span> <span class=\"number\">100</span><span class=\"string\">Gi</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\"><span class=\"attr\">  capacity:</span></span><br><span class=\"line\"><span class=\"attr\">    storage:</span> <span class=\"number\">100</span><span class=\"string\">Gi</span></span><br><span class=\"line\"><span class=\"attr\">  volumeMode:</span> <span class=\"string\">Filesystem</span></span><br><span class=\"line\"><span class=\"attr\">  accessMode:</span></span><br><span class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">ReadWriteOnece</span></span><br><span class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">ReadOnlyMany</span></span><br><span class=\"line\"><span class=\"attr\">  storageClassName:</span> <span class=\"string\">normal</span></span><br><span class=\"line\"><span class=\"attr\">  persistentVolumeReclaimPolicy:</span> <span class=\"string\">Recycle</span></span><br><span class=\"line\"><span class=\"attr\">  nfs:</span></span><br><span class=\"line\"><span class=\"attr\">    path:</span> <span class=\"string\">/tmp</span></span><br><span class=\"line\"><span class=\"attr\">    server:</span> <span class=\"number\">127.17</span><span class=\"number\">.0</span><span class=\"number\">.8</span></span><br></pre></td></tr></table></figure>\n\n<p>字段解析：</p>\n<ul>\n<li>capacity: 指定这个PV的总容量。</li>\n<li>volumeMode: 可选值有”Filesystem”和”Block”，默认是”Filesystem”。</li>\n<li>accessMode: 可选值有”ReadOnlyMany”,”ReadWriteOnce”,”ReadWriteMany”。Once指的是同时只能被一个节点操作，Many指的是同时可被多个节点操作。</li>\n<li>persistentVolumeReclaimPolicy: 指定一个PVC被删除时当前PV需要执行的操作。可选值有”Retain”,”Delete”,”Recycle”。不同卷类型的PV可选的值稍微有些不同，比如只有NFS与HostPath模式提供”Recycle”策略。</li>\n<li>storageClassName: 这个字段是可选值，字符串类型。只有带有相同storageClassName的PVC才能索取这个PV，并且需要注意的是若当前PV没有设置storageClassName字段值，则只有那些同样没有设置storageClassName字段值的PVC能索取这个PV。</li>\n<li>卷类型：卷类型可选值有很多，将会在后续注意说明。设置的方式是把卷类型名称（如nfs）作为spec下的一个key，对应的值类型是对象，美中卷类型对象都有不同的字段。</li>\n</ul>\n<h2 id=\"Persistent-volume-claims-PVC\"><a href=\"#Persistent-volume-claims-PVC\" class=\"headerlink\" title=\"Persistent volume claims(PVC)\"></a>Persistent volume claims(PVC)</h2><p>生成PV后还不能立刻应用到容器中，需要创建一个PVC对象来配置对这个PV的索取方式，例子如下：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolumeClaim</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> <span class=\"string\">storage-claim</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\"><span class=\"attr\">  accessMode:</span></span><br><span class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\"><span class=\"attr\">  resources:</span></span><br><span class=\"line\"><span class=\"attr\">    requests:</span></span><br><span class=\"line\"><span class=\"attr\">      storage:</span> <span class=\"number\">80</span><span class=\"string\">Gi</span></span><br><span class=\"line\"><span class=\"attr\">  storageClassName:</span> <span class=\"string\">normal</span></span><br><span class=\"line\"><span class=\"attr\">  selector:</span></span><br><span class=\"line\"><span class=\"attr\">    matchLabels:</span></span><br><span class=\"line\"><span class=\"attr\">      release:</span> <span class=\"string\">stable</span></span><br><span class=\"line\"><span class=\"attr\">    matchExpressions:</span></span><br><span class=\"line\"><span class=\"bullet\">    -</span> <span class=\"string\">&#123;key:</span> <span class=\"string\">capacity,</span> <span class=\"attr\">operator:</span> <span class=\"string\">In,</span> <span class=\"attr\">values:</span> <span class=\"string\">[80Gi,</span> <span class=\"number\">1000</span><span class=\"string\">Gi]&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>PVC匹配PV的方式并不是使用name指定，而是通过storageClassName, capacity, selector字段进行筛选匹配。PVC与PV都是命名空间域下的资源，PVC只能索取相同命名空间下的PV。</p>\n<p>字段解析：</p>\n<ul>\n<li>accessMode: TODO。</li>\n<li>resources: 指定申请PV的空间大小，上面指定了80Gi，若是向100Gi的PV索取则剩下的20Gi将会浪费掉。</li>\n<li>storageClassName: 上一节提到过，这个PVC只能索取带有相同storageClassName的PV。</li>\n<li>selector: 相当于PV的过滤器，matchLabels指定只能索取带有这些标签的PV。matchExpressions可以指定筛选表达式，例子中筛选容量为80Gi或100Gi的PV。假设实际中还存在200Gi或500Gi的PV，而这个只需要80Gi的PVC去申请了这些PV将会是极大的资源浪费，通过这个selector的筛选可以禁止这个PVC索取这些大容量的PV。但即使没有这个selector的限制，K8s还是会索取现有容量最小且能满足PVC申请容量的PV。</li>\n</ul>\n<p>生成了PVC后，创建部署时就可以通过PVC的“名称”来挂载卷到容器中，例子如下：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> <span class=\"string\">the-pod</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\"><span class=\"attr\">  containers:</span></span><br><span class=\"line\"><span class=\"attr\">  - name:</span> <span class=\"string\">the-container</span></span><br><span class=\"line\"><span class=\"attr\">    image:</span> <span class=\"string\">some-image</span></span><br><span class=\"line\"><span class=\"attr\">    volumeMounts:</span></span><br><span class=\"line\"><span class=\"attr\">    - mountPath:</span> <span class=\"string\">/mnt/data</span></span><br><span class=\"line\"><span class=\"attr\">      name:</span> <span class=\"string\">persistent-volume</span></span><br><span class=\"line\"><span class=\"attr\">  volumes:</span></span><br><span class=\"line\"><span class=\"attr\">  - name:</span> <span class=\"string\">persistent-volume</span></span><br><span class=\"line\"><span class=\"attr\">    persistentVolumeClaim:</span></span><br><span class=\"line\"><span class=\"attr\">      claimName:</span> <span class=\"string\">storage-claim</span></span><br></pre></td></tr></table></figure>\n\n<p>PVC的卷就会挂载到容器中的 /mnt/data 目录下。</p>\n<h2 id=\"块存储\"><a href=\"#块存储\" class=\"headerlink\" title=\"块存储\"></a>块存储</h2><p>Kubernetes v1.9 新增了 Alpha 版的 Raw Block Volume，使用前需要为 kube-apiserver、kube-controller-manager 和 kubelet 开启 BlockVolume 特性，即添加命令行选项 –feature-gates=BlockVolume=true。</p>\n<p>块存储为应用程序提供了直接对底层存储设备进行操作的方式而不用经过文件系统抽象层接口，这样可以达到更高的存储效率。</p>\n<p>支持块存储的 PV 插件包括：</p>\n<ul>\n<li>Local Volume</li>\n<li>fc</li>\n<li>iSCSI</li>\n<li>Ceph RBD</li>\n<li>AWS EBS</li>\n<li>GCE PD</li>\n<li>AzureDisk</li>\n<li>Cinder</li>\n</ul>\n<p>下面给出块存储的例子：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolume</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> <span class=\"string\">block-pv</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\"><span class=\"attr\">  capacity:</span></span><br><span class=\"line\"><span class=\"attr\">    storage:</span> <span class=\"number\">10</span><span class=\"string\">Gi</span></span><br><span class=\"line\"><span class=\"attr\">  accessModes:</span></span><br><span class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">ReadWriteOnece</span></span><br><span class=\"line\"><span class=\"attr\">  volumeMode:</span> <span class=\"string\">Block</span> <span class=\"comment\"># 块存储</span></span><br><span class=\"line\"><span class=\"attr\">  persistentVolumeReclaimPolicy:</span> <span class=\"string\">Retain</span></span><br><span class=\"line\"><span class=\"attr\">  fc:</span></span><br><span class=\"line\"><span class=\"attr\">    targetWWNs:</span> <span class=\"string\">[\"50060e801049cfd1\"]</span></span><br><span class=\"line\"><span class=\"attr\">    lun:</span> <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"attr\">    readOnly:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolumeClaim</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> <span class=\"string\">block-pvc</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\"><span class=\"attr\">  accessMode:</span></span><br><span class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\"><span class=\"attr\">  volumeMode:</span> <span class=\"string\">Block</span> <span class=\"comment\"># 块存储</span></span><br><span class=\"line\"><span class=\"attr\">  resources:</span></span><br><span class=\"line\"><span class=\"attr\">    requests:</span></span><br><span class=\"line\"><span class=\"attr\">      storage:</span> <span class=\"number\">10</span><span class=\"string\">Gi</span></span><br></pre></td></tr></table></figure>\n\n<p>块存储在机器上应该是以“设备”形式呈现，不同于文件系统的目录形式。部署应用时需要指定块设备同步到容器中 /dev 目录下的一个设备文件。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> <span class=\"string\">pod-with-block-volume</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\"><span class=\"attr\">  containers:</span></span><br><span class=\"line\"><span class=\"attr\">  - name:</span> <span class=\"string\">fc-container</span></span><br><span class=\"line\"><span class=\"attr\">    image:</span> <span class=\"attr\">fedora:26</span></span><br><span class=\"line\"><span class=\"attr\">    command:</span> <span class=\"string\">[\"/bin/sh\",</span> <span class=\"string\">\"-c\"</span><span class=\"string\">]</span></span><br><span class=\"line\"><span class=\"attr\">    args:</span> <span class=\"string\">[\"tail</span> <span class=\"bullet\">-f</span> <span class=\"string\">/dev/null\"]</span></span><br><span class=\"line\"><span class=\"attr\">    volumeDevices:</span>  <span class=\"comment\"># 块存储以设备文件形式存放到容器中的 /dev/xvda</span></span><br><span class=\"line\"><span class=\"attr\">    - name:</span> <span class=\"string\">data</span></span><br><span class=\"line\"><span class=\"attr\">      devicePath:</span> <span class=\"string\">/dev/xvda</span></span><br><span class=\"line\"><span class=\"attr\">  volumes:</span></span><br><span class=\"line\"><span class=\"attr\">  - name:</span> <span class=\"string\">data</span></span><br><span class=\"line\"><span class=\"attr\">    persistentVolumeClaim:</span></span><br><span class=\"line\"><span class=\"attr\">      claimName:</span> <span class=\"string\">block-pvc</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"各种卷类型\"><a href=\"#各种卷类型\" class=\"headerlink\" title=\"各种卷类型\"></a>各种卷类型</h1><p>K8s提供的卷类型非常丰富，包括（<a href=\"https://kubernetes.io/docs/concepts/storage/\" target=\"_blank\" rel=\"noopener\">详情参考官网</a>）：</p>\n<ul>\n<li>awsElasticBlockStore</li>\n<li>azureDisk</li>\n<li>azureFile</li>\n<li>cephfs</li>\n<li>cinder</li>\n<li>configMap</li>\n<li>csi</li>\n<li>downwardAPI</li>\n<li>emptyDir</li>\n<li>fc (fibre channel)</li>\n<li>flexVolume</li>\n<li>flocker</li>\n<li>gcePersistentDisk</li>\n<li>gitRepo (deprecated)</li>\n<li>glusterfs</li>\n<li>hostPath</li>\n<li>iscsi</li>\n<li>local</li>\n<li>nfs</li>\n<li>persistentVolumeClaim</li>\n<li>projected</li>\n<li>portworxVolume</li>\n<li>quobyte</li>\n<li>rbd</li>\n<li>scaleIO</li>\n<li>secret</li>\n<li>storageos</li>\n<li>vsphereVolume</li>\n</ul>\n<p>接下来将详细介绍部分存储类型的使用。</p>\n<h2 id=\"emptyDir\"><a href=\"#emptyDir\" class=\"headerlink\" title=\"emptyDir\"></a>emptyDir</h2><p>用于同一个Pod下不同容器之间共用的卷，当Pod被销毁时都会删除旧卷，这意味着emptyDir卷不能持久化Pod的信息，只用于Pod中不同容器之间以文件系统的方式通信。</p>\n<p>emptyDir的存储媒介可以选择：内存或磁盘。使用内存作为存储媒介时会以tmpfs类型的卷挂载到容器目录下，该目录下的数据都会保存在宿主机的内存中。使用磁盘作为存储媒介时会将会挂载宿主机 “/var/lib/kubelet/pods/<strong>{podUid}</strong>/volumes/kubernetes.io~empty-dir/<strong>{volumeName}</strong>“ 目录到容器中。</p>\n<p>下面给出emptyDir的例子：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\"><span class=\"attr\">  labels:</span></span><br><span class=\"line\"><span class=\"attr\">    name:</span> <span class=\"string\">test-emptypath</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> <span class=\"string\">test-emptypath</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\"><span class=\"attr\">  containers:</span></span><br><span class=\"line\"><span class=\"attr\">    - name:</span> <span class=\"string\">emptydir-producer</span></span><br><span class=\"line\"><span class=\"attr\">      image:</span> <span class=\"string\">busybox</span></span><br><span class=\"line\"><span class=\"attr\">      volumeMounts:</span></span><br><span class=\"line\"><span class=\"attr\">       - name:</span> <span class=\"string\">log-storage</span></span><br><span class=\"line\"><span class=\"attr\">         mountPath:</span> <span class=\"string\">/home/log/</span></span><br><span class=\"line\"><span class=\"attr\">      command:</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">/bin/sh</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"bullet\">-c</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">\"while [ true ]; do echo $(date) &gt;&gt; /home/log/test.log; sleep 5; done\"</span></span><br><span class=\"line\"><span class=\"attr\">    - name:</span> <span class=\"string\">emptydir-consumer</span></span><br><span class=\"line\"><span class=\"attr\">      image:</span> <span class=\"string\">busybox</span></span><br><span class=\"line\"><span class=\"attr\">      volumeMounts:</span></span><br><span class=\"line\"><span class=\"attr\">       - name:</span> <span class=\"string\">log-storage</span></span><br><span class=\"line\"><span class=\"attr\">         mountPath:</span> <span class=\"string\">/home/log/</span></span><br><span class=\"line\"><span class=\"attr\">      command:</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">tail</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"bullet\">-f</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">/home/log/test.log</span></span><br><span class=\"line\"><span class=\"attr\">  volumes:</span></span><br><span class=\"line\"><span class=\"attr\">  - name:</span> <span class=\"string\">log-storage</span></span><br><span class=\"line\"><span class=\"attr\">    emptyDir:</span></span><br><span class=\"line\">      <span class=\"comment\"># medium: Memory    # 卷媒介采用内存存储，不指定这个属性则表示采用磁盘作为存储媒介</span></span><br><span class=\"line\"><span class=\"attr\">      sizeLimit:</span> <span class=\"number\">300</span><span class=\"string\">Mi</span>  <span class=\"comment\"># 卷容量为300Mb</span></span><br></pre></td></tr></table></figure>\n\n<p>这个Pod中包含了两个容器，第一个容器用于产生日志输出到emptydir卷目录(/home/log)下的test.log文件中，另一个容器负责读取emptydir卷目录下的test.log文件内容，采用磁盘作为卷存储媒介，限制卷容量为300Mb。</p>\n<p>先进入第一个容器中确认容器中的日志已输出/home/log/test.log文件中。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl <span class=\"built_in\">exec</span> <span class=\"built_in\">test</span>-emptypath -c emptydir-producer cat /home/<span class=\"built_in\">log</span>/test.log</span><br><span class=\"line\">Wed Jan 1 15:21:21 UTC 2020</span><br><span class=\"line\">Wed Jan 1 15:21:26 UTC 2020</span><br><span class=\"line\">Wed Jan 1 15:21:31 UTC 2020</span><br><span class=\"line\">Wed Jan 1 15:21:36 UTC 2020</span><br><span class=\"line\">Wed Jan 1 15:21:41 UTC 2020</span><br><span class=\"line\"><span class=\"comment\"># 确认emptydir挂载到/home/log目录下，并且是以磁盘作为存储媒介</span></span><br><span class=\"line\">$ kubectl <span class=\"built_in\">exec</span> <span class=\"built_in\">test</span>-emptypath -c emptydir-producer df</span><br><span class=\"line\">Filesystem           1K-blocks      Used Available Use% Mounted on</span><br><span class=\"line\">overlay              478375712  69699844 408675868  15% /</span><br><span class=\"line\">tmpfs                    65536         0     65536   0% /dev</span><br><span class=\"line\">tmpfs                 32695936         0  32695936   0% /sys/fs/cgroup</span><br><span class=\"line\">/dev/mapper/centos-root 478375712  69699812 408675900  15% /dev/termination-log</span><br><span class=\"line\">/dev/mapper/centos-root 478375712  69699812 408675900  15% /home/<span class=\"built_in\">log</span></span><br><span class=\"line\">/dev/mapper/centos-root 478375712  69699812 408675900  15% /etc/resolv.conf</span><br><span class=\"line\">/dev/mapper/centos-root 478375712  69699812 408675900  15% /etc/hostname</span><br><span class=\"line\">/dev/mapper/centos-root 478375712  69699812 408675900  15% /etc/hosts</span><br><span class=\"line\">shm                      65536         0     65536   0% /dev/shm</span><br><span class=\"line\">tmpfs                 32695936        12  32695924   0% /var/run/secrets/kubernetes.io/serviceaccount</span><br><span class=\"line\">tmpfs                 32695936         0  32695936   0% /proc/acpi</span><br><span class=\"line\">tmpfs                    65536         0     65536   0% /proc/kcore</span><br><span class=\"line\">tmpfs                    65536         0     65536   0% /proc/keys</span><br><span class=\"line\">tmpfs                    65536         0     65536   0% /proc/timer_list</span><br><span class=\"line\">tmpfs                    65536         0     65536   0% /proc/timer_stats</span><br><span class=\"line\">tmpfs                    65536         0     65536   0% /proc/sched_debug</span><br><span class=\"line\">tmpfs                 32695936         0  32695936   0% /proc/scsi</span><br><span class=\"line\">tmpfs                 32695936         0  32695936   0% /sys/firmware</span><br></pre></td></tr></table></figure>\n\n<p>然后查看第二个容器的输出日志确实得到同样的内容。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl logs -f <span class=\"built_in\">test</span>-emptypath emptydir-consumer</span><br><span class=\"line\">Wed Jan 1 15:21:21 UTC 2020</span><br><span class=\"line\">Wed Jan 1 15:21:26 UTC 2020</span><br><span class=\"line\">Wed Jan 1 15:21:31 UTC 2020</span><br><span class=\"line\">Wed Jan 1 15:21:36 UTC 2020</span><br><span class=\"line\">Wed Jan 1 15:21:41 UTC 2020</span><br></pre></td></tr></table></figure>\n\n<p>接着我们尝试在宿主机查看这个emptydir卷对应的目录文件。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"hostPath\"><a href=\"#hostPath\" class=\"headerlink\" title=\"hostPath\"></a>hostPath</h2><h2 id=\"local\"><a href=\"#local\" class=\"headerlink\" title=\"local\"></a>local</h2><h2 id=\"secret\"><a href=\"#secret\" class=\"headerlink\" title=\"secret\"></a>secret</h2><h2 id=\"configMap\"><a href=\"#configMap\" class=\"headerlink\" title=\"configMap\"></a>configMap</h2><h2 id=\"persistentVolumeClaim\"><a href=\"#persistentVolumeClaim\" class=\"headerlink\" title=\"persistentVolumeClaim\"></a>persistentVolumeClaim</h2><p>一个persistentVolumeClaim卷需要绑定一个PersistentVolume后才能被Pod挂载。PersistentVolumes提供存储的抽象概念，它记录复杂的存储细节（使用的存储驱动及相关配置信息）。这样一来用户只需直接与persistentVolumeClaim卷打交道，无需了解后面绑定PersistentVolumes的存储细节。</p>\n<p>上面已对PVC做过详细介绍，这里不在阐述。</p>\n<h2 id=\"glusterFS\"><a href=\"#glusterFS\" class=\"headerlink\" title=\"glusterFS\"></a>glusterFS</h2><h2 id=\"cephRBD\"><a href=\"#cephRBD\" class=\"headerlink\" title=\"cephRBD\"></a>cephRBD</h2><p>Ceph RBD是基于Ceph的Block类型存储模式，优点是应用直接调用底层存储设备能力，不需要经过文件系统抽象接口，存取效率更高。缺点是只能挂载ReadWriteOnce模式的PVC，不适合做多应用文件共享。</p>\n<h2 id=\"cephFS\"><a href=\"#cephFS\" class=\"headerlink\" title=\"cephFS\"></a>cephFS</h2><h2 id=\"projected\"><a href=\"#projected\" class=\"headerlink\" title=\"projected\"></a>projected</h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"K8s存储概述\"><a href=\"#K8s存储概述\" class=\"headerlink\" title=\"K8s存储概述\"></a>K8s存储概述</h1><h2 id=\"Persistent-volumes-PV\"><a href=\"#Persistent-volumes-PV\" class=\"headerlink\" title=\"Persistent volumes(PV)\"></a>Persistent volumes(PV)</h2><p>下面是NFS的PV配置：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolume</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> <span class=\"string\">pv-1</span></span><br><span class=\"line\"><span class=\"attr\">  labels:</span></span><br><span class=\"line\"><span class=\"attr\">    release:</span> <span class=\"string\">stable</span></span><br><span class=\"line\"><span class=\"attr\">    capacity:</span> <span class=\"number\">100</span><span class=\"string\">Gi</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\"><span class=\"attr\">  capacity:</span></span><br><span class=\"line\"><span class=\"attr\">    storage:</span> <span class=\"number\">100</span><span class=\"string\">Gi</span></span><br><span class=\"line\"><span class=\"attr\">  volumeMode:</span> <span class=\"string\">Filesystem</span></span><br><span class=\"line\"><span class=\"attr\">  accessMode:</span></span><br><span class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">ReadWriteOnece</span></span><br><span class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">ReadOnlyMany</span></span><br><span class=\"line\"><span class=\"attr\">  storageClassName:</span> <span class=\"string\">normal</span></span><br><span class=\"line\"><span class=\"attr\">  persistentVolumeReclaimPolicy:</span> <span class=\"string\">Recycle</span></span><br><span class=\"line\"><span class=\"attr\">  nfs:</span></span><br><span class=\"line\"><span class=\"attr\">    path:</span> <span class=\"string\">/tmp</span></span><br><span class=\"line\"><span class=\"attr\">    server:</span> <span class=\"number\">127.17</span><span class=\"number\">.0</span><span class=\"number\">.8</span></span><br></pre></td></tr></table></figure>\n\n<p>字段解析：</p>\n<ul>\n<li>capacity: 指定这个PV的总容量。</li>\n<li>volumeMode: 可选值有”Filesystem”和”Block”，默认是”Filesystem”。</li>\n<li>accessMode: 可选值有”ReadOnlyMany”,”ReadWriteOnce”,”ReadWriteMany”。Once指的是同时只能被一个节点操作，Many指的是同时可被多个节点操作。</li>\n<li>persistentVolumeReclaimPolicy: 指定一个PVC被删除时当前PV需要执行的操作。可选值有”Retain”,”Delete”,”Recycle”。不同卷类型的PV可选的值稍微有些不同，比如只有NFS与HostPath模式提供”Recycle”策略。</li>\n<li>storageClassName: 这个字段是可选值，字符串类型。只有带有相同storageClassName的PVC才能索取这个PV，并且需要注意的是若当前PV没有设置storageClassName字段值，则只有那些同样没有设置storageClassName字段值的PVC能索取这个PV。</li>\n<li>卷类型：卷类型可选值有很多，将会在后续注意说明。设置的方式是把卷类型名称（如nfs）作为spec下的一个key，对应的值类型是对象，美中卷类型对象都有不同的字段。</li>\n</ul>\n<h2 id=\"Persistent-volume-claims-PVC\"><a href=\"#Persistent-volume-claims-PVC\" class=\"headerlink\" title=\"Persistent volume claims(PVC)\"></a>Persistent volume claims(PVC)</h2><p>生成PV后还不能立刻应用到容器中，需要创建一个PVC对象来配置对这个PV的索取方式，例子如下：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolumeClaim</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> <span class=\"string\">storage-claim</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\"><span class=\"attr\">  accessMode:</span></span><br><span class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\"><span class=\"attr\">  resources:</span></span><br><span class=\"line\"><span class=\"attr\">    requests:</span></span><br><span class=\"line\"><span class=\"attr\">      storage:</span> <span class=\"number\">80</span><span class=\"string\">Gi</span></span><br><span class=\"line\"><span class=\"attr\">  storageClassName:</span> <span class=\"string\">normal</span></span><br><span class=\"line\"><span class=\"attr\">  selector:</span></span><br><span class=\"line\"><span class=\"attr\">    matchLabels:</span></span><br><span class=\"line\"><span class=\"attr\">      release:</span> <span class=\"string\">stable</span></span><br><span class=\"line\"><span class=\"attr\">    matchExpressions:</span></span><br><span class=\"line\"><span class=\"bullet\">    -</span> <span class=\"string\">&#123;key:</span> <span class=\"string\">capacity,</span> <span class=\"attr\">operator:</span> <span class=\"string\">In,</span> <span class=\"attr\">values:</span> <span class=\"string\">[80Gi,</span> <span class=\"number\">1000</span><span class=\"string\">Gi]&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>PVC匹配PV的方式并不是使用name指定，而是通过storageClassName, capacity, selector字段进行筛选匹配。PVC与PV都是命名空间域下的资源，PVC只能索取相同命名空间下的PV。</p>\n<p>字段解析：</p>\n<ul>\n<li>accessMode: TODO。</li>\n<li>resources: 指定申请PV的空间大小，上面指定了80Gi，若是向100Gi的PV索取则剩下的20Gi将会浪费掉。</li>\n<li>storageClassName: 上一节提到过，这个PVC只能索取带有相同storageClassName的PV。</li>\n<li>selector: 相当于PV的过滤器，matchLabels指定只能索取带有这些标签的PV。matchExpressions可以指定筛选表达式，例子中筛选容量为80Gi或100Gi的PV。假设实际中还存在200Gi或500Gi的PV，而这个只需要80Gi的PVC去申请了这些PV将会是极大的资源浪费，通过这个selector的筛选可以禁止这个PVC索取这些大容量的PV。但即使没有这个selector的限制，K8s还是会索取现有容量最小且能满足PVC申请容量的PV。</li>\n</ul>\n<p>生成了PVC后，创建部署时就可以通过PVC的“名称”来挂载卷到容器中，例子如下：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> <span class=\"string\">the-pod</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\"><span class=\"attr\">  containers:</span></span><br><span class=\"line\"><span class=\"attr\">  - name:</span> <span class=\"string\">the-container</span></span><br><span class=\"line\"><span class=\"attr\">    image:</span> <span class=\"string\">some-image</span></span><br><span class=\"line\"><span class=\"attr\">    volumeMounts:</span></span><br><span class=\"line\"><span class=\"attr\">    - mountPath:</span> <span class=\"string\">/mnt/data</span></span><br><span class=\"line\"><span class=\"attr\">      name:</span> <span class=\"string\">persistent-volume</span></span><br><span class=\"line\"><span class=\"attr\">  volumes:</span></span><br><span class=\"line\"><span class=\"attr\">  - name:</span> <span class=\"string\">persistent-volume</span></span><br><span class=\"line\"><span class=\"attr\">    persistentVolumeClaim:</span></span><br><span class=\"line\"><span class=\"attr\">      claimName:</span> <span class=\"string\">storage-claim</span></span><br></pre></td></tr></table></figure>\n\n<p>PVC的卷就会挂载到容器中的 /mnt/data 目录下。</p>\n<h2 id=\"块存储\"><a href=\"#块存储\" class=\"headerlink\" title=\"块存储\"></a>块存储</h2><p>Kubernetes v1.9 新增了 Alpha 版的 Raw Block Volume，使用前需要为 kube-apiserver、kube-controller-manager 和 kubelet 开启 BlockVolume 特性，即添加命令行选项 –feature-gates=BlockVolume=true。</p>\n<p>块存储为应用程序提供了直接对底层存储设备进行操作的方式而不用经过文件系统抽象层接口，这样可以达到更高的存储效率。</p>\n<p>支持块存储的 PV 插件包括：</p>\n<ul>\n<li>Local Volume</li>\n<li>fc</li>\n<li>iSCSI</li>\n<li>Ceph RBD</li>\n<li>AWS EBS</li>\n<li>GCE PD</li>\n<li>AzureDisk</li>\n<li>Cinder</li>\n</ul>\n<p>下面给出块存储的例子：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolume</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> <span class=\"string\">block-pv</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\"><span class=\"attr\">  capacity:</span></span><br><span class=\"line\"><span class=\"attr\">    storage:</span> <span class=\"number\">10</span><span class=\"string\">Gi</span></span><br><span class=\"line\"><span class=\"attr\">  accessModes:</span></span><br><span class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">ReadWriteOnece</span></span><br><span class=\"line\"><span class=\"attr\">  volumeMode:</span> <span class=\"string\">Block</span> <span class=\"comment\"># 块存储</span></span><br><span class=\"line\"><span class=\"attr\">  persistentVolumeReclaimPolicy:</span> <span class=\"string\">Retain</span></span><br><span class=\"line\"><span class=\"attr\">  fc:</span></span><br><span class=\"line\"><span class=\"attr\">    targetWWNs:</span> <span class=\"string\">[\"50060e801049cfd1\"]</span></span><br><span class=\"line\"><span class=\"attr\">    lun:</span> <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"attr\">    readOnly:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">PersistentVolumeClaim</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> <span class=\"string\">block-pvc</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\"><span class=\"attr\">  accessMode:</span></span><br><span class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">ReadWriteOnce</span></span><br><span class=\"line\"><span class=\"attr\">  volumeMode:</span> <span class=\"string\">Block</span> <span class=\"comment\"># 块存储</span></span><br><span class=\"line\"><span class=\"attr\">  resources:</span></span><br><span class=\"line\"><span class=\"attr\">    requests:</span></span><br><span class=\"line\"><span class=\"attr\">      storage:</span> <span class=\"number\">10</span><span class=\"string\">Gi</span></span><br></pre></td></tr></table></figure>\n\n<p>块存储在机器上应该是以“设备”形式呈现，不同于文件系统的目录形式。部署应用时需要指定块设备同步到容器中 /dev 目录下的一个设备文件。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> <span class=\"string\">pod-with-block-volume</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\"><span class=\"attr\">  containers:</span></span><br><span class=\"line\"><span class=\"attr\">  - name:</span> <span class=\"string\">fc-container</span></span><br><span class=\"line\"><span class=\"attr\">    image:</span> <span class=\"attr\">fedora:26</span></span><br><span class=\"line\"><span class=\"attr\">    command:</span> <span class=\"string\">[\"/bin/sh\",</span> <span class=\"string\">\"-c\"</span><span class=\"string\">]</span></span><br><span class=\"line\"><span class=\"attr\">    args:</span> <span class=\"string\">[\"tail</span> <span class=\"bullet\">-f</span> <span class=\"string\">/dev/null\"]</span></span><br><span class=\"line\"><span class=\"attr\">    volumeDevices:</span>  <span class=\"comment\"># 块存储以设备文件形式存放到容器中的 /dev/xvda</span></span><br><span class=\"line\"><span class=\"attr\">    - name:</span> <span class=\"string\">data</span></span><br><span class=\"line\"><span class=\"attr\">      devicePath:</span> <span class=\"string\">/dev/xvda</span></span><br><span class=\"line\"><span class=\"attr\">  volumes:</span></span><br><span class=\"line\"><span class=\"attr\">  - name:</span> <span class=\"string\">data</span></span><br><span class=\"line\"><span class=\"attr\">    persistentVolumeClaim:</span></span><br><span class=\"line\"><span class=\"attr\">      claimName:</span> <span class=\"string\">block-pvc</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"各种卷类型\"><a href=\"#各种卷类型\" class=\"headerlink\" title=\"各种卷类型\"></a>各种卷类型</h1><p>K8s提供的卷类型非常丰富，包括（<a href=\"https://kubernetes.io/docs/concepts/storage/\" target=\"_blank\" rel=\"noopener\">详情参考官网</a>）：</p>\n<ul>\n<li>awsElasticBlockStore</li>\n<li>azureDisk</li>\n<li>azureFile</li>\n<li>cephfs</li>\n<li>cinder</li>\n<li>configMap</li>\n<li>csi</li>\n<li>downwardAPI</li>\n<li>emptyDir</li>\n<li>fc (fibre channel)</li>\n<li>flexVolume</li>\n<li>flocker</li>\n<li>gcePersistentDisk</li>\n<li>gitRepo (deprecated)</li>\n<li>glusterfs</li>\n<li>hostPath</li>\n<li>iscsi</li>\n<li>local</li>\n<li>nfs</li>\n<li>persistentVolumeClaim</li>\n<li>projected</li>\n<li>portworxVolume</li>\n<li>quobyte</li>\n<li>rbd</li>\n<li>scaleIO</li>\n<li>secret</li>\n<li>storageos</li>\n<li>vsphereVolume</li>\n</ul>\n<p>接下来将详细介绍部分存储类型的使用。</p>\n<h2 id=\"emptyDir\"><a href=\"#emptyDir\" class=\"headerlink\" title=\"emptyDir\"></a>emptyDir</h2><p>用于同一个Pod下不同容器之间共用的卷，当Pod被销毁时都会删除旧卷，这意味着emptyDir卷不能持久化Pod的信息，只用于Pod中不同容器之间以文件系统的方式通信。</p>\n<p>emptyDir的存储媒介可以选择：内存或磁盘。使用内存作为存储媒介时会以tmpfs类型的卷挂载到容器目录下，该目录下的数据都会保存在宿主机的内存中。使用磁盘作为存储媒介时会将会挂载宿主机 “/var/lib/kubelet/pods/<strong>{podUid}</strong>/volumes/kubernetes.io~empty-dir/<strong>{volumeName}</strong>“ 目录到容器中。</p>\n<p>下面给出emptyDir的例子：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Pod</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\"><span class=\"attr\">  labels:</span></span><br><span class=\"line\"><span class=\"attr\">    name:</span> <span class=\"string\">test-emptypath</span></span><br><span class=\"line\"><span class=\"attr\">  name:</span> <span class=\"string\">test-emptypath</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\"><span class=\"attr\">  containers:</span></span><br><span class=\"line\"><span class=\"attr\">    - name:</span> <span class=\"string\">emptydir-producer</span></span><br><span class=\"line\"><span class=\"attr\">      image:</span> <span class=\"string\">busybox</span></span><br><span class=\"line\"><span class=\"attr\">      volumeMounts:</span></span><br><span class=\"line\"><span class=\"attr\">       - name:</span> <span class=\"string\">log-storage</span></span><br><span class=\"line\"><span class=\"attr\">         mountPath:</span> <span class=\"string\">/home/log/</span></span><br><span class=\"line\"><span class=\"attr\">      command:</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">/bin/sh</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"bullet\">-c</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">\"while [ true ]; do echo $(date) &gt;&gt; /home/log/test.log; sleep 5; done\"</span></span><br><span class=\"line\"><span class=\"attr\">    - name:</span> <span class=\"string\">emptydir-consumer</span></span><br><span class=\"line\"><span class=\"attr\">      image:</span> <span class=\"string\">busybox</span></span><br><span class=\"line\"><span class=\"attr\">      volumeMounts:</span></span><br><span class=\"line\"><span class=\"attr\">       - name:</span> <span class=\"string\">log-storage</span></span><br><span class=\"line\"><span class=\"attr\">         mountPath:</span> <span class=\"string\">/home/log/</span></span><br><span class=\"line\"><span class=\"attr\">      command:</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">tail</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"bullet\">-f</span></span><br><span class=\"line\"><span class=\"bullet\">      -</span> <span class=\"string\">/home/log/test.log</span></span><br><span class=\"line\"><span class=\"attr\">  volumes:</span></span><br><span class=\"line\"><span class=\"attr\">  - name:</span> <span class=\"string\">log-storage</span></span><br><span class=\"line\"><span class=\"attr\">    emptyDir:</span></span><br><span class=\"line\">      <span class=\"comment\"># medium: Memory    # 卷媒介采用内存存储，不指定这个属性则表示采用磁盘作为存储媒介</span></span><br><span class=\"line\"><span class=\"attr\">      sizeLimit:</span> <span class=\"number\">300</span><span class=\"string\">Mi</span>  <span class=\"comment\"># 卷容量为300Mb</span></span><br></pre></td></tr></table></figure>\n\n<p>这个Pod中包含了两个容器，第一个容器用于产生日志输出到emptydir卷目录(/home/log)下的test.log文件中，另一个容器负责读取emptydir卷目录下的test.log文件内容，采用磁盘作为卷存储媒介，限制卷容量为300Mb。</p>\n<p>先进入第一个容器中确认容器中的日志已输出/home/log/test.log文件中。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl <span class=\"built_in\">exec</span> <span class=\"built_in\">test</span>-emptypath -c emptydir-producer cat /home/<span class=\"built_in\">log</span>/test.log</span><br><span class=\"line\">Wed Jan 1 15:21:21 UTC 2020</span><br><span class=\"line\">Wed Jan 1 15:21:26 UTC 2020</span><br><span class=\"line\">Wed Jan 1 15:21:31 UTC 2020</span><br><span class=\"line\">Wed Jan 1 15:21:36 UTC 2020</span><br><span class=\"line\">Wed Jan 1 15:21:41 UTC 2020</span><br><span class=\"line\"><span class=\"comment\"># 确认emptydir挂载到/home/log目录下，并且是以磁盘作为存储媒介</span></span><br><span class=\"line\">$ kubectl <span class=\"built_in\">exec</span> <span class=\"built_in\">test</span>-emptypath -c emptydir-producer df</span><br><span class=\"line\">Filesystem           1K-blocks      Used Available Use% Mounted on</span><br><span class=\"line\">overlay              478375712  69699844 408675868  15% /</span><br><span class=\"line\">tmpfs                    65536         0     65536   0% /dev</span><br><span class=\"line\">tmpfs                 32695936         0  32695936   0% /sys/fs/cgroup</span><br><span class=\"line\">/dev/mapper/centos-root 478375712  69699812 408675900  15% /dev/termination-log</span><br><span class=\"line\">/dev/mapper/centos-root 478375712  69699812 408675900  15% /home/<span class=\"built_in\">log</span></span><br><span class=\"line\">/dev/mapper/centos-root 478375712  69699812 408675900  15% /etc/resolv.conf</span><br><span class=\"line\">/dev/mapper/centos-root 478375712  69699812 408675900  15% /etc/hostname</span><br><span class=\"line\">/dev/mapper/centos-root 478375712  69699812 408675900  15% /etc/hosts</span><br><span class=\"line\">shm                      65536         0     65536   0% /dev/shm</span><br><span class=\"line\">tmpfs                 32695936        12  32695924   0% /var/run/secrets/kubernetes.io/serviceaccount</span><br><span class=\"line\">tmpfs                 32695936         0  32695936   0% /proc/acpi</span><br><span class=\"line\">tmpfs                    65536         0     65536   0% /proc/kcore</span><br><span class=\"line\">tmpfs                    65536         0     65536   0% /proc/keys</span><br><span class=\"line\">tmpfs                    65536         0     65536   0% /proc/timer_list</span><br><span class=\"line\">tmpfs                    65536         0     65536   0% /proc/timer_stats</span><br><span class=\"line\">tmpfs                    65536         0     65536   0% /proc/sched_debug</span><br><span class=\"line\">tmpfs                 32695936         0  32695936   0% /proc/scsi</span><br><span class=\"line\">tmpfs                 32695936         0  32695936   0% /sys/firmware</span><br></pre></td></tr></table></figure>\n\n<p>然后查看第二个容器的输出日志确实得到同样的内容。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl logs -f <span class=\"built_in\">test</span>-emptypath emptydir-consumer</span><br><span class=\"line\">Wed Jan 1 15:21:21 UTC 2020</span><br><span class=\"line\">Wed Jan 1 15:21:26 UTC 2020</span><br><span class=\"line\">Wed Jan 1 15:21:31 UTC 2020</span><br><span class=\"line\">Wed Jan 1 15:21:36 UTC 2020</span><br><span class=\"line\">Wed Jan 1 15:21:41 UTC 2020</span><br></pre></td></tr></table></figure>\n\n<p>接着我们尝试在宿主机查看这个emptydir卷对应的目录文件。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"hostPath\"><a href=\"#hostPath\" class=\"headerlink\" title=\"hostPath\"></a>hostPath</h2><h2 id=\"local\"><a href=\"#local\" class=\"headerlink\" title=\"local\"></a>local</h2><h2 id=\"secret\"><a href=\"#secret\" class=\"headerlink\" title=\"secret\"></a>secret</h2><h2 id=\"configMap\"><a href=\"#configMap\" class=\"headerlink\" title=\"configMap\"></a>configMap</h2><h2 id=\"persistentVolumeClaim\"><a href=\"#persistentVolumeClaim\" class=\"headerlink\" title=\"persistentVolumeClaim\"></a>persistentVolumeClaim</h2><p>一个persistentVolumeClaim卷需要绑定一个PersistentVolume后才能被Pod挂载。PersistentVolumes提供存储的抽象概念，它记录复杂的存储细节（使用的存储驱动及相关配置信息）。这样一来用户只需直接与persistentVolumeClaim卷打交道，无需了解后面绑定PersistentVolumes的存储细节。</p>\n<p>上面已对PVC做过详细介绍，这里不在阐述。</p>\n<h2 id=\"glusterFS\"><a href=\"#glusterFS\" class=\"headerlink\" title=\"glusterFS\"></a>glusterFS</h2><h2 id=\"cephRBD\"><a href=\"#cephRBD\" class=\"headerlink\" title=\"cephRBD\"></a>cephRBD</h2><p>Ceph RBD是基于Ceph的Block类型存储模式，优点是应用直接调用底层存储设备能力，不需要经过文件系统抽象接口，存取效率更高。缺点是只能挂载ReadWriteOnce模式的PVC，不适合做多应用文件共享。</p>\n<h2 id=\"cephFS\"><a href=\"#cephFS\" class=\"headerlink\" title=\"cephFS\"></a>cephFS</h2><h2 id=\"projected\"><a href=\"#projected\" class=\"headerlink\" title=\"projected\"></a>projected</h2>"},{"title":"K8s容器选举模式","_content":"选举模式在软件架构中应用广泛，主要解决的问题是：某些有状态的功能逻辑只能在一个节点上执行（如：任务队列，集群锁等），不能在多个节点上并行操作，但又想保证服务的高可用。这种模式需要外部组件存储\n\n<!--more-->","source":"_drafts/k8s-容器主从模式.md","raw":"---\ntitle: \"K8s容器选举模式\"\ncategory: k8s\n---\n选举模式在软件架构中应用广泛，主要解决的问题是：某些有状态的功能逻辑只能在一个节点上执行（如：任务队列，集群锁等），不能在多个节点上并行操作，但又想保证服务的高可用。这种模式需要外部组件存储\n\n<!--more-->","slug":"k8s-容器主从模式","published":0,"date":"2020-01-16T17:23:25.488Z","updated":"2019-11-21T03:04:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck679mts3000klbmd96zt6wki","content":"<p>选举模式在软件架构中应用广泛，主要解决的问题是：某些有状态的功能逻辑只能在一个节点上执行（如：任务队列，集群锁等），不能在多个节点上并行操作，但又想保证服务的高可用。这种模式需要外部组件存储</p>\n<a id=\"more\"></a>","site":{"data":{}},"excerpt":"<p>选举模式在软件架构中应用广泛，主要解决的问题是：某些有状态的功能逻辑只能在一个节点上执行（如：任务队列，集群锁等），不能在多个节点上并行操作，但又想保证服务的高可用。这种模式需要外部组件存储</p>","more":""},{"title":"Rook搭建Ceph集群","_content":"","source":"_drafts/rook-ceph.md","raw":"---\ntitle: \"Rook搭建Ceph集群\"\ncategory: Ceph\n---\n","slug":"rook-ceph","published":0,"date":"2020-01-16T17:23:25.488Z","updated":"2020-01-06T06:57:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck679mts4000nlbmdko3ob8rd","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"k8s基本概念","mathjax":false,"_content":"本章介绍K8s核心概念，了解K8s的基本组件及其作用，为后续深入学习做铺垫。\n\n<!--more-->\n\n# 资源\n## Cluster\nK8s集群，由上图中的所有组件组成，包含了计算、存储、网络资源。\n\n## Node\n* Node：Node指定一台宿主机，可以是物理机或是虚拟机。K8s中节点分为两种：Master Node 与 Worker Node。\n* Master Node：对集群做出全局性决策(例如：调度)，以及检测和响应集群事件(副本控制器的replicas字段不满足时,启动新的副本)。包括组件有：kube-apiserver,kube-control-manager,kube-schduler。\n* Worker Node：落实容器生命周期管理工作，以及POD的路由转发处理工作。包括组件有：kubelet,kube-proxy。\n\n## Pod\nPod可以理解为一个虚拟节点，Kubernetes以Pod为最小单元进行调度、扩展、资源共享、管理生命周期。每个Pod中可以包含一个或多个容器，Pod中的所有容器都会共享同一个网络以及文件系统，也就是说Pod中的多个容器不能同时占用同一个Pod端口，K8s会为每个Pod创建一个volume，同一个Pod下多个容器的文件共享就是通过挂载同一个volume来实现的。同一个Pod中的所有容器只会运行在同一Node上。\n\n## ReplicationController\nRC是K8s集群中最早的保证Pod高可用的API对象。通过监控运行中的Pod来保证集群中运行指定数目的Pod副本。指定的数目可以是多个也可以是1个；少于指定数目，RC就会启动运行新的Pod副本；多于指定数目，RC就会杀死多余的Pod副本。即使在指定数目为1的情况下，通过RC运行Pod也比直接运行Pod更明智，因为RC也可以发挥它高可用的能力，保证永远有1个Pod在运行。RC是K8s较早期的技术概念，只适用于长期伺服型的业务类型，比如控制小机器人提供高可用的Web服务。\n\n## ReplicaSet\nRS是新一代RC，提供同样的高可用能力，区别主要在于RS后来居上，能支持更多种类的匹配模式。副本集对象一般不单独使用，而是作为Deployment的理想状态参数使用。\n\n## Deployment\n部署表示用户对K8s集群的一次更新操作。部署是一个比ReplicaSet应用模式更广的API对象，可以是创建一个新的服务，更新一个新的服务，也可以是滚动升级一个服务。滚动升级一个服务，实际是创建一个新的RS，然后逐渐将新RS中副本数增加到理想状态，将旧RS中的副本数减小到0的复合操作；这样一个复合操作用一个ReplicaSet是不太好描述的，所以用一个更通用的Deployment来描述。以K8s的发展方向，未来对所有长期伺服型的的业务的管理，都会通过Deployment来管理。\n\n## StatefulSet\nStatefulSet是为了解决有状态服务的问题（对应Deployments和ReplicaSets是为无状态服务而设计），其应用场景包括:\n* 稳定的持久化存储，即Pod重新调度后还是能访问到相同的持久化数据，基于PVC来实现\n* 稳定的网络标志，即Pod重新调度后其PodName和HostName不变，基于Headless Service（即没有Cluster IP的Service）来实现\n* 有序部署，有序扩展，即Pod是有顺序的，在部署或者扩展的时候要依据定义的顺序依次依次进行（即从0到N-1，在下一个Pod运行之前所有之前的Pod必须都是Running和Ready状态），基于init containers来实现\n* 有序收缩，有序删除（即从N-1到0）\n\n## DaemonSet\n长期伺服型和批处理型服务的核心在业务应用，可能有些节点运行多个同类业务的Pod，有些节点上又没有这类Pod运行；而后台支撑型服务的核心关注点在K8s集群中的节点（物理机或虚拟机），要保证每个节点上都有一个此类Pod运行。节点可能是所有集群节点也可能是通过nodeSelector选定的一些特定节点。典型的后台支撑型服务包括，存储，日志和监控等在每个节点上支持K8s集群运行的服务。\n\n## PersistentVolume\nPersistentVolumes提供存储的抽象概念，它记录复杂的存储细节（使用的存储驱动及相关配置信息），使得Pod挂载卷可以忽略这些繁杂的细节，可以把一个PersistentVolume看作一个抽象卷。\n\n## PersistentVolumeClaim\n存储的PV和PVC的这种关系，跟计算的Node和Pod的关系是非常类似的；PV和Node是资源的提供者，根据集群的基础设施变化而变化，由K8s集群管理员配置；而PVC和Pod是资源的使用者，根据业务服务的需求变化而变化，有K8s集群的使用者即服务的管理员来配置。\n\n## Secret\nSecret是用来保存和传递密码、密钥、认证凭证这些敏感信息的对象。使用Secret的好处是可以避免把敏感信息明文写在配置文件里。\n\n## Namespace\n名字空间为K8s集群提供虚拟的隔离作用，K8s集群初始有两个名字空间，分别是默认名字空间default和系统名字空间kube-system，除此以外，管理员可以可以创建新的名字空间满足需要。\n\n## UserAccount\n用户帐户为人提供账户标识，记录了权限以及凭证信息。用户帐户对应的是人的身份，人的身份与服务的namespace无关，所以用户账户是跨namespace的。\n\n## ServiceAccount\n服务账户为计算机进程和K8s集群中运行的Pod提供账户标识，只记录了权限信息。服务帐户对应的是一个运行中程序的身份，与特定namespace是相关的。\n\n# 核心组件\n![K8s架构图](https://res.cloudinary.com/dukp6c7f7/image/upload/f_auto,fl_lossy,q_auto/s3-ghost/2016/06/o7leok.png)\n\n## etcd\n数据库。所有master的持续状态都存在etcd的一个实例中。这可以很好地存储配置数据。因为有watch(观察者)的支持，各部件协调中的改变可以很快被察觉。\n\n## apiserver\n作为K8s集群对外的开放API的门户入口，主要功能有：\n* 提供整个K8s集群资源增删改查的Restful接口。\n* 对接口请求进行安全校验。 \n* 把资源数据持久化到etcd。\n* 作为资源分配的入口点。scheduler监测到有容器需要创建时，经过sheduler调度算法计算好资源分配策略后需要调用apiserver的接口进行资源的实际分配操作，最终由apiserver向kubelet节点发起容器创建的通知。\n\n## controller-manager\n集群内部的Controller管理中心，内置了多个原生Controller。\n\n说到controller-manager不得不介绍Controller组件，apiServer对外提供的Restful接口纯粹是对资源数据的增删改查操作，对于资源的部署和维护等逻辑不包含在其中，实际上是Controller通过apiServer监控集群的资源数据变化，发现某个资源数据发生变化时会做出相应的处理逻辑。\n\n比如：controller-manager中的Replication Controller（不同于资源类型的ReplicationController，为了便于区分接下来我会把资源类型的ReplicationController简称为RC）会检测集群中的POD节点情况，确保RC中的POD数量保持在用户创建RC时指定的副本数，当发现POD宕机时，Replication Controller会重新创建一个新的POD来维持这个副本数；当用户修改了RC的副本数时，Replication Controller也会根据当前RC中POD的数据进行POD的追加或删除。\n\n## scheduler\nScheduler负责Pod调度。负责接收Controller Manager创建的新的Pod，根据调度策略为其分配一个合适的Node。完整的调度过程为：\n1. 通过调度算法为待调度Pod列表的每个Pod从Node列表中选择一个最适合的Node，并将信息写入etcd中。\n2. kubelet通过API Server监听到kubernetes Scheduler产生的Pod绑定信息，然后获取对应的Pod清单，下载Image，并启动容器。\n\n![scheduler调度过程](https://upload-images.jianshu.io/upload_images/7378149-d8078bd4c09c75a1.png?imageMogr2/auto-orient/strip|imageView2/2/w/603/format/webp)\n\n## kubelet\nkubelet充当K8s worker节点对容器生命周期的管理服务。经过上述scheduler调度策略完成之后，需要真正在对应的Node上创建这个POD，kubelet就是负责这一部分的工作。\n\nkubelet是基于controller模式实现的（笔者日后会编写关于自定义Controller的文章讲解），它会监听Pod的增删改事件（包括Pod的生命周期变化）、Node自身事件（每个kubelet就是一个Node）以及定时的清理事件。一旦发现监听的数据产生了变化，kubelet会立刻作出相应的业务逻辑，如：scheduler把POD分配给了一个Node，这个Node监听到POD数据修改事件并从最新的POD数据中得知该POD被分配到当前Node中，kubelet判断到当前宿主机资源满足容器创建后就会根据POD的容器配置在宿主机上创建这些容器。\n\n## kube-proxy\nkube-proxy在K8s中主要承担路由转发和负载均衡的工作，具体功能包括：\n* 管理service的访问入口，包括集群内Pod到Service的访问和集群外访问service。\n* 管理sevice的Endpoints，该service对外暴露一个Virtual IP，也成为Cluster IP, 集群内通过访问这个Cluster IP:Port就能访问到集群内对应的serivce下的Pod。\n* service是通过Selector选择的一组Pods的服务抽象，其实就是一个微服务，提供了服务的LB和反向代理的能力，而kube-proxy的主要作用就是负责service的实现。\n\n## kubectl\napiserver开放的接口是HTTPS协议的Restful API，不方便用户在控制台直接操作K8s。kubectl就是为了解决这个问题而产生的，用户可以在控制台中通过kubectl封装好的简单命令对K8s集群进行操作（如：kubectl get pod 查询默认命名空间下的pod），kubectl会根据用户输入的命令转化成apiserver Restful API的请求形式再转发给apiserver。","source":"_drafts/k8s基本概念.md","raw":"---\ntitle: \"k8s基本概念\"\ncategory: k8s\nmathjax: false\n---\n本章介绍K8s核心概念，了解K8s的基本组件及其作用，为后续深入学习做铺垫。\n\n<!--more-->\n\n# 资源\n## Cluster\nK8s集群，由上图中的所有组件组成，包含了计算、存储、网络资源。\n\n## Node\n* Node：Node指定一台宿主机，可以是物理机或是虚拟机。K8s中节点分为两种：Master Node 与 Worker Node。\n* Master Node：对集群做出全局性决策(例如：调度)，以及检测和响应集群事件(副本控制器的replicas字段不满足时,启动新的副本)。包括组件有：kube-apiserver,kube-control-manager,kube-schduler。\n* Worker Node：落实容器生命周期管理工作，以及POD的路由转发处理工作。包括组件有：kubelet,kube-proxy。\n\n## Pod\nPod可以理解为一个虚拟节点，Kubernetes以Pod为最小单元进行调度、扩展、资源共享、管理生命周期。每个Pod中可以包含一个或多个容器，Pod中的所有容器都会共享同一个网络以及文件系统，也就是说Pod中的多个容器不能同时占用同一个Pod端口，K8s会为每个Pod创建一个volume，同一个Pod下多个容器的文件共享就是通过挂载同一个volume来实现的。同一个Pod中的所有容器只会运行在同一Node上。\n\n## ReplicationController\nRC是K8s集群中最早的保证Pod高可用的API对象。通过监控运行中的Pod来保证集群中运行指定数目的Pod副本。指定的数目可以是多个也可以是1个；少于指定数目，RC就会启动运行新的Pod副本；多于指定数目，RC就会杀死多余的Pod副本。即使在指定数目为1的情况下，通过RC运行Pod也比直接运行Pod更明智，因为RC也可以发挥它高可用的能力，保证永远有1个Pod在运行。RC是K8s较早期的技术概念，只适用于长期伺服型的业务类型，比如控制小机器人提供高可用的Web服务。\n\n## ReplicaSet\nRS是新一代RC，提供同样的高可用能力，区别主要在于RS后来居上，能支持更多种类的匹配模式。副本集对象一般不单独使用，而是作为Deployment的理想状态参数使用。\n\n## Deployment\n部署表示用户对K8s集群的一次更新操作。部署是一个比ReplicaSet应用模式更广的API对象，可以是创建一个新的服务，更新一个新的服务，也可以是滚动升级一个服务。滚动升级一个服务，实际是创建一个新的RS，然后逐渐将新RS中副本数增加到理想状态，将旧RS中的副本数减小到0的复合操作；这样一个复合操作用一个ReplicaSet是不太好描述的，所以用一个更通用的Deployment来描述。以K8s的发展方向，未来对所有长期伺服型的的业务的管理，都会通过Deployment来管理。\n\n## StatefulSet\nStatefulSet是为了解决有状态服务的问题（对应Deployments和ReplicaSets是为无状态服务而设计），其应用场景包括:\n* 稳定的持久化存储，即Pod重新调度后还是能访问到相同的持久化数据，基于PVC来实现\n* 稳定的网络标志，即Pod重新调度后其PodName和HostName不变，基于Headless Service（即没有Cluster IP的Service）来实现\n* 有序部署，有序扩展，即Pod是有顺序的，在部署或者扩展的时候要依据定义的顺序依次依次进行（即从0到N-1，在下一个Pod运行之前所有之前的Pod必须都是Running和Ready状态），基于init containers来实现\n* 有序收缩，有序删除（即从N-1到0）\n\n## DaemonSet\n长期伺服型和批处理型服务的核心在业务应用，可能有些节点运行多个同类业务的Pod，有些节点上又没有这类Pod运行；而后台支撑型服务的核心关注点在K8s集群中的节点（物理机或虚拟机），要保证每个节点上都有一个此类Pod运行。节点可能是所有集群节点也可能是通过nodeSelector选定的一些特定节点。典型的后台支撑型服务包括，存储，日志和监控等在每个节点上支持K8s集群运行的服务。\n\n## PersistentVolume\nPersistentVolumes提供存储的抽象概念，它记录复杂的存储细节（使用的存储驱动及相关配置信息），使得Pod挂载卷可以忽略这些繁杂的细节，可以把一个PersistentVolume看作一个抽象卷。\n\n## PersistentVolumeClaim\n存储的PV和PVC的这种关系，跟计算的Node和Pod的关系是非常类似的；PV和Node是资源的提供者，根据集群的基础设施变化而变化，由K8s集群管理员配置；而PVC和Pod是资源的使用者，根据业务服务的需求变化而变化，有K8s集群的使用者即服务的管理员来配置。\n\n## Secret\nSecret是用来保存和传递密码、密钥、认证凭证这些敏感信息的对象。使用Secret的好处是可以避免把敏感信息明文写在配置文件里。\n\n## Namespace\n名字空间为K8s集群提供虚拟的隔离作用，K8s集群初始有两个名字空间，分别是默认名字空间default和系统名字空间kube-system，除此以外，管理员可以可以创建新的名字空间满足需要。\n\n## UserAccount\n用户帐户为人提供账户标识，记录了权限以及凭证信息。用户帐户对应的是人的身份，人的身份与服务的namespace无关，所以用户账户是跨namespace的。\n\n## ServiceAccount\n服务账户为计算机进程和K8s集群中运行的Pod提供账户标识，只记录了权限信息。服务帐户对应的是一个运行中程序的身份，与特定namespace是相关的。\n\n# 核心组件\n![K8s架构图](https://res.cloudinary.com/dukp6c7f7/image/upload/f_auto,fl_lossy,q_auto/s3-ghost/2016/06/o7leok.png)\n\n## etcd\n数据库。所有master的持续状态都存在etcd的一个实例中。这可以很好地存储配置数据。因为有watch(观察者)的支持，各部件协调中的改变可以很快被察觉。\n\n## apiserver\n作为K8s集群对外的开放API的门户入口，主要功能有：\n* 提供整个K8s集群资源增删改查的Restful接口。\n* 对接口请求进行安全校验。 \n* 把资源数据持久化到etcd。\n* 作为资源分配的入口点。scheduler监测到有容器需要创建时，经过sheduler调度算法计算好资源分配策略后需要调用apiserver的接口进行资源的实际分配操作，最终由apiserver向kubelet节点发起容器创建的通知。\n\n## controller-manager\n集群内部的Controller管理中心，内置了多个原生Controller。\n\n说到controller-manager不得不介绍Controller组件，apiServer对外提供的Restful接口纯粹是对资源数据的增删改查操作，对于资源的部署和维护等逻辑不包含在其中，实际上是Controller通过apiServer监控集群的资源数据变化，发现某个资源数据发生变化时会做出相应的处理逻辑。\n\n比如：controller-manager中的Replication Controller（不同于资源类型的ReplicationController，为了便于区分接下来我会把资源类型的ReplicationController简称为RC）会检测集群中的POD节点情况，确保RC中的POD数量保持在用户创建RC时指定的副本数，当发现POD宕机时，Replication Controller会重新创建一个新的POD来维持这个副本数；当用户修改了RC的副本数时，Replication Controller也会根据当前RC中POD的数据进行POD的追加或删除。\n\n## scheduler\nScheduler负责Pod调度。负责接收Controller Manager创建的新的Pod，根据调度策略为其分配一个合适的Node。完整的调度过程为：\n1. 通过调度算法为待调度Pod列表的每个Pod从Node列表中选择一个最适合的Node，并将信息写入etcd中。\n2. kubelet通过API Server监听到kubernetes Scheduler产生的Pod绑定信息，然后获取对应的Pod清单，下载Image，并启动容器。\n\n![scheduler调度过程](https://upload-images.jianshu.io/upload_images/7378149-d8078bd4c09c75a1.png?imageMogr2/auto-orient/strip|imageView2/2/w/603/format/webp)\n\n## kubelet\nkubelet充当K8s worker节点对容器生命周期的管理服务。经过上述scheduler调度策略完成之后，需要真正在对应的Node上创建这个POD，kubelet就是负责这一部分的工作。\n\nkubelet是基于controller模式实现的（笔者日后会编写关于自定义Controller的文章讲解），它会监听Pod的增删改事件（包括Pod的生命周期变化）、Node自身事件（每个kubelet就是一个Node）以及定时的清理事件。一旦发现监听的数据产生了变化，kubelet会立刻作出相应的业务逻辑，如：scheduler把POD分配给了一个Node，这个Node监听到POD数据修改事件并从最新的POD数据中得知该POD被分配到当前Node中，kubelet判断到当前宿主机资源满足容器创建后就会根据POD的容器配置在宿主机上创建这些容器。\n\n## kube-proxy\nkube-proxy在K8s中主要承担路由转发和负载均衡的工作，具体功能包括：\n* 管理service的访问入口，包括集群内Pod到Service的访问和集群外访问service。\n* 管理sevice的Endpoints，该service对外暴露一个Virtual IP，也成为Cluster IP, 集群内通过访问这个Cluster IP:Port就能访问到集群内对应的serivce下的Pod。\n* service是通过Selector选择的一组Pods的服务抽象，其实就是一个微服务，提供了服务的LB和反向代理的能力，而kube-proxy的主要作用就是负责service的实现。\n\n## kubectl\napiserver开放的接口是HTTPS协议的Restful API，不方便用户在控制台直接操作K8s。kubectl就是为了解决这个问题而产生的，用户可以在控制台中通过kubectl封装好的简单命令对K8s集群进行操作（如：kubectl get pod 查询默认命名空间下的pod），kubectl会根据用户输入的命令转化成apiserver Restful API的请求形式再转发给apiserver。","slug":"k8s基本概念","published":0,"date":"2020-01-16T17:23:25.488Z","updated":"2020-01-14T03:34:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck679mts5000plbmd2kp3m56b","content":"<p>本章介绍K8s核心概念，了解K8s的基本组件及其作用，为后续深入学习做铺垫。</p>\n<a id=\"more\"></a>\n\n<h1 id=\"资源\"><a href=\"#资源\" class=\"headerlink\" title=\"资源\"></a>资源</h1><h2 id=\"Cluster\"><a href=\"#Cluster\" class=\"headerlink\" title=\"Cluster\"></a>Cluster</h2><p>K8s集群，由上图中的所有组件组成，包含了计算、存储、网络资源。</p>\n<h2 id=\"Node\"><a href=\"#Node\" class=\"headerlink\" title=\"Node\"></a>Node</h2><ul>\n<li>Node：Node指定一台宿主机，可以是物理机或是虚拟机。K8s中节点分为两种：Master Node 与 Worker Node。</li>\n<li>Master Node：对集群做出全局性决策(例如：调度)，以及检测和响应集群事件(副本控制器的replicas字段不满足时,启动新的副本)。包括组件有：kube-apiserver,kube-control-manager,kube-schduler。</li>\n<li>Worker Node：落实容器生命周期管理工作，以及POD的路由转发处理工作。包括组件有：kubelet,kube-proxy。</li>\n</ul>\n<h2 id=\"Pod\"><a href=\"#Pod\" class=\"headerlink\" title=\"Pod\"></a>Pod</h2><p>Pod可以理解为一个虚拟节点，Kubernetes以Pod为最小单元进行调度、扩展、资源共享、管理生命周期。每个Pod中可以包含一个或多个容器，Pod中的所有容器都会共享同一个网络以及文件系统，也就是说Pod中的多个容器不能同时占用同一个Pod端口，K8s会为每个Pod创建一个volume，同一个Pod下多个容器的文件共享就是通过挂载同一个volume来实现的。同一个Pod中的所有容器只会运行在同一Node上。</p>\n<h2 id=\"ReplicationController\"><a href=\"#ReplicationController\" class=\"headerlink\" title=\"ReplicationController\"></a>ReplicationController</h2><p>RC是K8s集群中最早的保证Pod高可用的API对象。通过监控运行中的Pod来保证集群中运行指定数目的Pod副本。指定的数目可以是多个也可以是1个；少于指定数目，RC就会启动运行新的Pod副本；多于指定数目，RC就会杀死多余的Pod副本。即使在指定数目为1的情况下，通过RC运行Pod也比直接运行Pod更明智，因为RC也可以发挥它高可用的能力，保证永远有1个Pod在运行。RC是K8s较早期的技术概念，只适用于长期伺服型的业务类型，比如控制小机器人提供高可用的Web服务。</p>\n<h2 id=\"ReplicaSet\"><a href=\"#ReplicaSet\" class=\"headerlink\" title=\"ReplicaSet\"></a>ReplicaSet</h2><p>RS是新一代RC，提供同样的高可用能力，区别主要在于RS后来居上，能支持更多种类的匹配模式。副本集对象一般不单独使用，而是作为Deployment的理想状态参数使用。</p>\n<h2 id=\"Deployment\"><a href=\"#Deployment\" class=\"headerlink\" title=\"Deployment\"></a>Deployment</h2><p>部署表示用户对K8s集群的一次更新操作。部署是一个比ReplicaSet应用模式更广的API对象，可以是创建一个新的服务，更新一个新的服务，也可以是滚动升级一个服务。滚动升级一个服务，实际是创建一个新的RS，然后逐渐将新RS中副本数增加到理想状态，将旧RS中的副本数减小到0的复合操作；这样一个复合操作用一个ReplicaSet是不太好描述的，所以用一个更通用的Deployment来描述。以K8s的发展方向，未来对所有长期伺服型的的业务的管理，都会通过Deployment来管理。</p>\n<h2 id=\"StatefulSet\"><a href=\"#StatefulSet\" class=\"headerlink\" title=\"StatefulSet\"></a>StatefulSet</h2><p>StatefulSet是为了解决有状态服务的问题（对应Deployments和ReplicaSets是为无状态服务而设计），其应用场景包括:</p>\n<ul>\n<li>稳定的持久化存储，即Pod重新调度后还是能访问到相同的持久化数据，基于PVC来实现</li>\n<li>稳定的网络标志，即Pod重新调度后其PodName和HostName不变，基于Headless Service（即没有Cluster IP的Service）来实现</li>\n<li>有序部署，有序扩展，即Pod是有顺序的，在部署或者扩展的时候要依据定义的顺序依次依次进行（即从0到N-1，在下一个Pod运行之前所有之前的Pod必须都是Running和Ready状态），基于init containers来实现</li>\n<li>有序收缩，有序删除（即从N-1到0）</li>\n</ul>\n<h2 id=\"DaemonSet\"><a href=\"#DaemonSet\" class=\"headerlink\" title=\"DaemonSet\"></a>DaemonSet</h2><p>长期伺服型和批处理型服务的核心在业务应用，可能有些节点运行多个同类业务的Pod，有些节点上又没有这类Pod运行；而后台支撑型服务的核心关注点在K8s集群中的节点（物理机或虚拟机），要保证每个节点上都有一个此类Pod运行。节点可能是所有集群节点也可能是通过nodeSelector选定的一些特定节点。典型的后台支撑型服务包括，存储，日志和监控等在每个节点上支持K8s集群运行的服务。</p>\n<h2 id=\"PersistentVolume\"><a href=\"#PersistentVolume\" class=\"headerlink\" title=\"PersistentVolume\"></a>PersistentVolume</h2><p>PersistentVolumes提供存储的抽象概念，它记录复杂的存储细节（使用的存储驱动及相关配置信息），使得Pod挂载卷可以忽略这些繁杂的细节，可以把一个PersistentVolume看作一个抽象卷。</p>\n<h2 id=\"PersistentVolumeClaim\"><a href=\"#PersistentVolumeClaim\" class=\"headerlink\" title=\"PersistentVolumeClaim\"></a>PersistentVolumeClaim</h2><p>存储的PV和PVC的这种关系，跟计算的Node和Pod的关系是非常类似的；PV和Node是资源的提供者，根据集群的基础设施变化而变化，由K8s集群管理员配置；而PVC和Pod是资源的使用者，根据业务服务的需求变化而变化，有K8s集群的使用者即服务的管理员来配置。</p>\n<h2 id=\"Secret\"><a href=\"#Secret\" class=\"headerlink\" title=\"Secret\"></a>Secret</h2><p>Secret是用来保存和传递密码、密钥、认证凭证这些敏感信息的对象。使用Secret的好处是可以避免把敏感信息明文写在配置文件里。</p>\n<h2 id=\"Namespace\"><a href=\"#Namespace\" class=\"headerlink\" title=\"Namespace\"></a>Namespace</h2><p>名字空间为K8s集群提供虚拟的隔离作用，K8s集群初始有两个名字空间，分别是默认名字空间default和系统名字空间kube-system，除此以外，管理员可以可以创建新的名字空间满足需要。</p>\n<h2 id=\"UserAccount\"><a href=\"#UserAccount\" class=\"headerlink\" title=\"UserAccount\"></a>UserAccount</h2><p>用户帐户为人提供账户标识，记录了权限以及凭证信息。用户帐户对应的是人的身份，人的身份与服务的namespace无关，所以用户账户是跨namespace的。</p>\n<h2 id=\"ServiceAccount\"><a href=\"#ServiceAccount\" class=\"headerlink\" title=\"ServiceAccount\"></a>ServiceAccount</h2><p>服务账户为计算机进程和K8s集群中运行的Pod提供账户标识，只记录了权限信息。服务帐户对应的是一个运行中程序的身份，与特定namespace是相关的。</p>\n<h1 id=\"核心组件\"><a href=\"#核心组件\" class=\"headerlink\" title=\"核心组件\"></a>核心组件</h1><p><img src=\"https://res.cloudinary.com/dukp6c7f7/image/upload/f_auto,fl_lossy,q_auto/s3-ghost/2016/06/o7leok.png\" alt=\"K8s架构图\"></p>\n<h2 id=\"etcd\"><a href=\"#etcd\" class=\"headerlink\" title=\"etcd\"></a>etcd</h2><p>数据库。所有master的持续状态都存在etcd的一个实例中。这可以很好地存储配置数据。因为有watch(观察者)的支持，各部件协调中的改变可以很快被察觉。</p>\n<h2 id=\"apiserver\"><a href=\"#apiserver\" class=\"headerlink\" title=\"apiserver\"></a>apiserver</h2><p>作为K8s集群对外的开放API的门户入口，主要功能有：</p>\n<ul>\n<li>提供整个K8s集群资源增删改查的Restful接口。</li>\n<li>对接口请求进行安全校验。 </li>\n<li>把资源数据持久化到etcd。</li>\n<li>作为资源分配的入口点。scheduler监测到有容器需要创建时，经过sheduler调度算法计算好资源分配策略后需要调用apiserver的接口进行资源的实际分配操作，最终由apiserver向kubelet节点发起容器创建的通知。</li>\n</ul>\n<h2 id=\"controller-manager\"><a href=\"#controller-manager\" class=\"headerlink\" title=\"controller-manager\"></a>controller-manager</h2><p>集群内部的Controller管理中心，内置了多个原生Controller。</p>\n<p>说到controller-manager不得不介绍Controller组件，apiServer对外提供的Restful接口纯粹是对资源数据的增删改查操作，对于资源的部署和维护等逻辑不包含在其中，实际上是Controller通过apiServer监控集群的资源数据变化，发现某个资源数据发生变化时会做出相应的处理逻辑。</p>\n<p>比如：controller-manager中的Replication Controller（不同于资源类型的ReplicationController，为了便于区分接下来我会把资源类型的ReplicationController简称为RC）会检测集群中的POD节点情况，确保RC中的POD数量保持在用户创建RC时指定的副本数，当发现POD宕机时，Replication Controller会重新创建一个新的POD来维持这个副本数；当用户修改了RC的副本数时，Replication Controller也会根据当前RC中POD的数据进行POD的追加或删除。</p>\n<h2 id=\"scheduler\"><a href=\"#scheduler\" class=\"headerlink\" title=\"scheduler\"></a>scheduler</h2><p>Scheduler负责Pod调度。负责接收Controller Manager创建的新的Pod，根据调度策略为其分配一个合适的Node。完整的调度过程为：</p>\n<ol>\n<li>通过调度算法为待调度Pod列表的每个Pod从Node列表中选择一个最适合的Node，并将信息写入etcd中。</li>\n<li>kubelet通过API Server监听到kubernetes Scheduler产生的Pod绑定信息，然后获取对应的Pod清单，下载Image，并启动容器。</li>\n</ol>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7378149-d8078bd4c09c75a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/603/format/webp\" alt=\"scheduler调度过程\"></p>\n<h2 id=\"kubelet\"><a href=\"#kubelet\" class=\"headerlink\" title=\"kubelet\"></a>kubelet</h2><p>kubelet充当K8s worker节点对容器生命周期的管理服务。经过上述scheduler调度策略完成之后，需要真正在对应的Node上创建这个POD，kubelet就是负责这一部分的工作。</p>\n<p>kubelet是基于controller模式实现的（笔者日后会编写关于自定义Controller的文章讲解），它会监听Pod的增删改事件（包括Pod的生命周期变化）、Node自身事件（每个kubelet就是一个Node）以及定时的清理事件。一旦发现监听的数据产生了变化，kubelet会立刻作出相应的业务逻辑，如：scheduler把POD分配给了一个Node，这个Node监听到POD数据修改事件并从最新的POD数据中得知该POD被分配到当前Node中，kubelet判断到当前宿主机资源满足容器创建后就会根据POD的容器配置在宿主机上创建这些容器。</p>\n<h2 id=\"kube-proxy\"><a href=\"#kube-proxy\" class=\"headerlink\" title=\"kube-proxy\"></a>kube-proxy</h2><p>kube-proxy在K8s中主要承担路由转发和负载均衡的工作，具体功能包括：</p>\n<ul>\n<li>管理service的访问入口，包括集群内Pod到Service的访问和集群外访问service。</li>\n<li>管理sevice的Endpoints，该service对外暴露一个Virtual IP，也成为Cluster IP, 集群内通过访问这个Cluster IP:Port就能访问到集群内对应的serivce下的Pod。</li>\n<li>service是通过Selector选择的一组Pods的服务抽象，其实就是一个微服务，提供了服务的LB和反向代理的能力，而kube-proxy的主要作用就是负责service的实现。</li>\n</ul>\n<h2 id=\"kubectl\"><a href=\"#kubectl\" class=\"headerlink\" title=\"kubectl\"></a>kubectl</h2><p>apiserver开放的接口是HTTPS协议的Restful API，不方便用户在控制台直接操作K8s。kubectl就是为了解决这个问题而产生的，用户可以在控制台中通过kubectl封装好的简单命令对K8s集群进行操作（如：kubectl get pod 查询默认命名空间下的pod），kubectl会根据用户输入的命令转化成apiserver Restful API的请求形式再转发给apiserver。</p>\n","site":{"data":{}},"excerpt":"<p>本章介绍K8s核心概念，了解K8s的基本组件及其作用，为后续深入学习做铺垫。</p>","more":"<h1 id=\"资源\"><a href=\"#资源\" class=\"headerlink\" title=\"资源\"></a>资源</h1><h2 id=\"Cluster\"><a href=\"#Cluster\" class=\"headerlink\" title=\"Cluster\"></a>Cluster</h2><p>K8s集群，由上图中的所有组件组成，包含了计算、存储、网络资源。</p>\n<h2 id=\"Node\"><a href=\"#Node\" class=\"headerlink\" title=\"Node\"></a>Node</h2><ul>\n<li>Node：Node指定一台宿主机，可以是物理机或是虚拟机。K8s中节点分为两种：Master Node 与 Worker Node。</li>\n<li>Master Node：对集群做出全局性决策(例如：调度)，以及检测和响应集群事件(副本控制器的replicas字段不满足时,启动新的副本)。包括组件有：kube-apiserver,kube-control-manager,kube-schduler。</li>\n<li>Worker Node：落实容器生命周期管理工作，以及POD的路由转发处理工作。包括组件有：kubelet,kube-proxy。</li>\n</ul>\n<h2 id=\"Pod\"><a href=\"#Pod\" class=\"headerlink\" title=\"Pod\"></a>Pod</h2><p>Pod可以理解为一个虚拟节点，Kubernetes以Pod为最小单元进行调度、扩展、资源共享、管理生命周期。每个Pod中可以包含一个或多个容器，Pod中的所有容器都会共享同一个网络以及文件系统，也就是说Pod中的多个容器不能同时占用同一个Pod端口，K8s会为每个Pod创建一个volume，同一个Pod下多个容器的文件共享就是通过挂载同一个volume来实现的。同一个Pod中的所有容器只会运行在同一Node上。</p>\n<h2 id=\"ReplicationController\"><a href=\"#ReplicationController\" class=\"headerlink\" title=\"ReplicationController\"></a>ReplicationController</h2><p>RC是K8s集群中最早的保证Pod高可用的API对象。通过监控运行中的Pod来保证集群中运行指定数目的Pod副本。指定的数目可以是多个也可以是1个；少于指定数目，RC就会启动运行新的Pod副本；多于指定数目，RC就会杀死多余的Pod副本。即使在指定数目为1的情况下，通过RC运行Pod也比直接运行Pod更明智，因为RC也可以发挥它高可用的能力，保证永远有1个Pod在运行。RC是K8s较早期的技术概念，只适用于长期伺服型的业务类型，比如控制小机器人提供高可用的Web服务。</p>\n<h2 id=\"ReplicaSet\"><a href=\"#ReplicaSet\" class=\"headerlink\" title=\"ReplicaSet\"></a>ReplicaSet</h2><p>RS是新一代RC，提供同样的高可用能力，区别主要在于RS后来居上，能支持更多种类的匹配模式。副本集对象一般不单独使用，而是作为Deployment的理想状态参数使用。</p>\n<h2 id=\"Deployment\"><a href=\"#Deployment\" class=\"headerlink\" title=\"Deployment\"></a>Deployment</h2><p>部署表示用户对K8s集群的一次更新操作。部署是一个比ReplicaSet应用模式更广的API对象，可以是创建一个新的服务，更新一个新的服务，也可以是滚动升级一个服务。滚动升级一个服务，实际是创建一个新的RS，然后逐渐将新RS中副本数增加到理想状态，将旧RS中的副本数减小到0的复合操作；这样一个复合操作用一个ReplicaSet是不太好描述的，所以用一个更通用的Deployment来描述。以K8s的发展方向，未来对所有长期伺服型的的业务的管理，都会通过Deployment来管理。</p>\n<h2 id=\"StatefulSet\"><a href=\"#StatefulSet\" class=\"headerlink\" title=\"StatefulSet\"></a>StatefulSet</h2><p>StatefulSet是为了解决有状态服务的问题（对应Deployments和ReplicaSets是为无状态服务而设计），其应用场景包括:</p>\n<ul>\n<li>稳定的持久化存储，即Pod重新调度后还是能访问到相同的持久化数据，基于PVC来实现</li>\n<li>稳定的网络标志，即Pod重新调度后其PodName和HostName不变，基于Headless Service（即没有Cluster IP的Service）来实现</li>\n<li>有序部署，有序扩展，即Pod是有顺序的，在部署或者扩展的时候要依据定义的顺序依次依次进行（即从0到N-1，在下一个Pod运行之前所有之前的Pod必须都是Running和Ready状态），基于init containers来实现</li>\n<li>有序收缩，有序删除（即从N-1到0）</li>\n</ul>\n<h2 id=\"DaemonSet\"><a href=\"#DaemonSet\" class=\"headerlink\" title=\"DaemonSet\"></a>DaemonSet</h2><p>长期伺服型和批处理型服务的核心在业务应用，可能有些节点运行多个同类业务的Pod，有些节点上又没有这类Pod运行；而后台支撑型服务的核心关注点在K8s集群中的节点（物理机或虚拟机），要保证每个节点上都有一个此类Pod运行。节点可能是所有集群节点也可能是通过nodeSelector选定的一些特定节点。典型的后台支撑型服务包括，存储，日志和监控等在每个节点上支持K8s集群运行的服务。</p>\n<h2 id=\"PersistentVolume\"><a href=\"#PersistentVolume\" class=\"headerlink\" title=\"PersistentVolume\"></a>PersistentVolume</h2><p>PersistentVolumes提供存储的抽象概念，它记录复杂的存储细节（使用的存储驱动及相关配置信息），使得Pod挂载卷可以忽略这些繁杂的细节，可以把一个PersistentVolume看作一个抽象卷。</p>\n<h2 id=\"PersistentVolumeClaim\"><a href=\"#PersistentVolumeClaim\" class=\"headerlink\" title=\"PersistentVolumeClaim\"></a>PersistentVolumeClaim</h2><p>存储的PV和PVC的这种关系，跟计算的Node和Pod的关系是非常类似的；PV和Node是资源的提供者，根据集群的基础设施变化而变化，由K8s集群管理员配置；而PVC和Pod是资源的使用者，根据业务服务的需求变化而变化，有K8s集群的使用者即服务的管理员来配置。</p>\n<h2 id=\"Secret\"><a href=\"#Secret\" class=\"headerlink\" title=\"Secret\"></a>Secret</h2><p>Secret是用来保存和传递密码、密钥、认证凭证这些敏感信息的对象。使用Secret的好处是可以避免把敏感信息明文写在配置文件里。</p>\n<h2 id=\"Namespace\"><a href=\"#Namespace\" class=\"headerlink\" title=\"Namespace\"></a>Namespace</h2><p>名字空间为K8s集群提供虚拟的隔离作用，K8s集群初始有两个名字空间，分别是默认名字空间default和系统名字空间kube-system，除此以外，管理员可以可以创建新的名字空间满足需要。</p>\n<h2 id=\"UserAccount\"><a href=\"#UserAccount\" class=\"headerlink\" title=\"UserAccount\"></a>UserAccount</h2><p>用户帐户为人提供账户标识，记录了权限以及凭证信息。用户帐户对应的是人的身份，人的身份与服务的namespace无关，所以用户账户是跨namespace的。</p>\n<h2 id=\"ServiceAccount\"><a href=\"#ServiceAccount\" class=\"headerlink\" title=\"ServiceAccount\"></a>ServiceAccount</h2><p>服务账户为计算机进程和K8s集群中运行的Pod提供账户标识，只记录了权限信息。服务帐户对应的是一个运行中程序的身份，与特定namespace是相关的。</p>\n<h1 id=\"核心组件\"><a href=\"#核心组件\" class=\"headerlink\" title=\"核心组件\"></a>核心组件</h1><p><img src=\"https://res.cloudinary.com/dukp6c7f7/image/upload/f_auto,fl_lossy,q_auto/s3-ghost/2016/06/o7leok.png\" alt=\"K8s架构图\"></p>\n<h2 id=\"etcd\"><a href=\"#etcd\" class=\"headerlink\" title=\"etcd\"></a>etcd</h2><p>数据库。所有master的持续状态都存在etcd的一个实例中。这可以很好地存储配置数据。因为有watch(观察者)的支持，各部件协调中的改变可以很快被察觉。</p>\n<h2 id=\"apiserver\"><a href=\"#apiserver\" class=\"headerlink\" title=\"apiserver\"></a>apiserver</h2><p>作为K8s集群对外的开放API的门户入口，主要功能有：</p>\n<ul>\n<li>提供整个K8s集群资源增删改查的Restful接口。</li>\n<li>对接口请求进行安全校验。 </li>\n<li>把资源数据持久化到etcd。</li>\n<li>作为资源分配的入口点。scheduler监测到有容器需要创建时，经过sheduler调度算法计算好资源分配策略后需要调用apiserver的接口进行资源的实际分配操作，最终由apiserver向kubelet节点发起容器创建的通知。</li>\n</ul>\n<h2 id=\"controller-manager\"><a href=\"#controller-manager\" class=\"headerlink\" title=\"controller-manager\"></a>controller-manager</h2><p>集群内部的Controller管理中心，内置了多个原生Controller。</p>\n<p>说到controller-manager不得不介绍Controller组件，apiServer对外提供的Restful接口纯粹是对资源数据的增删改查操作，对于资源的部署和维护等逻辑不包含在其中，实际上是Controller通过apiServer监控集群的资源数据变化，发现某个资源数据发生变化时会做出相应的处理逻辑。</p>\n<p>比如：controller-manager中的Replication Controller（不同于资源类型的ReplicationController，为了便于区分接下来我会把资源类型的ReplicationController简称为RC）会检测集群中的POD节点情况，确保RC中的POD数量保持在用户创建RC时指定的副本数，当发现POD宕机时，Replication Controller会重新创建一个新的POD来维持这个副本数；当用户修改了RC的副本数时，Replication Controller也会根据当前RC中POD的数据进行POD的追加或删除。</p>\n<h2 id=\"scheduler\"><a href=\"#scheduler\" class=\"headerlink\" title=\"scheduler\"></a>scheduler</h2><p>Scheduler负责Pod调度。负责接收Controller Manager创建的新的Pod，根据调度策略为其分配一个合适的Node。完整的调度过程为：</p>\n<ol>\n<li>通过调度算法为待调度Pod列表的每个Pod从Node列表中选择一个最适合的Node，并将信息写入etcd中。</li>\n<li>kubelet通过API Server监听到kubernetes Scheduler产生的Pod绑定信息，然后获取对应的Pod清单，下载Image，并启动容器。</li>\n</ol>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/7378149-d8078bd4c09c75a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/603/format/webp\" alt=\"scheduler调度过程\"></p>\n<h2 id=\"kubelet\"><a href=\"#kubelet\" class=\"headerlink\" title=\"kubelet\"></a>kubelet</h2><p>kubelet充当K8s worker节点对容器生命周期的管理服务。经过上述scheduler调度策略完成之后，需要真正在对应的Node上创建这个POD，kubelet就是负责这一部分的工作。</p>\n<p>kubelet是基于controller模式实现的（笔者日后会编写关于自定义Controller的文章讲解），它会监听Pod的增删改事件（包括Pod的生命周期变化）、Node自身事件（每个kubelet就是一个Node）以及定时的清理事件。一旦发现监听的数据产生了变化，kubelet会立刻作出相应的业务逻辑，如：scheduler把POD分配给了一个Node，这个Node监听到POD数据修改事件并从最新的POD数据中得知该POD被分配到当前Node中，kubelet判断到当前宿主机资源满足容器创建后就会根据POD的容器配置在宿主机上创建这些容器。</p>\n<h2 id=\"kube-proxy\"><a href=\"#kube-proxy\" class=\"headerlink\" title=\"kube-proxy\"></a>kube-proxy</h2><p>kube-proxy在K8s中主要承担路由转发和负载均衡的工作，具体功能包括：</p>\n<ul>\n<li>管理service的访问入口，包括集群内Pod到Service的访问和集群外访问service。</li>\n<li>管理sevice的Endpoints，该service对外暴露一个Virtual IP，也成为Cluster IP, 集群内通过访问这个Cluster IP:Port就能访问到集群内对应的serivce下的Pod。</li>\n<li>service是通过Selector选择的一组Pods的服务抽象，其实就是一个微服务，提供了服务的LB和反向代理的能力，而kube-proxy的主要作用就是负责service的实现。</li>\n</ul>\n<h2 id=\"kubectl\"><a href=\"#kubectl\" class=\"headerlink\" title=\"kubectl\"></a>kubectl</h2><p>apiserver开放的接口是HTTPS协议的Restful API，不方便用户在控制台直接操作K8s。kubectl就是为了解决这个问题而产生的，用户可以在控制台中通过kubectl封装好的简单命令对K8s集群进行操作（如：kubectl get pod 查询默认命名空间下的pod），kubectl会根据用户输入的命令转化成apiserver Restful API的请求形式再转发给apiserver。</p>"},{"title":"分布式训练","mathjax":false,"_content":"分布式训练系统架构主要分为两种：Parameter Server Architecture 和 Ring-allreduce Architecture。\n\n<!--more-->\n\n## 1. Parameter Server Architecture（PS架构）\n节点分为两种：Parameter Server与Worker。Server负责存放模型参数，Worker负责计算梯度。每一轮迭代中，Worker会从Server中拉取最新模型参数然后计算训练梯度，每个Worker再把各自训练好的梯度值传回给Server，最后在Server中做聚合运算得出本轮迭代的梯度变化值并进行模型参数更新，接着用新的模型参数开始下一轮的迭代训练。","source":"_drafts/分布式训练.md","raw":"---\ntitle: \"分布式训练\"\ncategory: 算法\nmathjax: false\n---\n分布式训练系统架构主要分为两种：Parameter Server Architecture 和 Ring-allreduce Architecture。\n\n<!--more-->\n\n## 1. Parameter Server Architecture（PS架构）\n节点分为两种：Parameter Server与Worker。Server负责存放模型参数，Worker负责计算梯度。每一轮迭代中，Worker会从Server中拉取最新模型参数然后计算训练梯度，每个Worker再把各自训练好的梯度值传回给Server，最后在Server中做聚合运算得出本轮迭代的梯度变化值并进行模型参数更新，接着用新的模型参数开始下一轮的迭代训练。","slug":"分布式训练","published":0,"date":"2020-01-16T17:23:25.488Z","updated":"2019-09-29T03:23:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck679mts6000slbmd65h071yw","content":"<p>分布式训练系统架构主要分为两种：Parameter Server Architecture 和 Ring-allreduce Architecture。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"1-Parameter-Server-Architecture（PS架构）\"><a href=\"#1-Parameter-Server-Architecture（PS架构）\" class=\"headerlink\" title=\"1. Parameter Server Architecture（PS架构）\"></a>1. Parameter Server Architecture（PS架构）</h2><p>节点分为两种：Parameter Server与Worker。Server负责存放模型参数，Worker负责计算梯度。每一轮迭代中，Worker会从Server中拉取最新模型参数然后计算训练梯度，每个Worker再把各自训练好的梯度值传回给Server，最后在Server中做聚合运算得出本轮迭代的梯度变化值并进行模型参数更新，接着用新的模型参数开始下一轮的迭代训练。</p>\n","site":{"data":{}},"excerpt":"<p>分布式训练系统架构主要分为两种：Parameter Server Architecture 和 Ring-allreduce Architecture。</p>","more":"<h2 id=\"1-Parameter-Server-Architecture（PS架构）\"><a href=\"#1-Parameter-Server-Architecture（PS架构）\" class=\"headerlink\" title=\"1. Parameter Server Architecture（PS架构）\"></a>1. Parameter Server Architecture（PS架构）</h2><p>节点分为两种：Parameter Server与Worker。Server负责存放模型参数，Worker负责计算梯度。每一轮迭代中，Worker会从Server中拉取最新模型参数然后计算训练梯度，每个Worker再把各自训练好的梯度值传回给Server，最后在Server中做聚合运算得出本轮迭代的梯度变化值并进行模型参数更新，接着用新的模型参数开始下一轮的迭代训练。</p>"},{"_content":"<script type=\"text/javascript\" async src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML\"> </script>\n\n# 一、决策树概要\n日常生活中，我们脑海中对一个物体进行分类会用一大堆条件一步步地判断来得出答案，比如要判别一个动物是鸡，还是鹅，还是鸭，或三者都不是。我们会通过一些体征一步步地进行判断，例如：  \n1. 先判断该动物是否有翅膀。如果没有，则三者（鸡、鹅、鸭）都不是  \n2. 判断嘴巴是否扁平。如果不是，则它是鸡  \n3. 判断额部是否有橙黄色或黑褐色肉质突起。如果有，则为鹅；否则为鸭  \n\n这样一步步的条件判断，最终分类出该动物物种的方法，我们可以通过决策树来完成，下面给出该例子的图示：\n\n                           _____________有翅膀____________\n                       有  |                            |  否\n                ________嘴巴扁平________             *不是鸡、鹅、鸭*\n            是  |                     | 否\n        有橙黄色或黑褐色肉质突起          *鸡*\n     是 |                  | 否\n       *鹅*               *鸭*\n\n人类脑海中这样的条件判断其实都是基于对一系列特征数据的学习而得出的结论。决策树就是根据这个原理，从一大堆特征数据以及其对应的分类结果中进行学习并自动求得一棵决策树，过后再遇到同样的分类问题，就可以直接把决策树上的决策条件拿来使用就可以了。\n\n观察上图中的叶子节点，所有叶子节点都是最终分类结果值，算法通过从树的根节点上根据判断条件往下走，走到最终叶子节点即为分类结果。\n\n## 如何评判决策树的好坏？\n下面我们给出几个判断决策树好坏的指标，决策树算法就是针对这些指标建立数学模型，通过数学模型求得最优值，从而得到最优决策方案：\n\n1. 分类不纯。样本根据决策树算法走到了叶子节点进行归类，但依然存在多个不同分类的样本被归类到同一个叶子节点上，这样的决策树是不好的，没办法帮我们起到分类效果。\n2. 树的深度太大。一棵决策树的深度太大，说明判断条件过多，这样的分类及其复杂，不易于理解，效率也不高。\n3. 节点分支太多。为了使得分类够纯净，而对某个节点产生非常多的分支。例如：错误的对ID字段作为特征属性来条件判断，得出了ID=1,2,3...无数多个分支，这样跟没有分类区别不大，并且容易造成训练过拟合。 \n4. 决策树泛化能力差。如果某棵决策树在训练集中训练结果非常完美，但放到实际应用中得到的效果不佳，就是泛化能力差。\n\n## 决策树的优缺点\n\n优点：\n\n1. 可以生成可以理解的规则。\n2. 计算量相对来说不是很大。\n3. 可以处理连续和种类字段。\n4. 决策树可以清晰的显示哪些字段比较重要\n\n缺点：\n\n1. 对连续性的字段比较难预测。\n2. 对有时间顺序的数据，需要很多预处理的工作。\n3. 当类别太多时，错误可能就会增加的比较快。\n4. 一般的算法分类的时候，只是根据一个字段来分类。\n\n\n# 二、预备知识\n\n## 特征\n下文开始，笔者所谓特征就是对分类有影响的“对象属性”。比如上述鸡鸭鹅分类例子中，我们会为该对象设计这样的一些属性：\n\n```\nclass Animal {\n\tint ID\n\tbool 有翅膀\n\tbool 嘴巴扁平\n\tbool 有橙黄色或黑褐色肉质突起\n\tint 年龄\n\tbool 性别\n\t\n\t...\n}\n```\n其中“ID、年龄、性别\"属性对分类没有起到作用，我们就不选取这些属性作为分类**特征**。\n\n## 熵函数\n熵函数标准定义为：\n\n$$\nF(P) = - \\sum^n_{i=1} p_i \\cdot \\log p_i\n\\\\\\\\\ns.t \\space\\space\\space\\space \\sum^n_{i=1} p_i = 1, p_i \\ge 0, i=1,2,…,n\n$$\n\n当 $p_i=\\frac{1}{n}$ 时，熵函数取得最大值，并且n越大熵函数的最大值也随之增大。\n\n## 信息熵\n判断分类纯不纯使用“信息熵”进行判断。\n\n设实际分类总数为*N*，$P(Y|C=c_i)=\\frac{|S_{c_i}|}{|Y|}$ 表示分类i的样本数占整个样本集总数的比率，其中 $S_{c_i}$ 表示样本集Y中分类为$c_i$的子集。\n\n求取信息熵的函数如下：\n\n$$\n\\begin{aligned}\nH(X) &= - \\sum^n_{i=1} P(Y|C=c_i) \\cdot \\log P(Y|C=c_i) \\\\\\\\\n&= - \\sum^n_{i=1} \\frac{|S_{c_i}|}{|Y|} \\cdot \\log \\frac{|S_{c_i}|}{|Y|}\n\\end{aligned}\n$$\n\n当样本集中仅有一种分类的样本时，$H(X)=0$。  \n当样本集中混杂的样本分类数很多，且每个分类的样本数量越平均，H(X)的值越大。即H(X)越大，分类越不纯。\n\n由此，信息熵就作为决策树中节点分类好坏的一个关键评判因素。\n\n## 条件熵\n假设有随机变量(X,Y)，其联合概率分布为: $P(Y|X=x_i)=\\frac{|S^{(x_i)}|}{|Y|}(i=1,2,⋯,m)$\n\n定义 $S^{(x_i)}$ 为样本集Y中特征 $X=x_i$ 的子集，$S_{c_i}^{(x_i)}$ 为 $S_{c_i}$ 中特征 $X=x_i$ 的子集。\n\n则条件熵 $H(Y∣X)$ 表示对给定样本集Y在基于特征X进行分类所得结果的混乱程度：\n$$\n\\begin{aligned}\nH(Y|X) &= \\sum^m_{i=1} P(Y|X=x_i) \\cdot H(Y|X=x_i)\\\\\\\\\n\t\t&= \\sum^m_{i=1} \\frac{|S^{(x_i)}|}{|Y|} \\cdot H(Y|X=x_i)\\\\\\\\\n\t\t&= \\sum^m_{i=1} \\Bigg( \\frac{|S^{(x_i)}|}{|Y|} \\cdot \\bigg( \\sum^n_{i=1} \\frac{|S_{c_i}^{(x_i)}|}{|S_{x_i}|} \\cdot \\log \\frac{|S_{c_i}^{(x_i)}|}{|S_{x_i}|} \\bigg) \\Bigg)\n\\end{aligned}\n$$\n\n这个值越小，说明按照特征X进行分类后所得到的结果越纯净。\n\n## 信息增益\n**信息增益** 表示对给定样本集Y在基于特征X进行分类后所得结果的混乱程度与原样本集Y的混乱程度的差值。\n$$\ng(Y,X)=H(Y)-H(Y|X)\n$$\n\n通过信息增益，我们可以判断对某个节点Y进行再分类时，应采取信息增益最大的特征X进行分类。\n\n# 三、ID3算法\n有了上面的预备知识，接下来讲解ID3算法就非常简单了，和其它机器学习算法一样，ID3算法分为 __训练__ 和 __测试__ 两个过程。\n\n## 训练\nID3的训练过程就是建树过程，其具体步骤如下：\n\n1. 将输入的全部样本作为根节点的样本集，对根节点进行 __步骤2__ 的操作。\n2. 计算当前节点的信息熵，如果其信息熵为0，则 __停止操作__ ；否则，进入 __步骤3__ 。\n3. 若所有特征都被祖先节点用来作为\"分类特征\"，则也 __停止操作__; 否则，进入 __步骤4__\n4. 选取每一个祖先节点未用来作为“分类特征”的特征计算其信息增益。如果所有特征的信息增益都不大于0，则 __停止操作__ ；否则，选取信息增益最大的特征作为该节点的“分类特征”。\n5. 假设分类特征X有N种特征值，则把该节点的样本集分为N份(对于第i份样本集中的特征保证X=xi{i=1,2,…,N})。将这N份样本集作为当前节点的N个子节点，遍历这N个子节点，分别对其进行 __步骤2__ 的操作 (递归操作)。\n\n下面给出建树过程的图示：\n\n```\n                                      Y                  \n                    {c1,c2,c3,c1,c1,c2,c1,c3,c2,c1,...}      g(Y|A)=0.43\n                                      |                      g(Y|B)=1.24     \n                                      |                      g(Y|C)=0.87\n               __________________________________________________\n       B=b1    |               B=b2 |                           |  B=b3\n               |                    |                           |\n              N1                    N2                          N3\n         {c1,c2,...}           {c2,c2,...}                   {c1,c3,...}\ng(N1|A)=0.42  |                  H(N2)=0                        |       g(N1|A)=0.35\ng(N1|C)=0.13  |                                                 |       g(N1|C)=0.51\n         ______________                          ______________________________________\n   A=a1  |            | A=a2                     |           |            |           | \n         |            |                          |           |            |           |\n         |            |                    C=c1  |      C=c2 |            | C=c3      | C=c4\n        N4            N5                        N6          N7           N8           N9\n  {c1,c1,...}     {c2,c2,...}                {c1,..}      {c1,..}      {c3,..}     {c1,c3,..}\n   H(N4)=0          H(N5)=0                  H(N6)=0      H(N7)=0      H(N8)=0        |  H(N7)>0\n                                                                                      |  g(N7|A)>0\n                                                                                      |\n                                                                                  __________\n                                                                                  |        |  \n                                                                            A=a1  |        |  A=a2\n                                                                                  |        |\n                                                                                 N10      N11\n                                                                               {c1,..}  {c3,c3,c3,c1}\n                                                                             H(N10)=0       H(N11)>0\n```\n\n## 测试\nID3算法的测试阶段是根据测试数据的特征值按照树节点的分类特征的分支一直往下走，走到叶子节点就能得到该测试数据的 __预测分类__ 。\n\n算法步骤如下：\n\n1. 按照 _分类特征_ 以及 _测试数据_ 的特征值，选取对应特征值的分支路径，一直往下走，直到叶子节点为止。\n2. 到达叶子节点后，判断该叶子节点的信息熵是否为0。  \n如果为0，说明该节点样本集中的样本分类一致，直接拿样本集中的一个样本的分类作为 __预测结果__ ；如果信息熵不为0，说明该节点样本集中夹杂了多个分类的样本，这时我们取样本集中样本数量最多的分类作为 __预测结果__。\n\n下面给出例子：  \n继续用上图的建好的决策树进行分类测试，假设有一个测试数据：T1={A=a1, B=b1, C=c1}, T2={A=a1,B=b2,C=c1}, T3={A=a2,B=b3,C=c4}。\n\n对于T1的探索路径为：Y -> N1 -> N4。因为H(N4)=0，得出T1的 __预测分类__ 为c1。  \n对于T2的探索路径为：Y -> N2。因为H(N4)=0，得出T2的 __预测分类__ 为c2。  \n对于T3的探索路径为：Y -> N3 -> N9 -> N11。因为H(N11)>0，说明该节点的数据不纯，我们以该节点样本集中数量最多的分类作为T3的 __预测分类__ ，即为c3。\n\n\n# 四、C4.5算法\nC4.5算法与ID3算法的区别在于C4.5算法选择最优分类特征时采用信息增益率代替ID3的信息增益来评判分类的纯度，其余部分完全一样。\n\n但如果同时存在多个特征求得的信息增益量相近，应该优先选择分支数最少的特征。这样分支数较多的特征会留到更底层的节点做划分，越底层的节点熵值越小，甚至到达阈值时就能对其进行剪枝，从而减少整个决策树的分支数量，提升效率以及泛化能力。\n\n为了解决这个问题，C4.5采用**信息增益率**评估选取一个特征进行划分的优劣。\n\n**信息增益率**公式如下：\n\n$$\ng(Y,X)=H(Y)-H(Y|X)\n\\\\\\\\\nS(Y,X) = - \\sum^m_{i=1} \\frac{|S^{(x_i)}|}{|Y|} \\log \\frac{|S^{(x_i)}|}{|Y|}\n\\\\\\\\\nGainRatio(Y,X)= \\frac{g(Y,X)}{S(Y,X)}\n$$\n\n注意，S(Y,X)是熵函数，当分支数m越多，该函数的值就越大，信息增益率就会随之减少。这样C4.5算法就会在信息增益量相近的特征中，优先选取分支数最少的特征进行子集划分，从而解决ID3算法“更倾向于选择分支数较多的特征”的缺陷。\n\n笔者的疑惑：笔者认为“信息增益率函数能使算法优先选择分支数少的特征做子集划分”这个观点不全对，观察一下S(Y,X)函数，即使分支数很多(即m很大)，但是有一个$|S^{(x_i)}|$趋向于1，剩余部分$|S^{(x_i)}|$则趋向于0时，函数S(Y,X)得到的值依然很小，这样一来信息增益率依然很大，会导致挑选了一个分支数非常多的特征进行子集划分。\n\n# 五、CART算法\nCART树是一棵二叉树，每个非叶子节点只划分两个子节点，每个节点上只会把一个特征的特征值分为两个子集。\n\n比如“学历”特征，分别有3个特征值：{本科、硕士、博士}，CART有以下三种可能的分法：\n\n* {本科,硕士}, {博士}\n* {本科,博士}, {硕士}\n* {硕士,博士}, {本科}\n\n分别把两个特征值子集对应的样本分到两个子节点上，而选取哪一种划分方案，需要通过枚举每一种划分方案的__Gini系数__计算完毕后，选取__Gini系数__最小的划分方案为最优划分方案。\t\n\nCART算法采用Gini系数计算衡量分类不纯度。\n\n$$\nGini(Y) = \\sum^n_{i=1} \\frac{|S_{c_i}|}{|Y|} (1 - \\frac{|S_{c_i}|}{|Y|}) = 1 - \\sum^n_{i=1} (\\frac{|S_{c_i}|}{|Y|})^2\n\\\\\\\\\n0 \\le Gini(Y) \\le 1\n$$\n\n划分时，把节点Y的样本集划分为两个集合$S_1$和$S_2$，则对于样本集Y的不纯度计算函数为：\n\n$$\nGAIN(Y) = \\frac{|S_1|}{Y} Gini(S_1) + \\frac{|S_2|}{Y} Gini(S_2)\n$$\n\n而对训练集进行划分时，划分的规则是利用二叉树的表示形式，CART算法的开始是从根节点进行划分，对各个结点进行重复递归的过程：\n\n1. 对于每个结点，计算各个剩余特征的最优分界点，并得到各个特征对应的最小Gini系数。注意：这里的剩余特征X可能在祖先节点处被用做过划分，它们两个节点对特征X的处理区别在于祖先节点中特征X的特征值子集比子节点关于特征X的特征值子集更大。\n2. 选择Gini系数最小的特征按照最优分界点进行分割，分割成两个字节点。\n3. 重复对此结点分割出来的两个子节点进行分割这一过程。\n4. 节点划分的终止条件可以为：节点Gini系数下降到指定阈值、持续到叶结点样本个数极少（如少于5个）、树的深度达到指定阈值等。\n\n## 六、剪枝\n剪枝的作用除了简化决策树构造，提高算法效率之外，更重要的是“防止过拟合”。\n\n防止决策树过拟合的方法就是：在训练时，生成的决策树节点细分程度不要过细，也就是所谓的“训练过度”。\n\n可以设定一些指标的阈值，当决策树的某个指标到达预设的阈值时，即使该叶子节点的分类不纯也停止再细分。\n\n这里给出一些常用的剪枝方案：\n\n1. 节点混乱度(信息增益，信息增益率，Gini系数)下降到指定阈值时，停止对该节点再细分。\n2. 限制树的最大深度。当决策树达到一定深度时，停止对该节点再细分。\n3. 限制节点最小样本数。节点不断细分更多的子节点，层数越低的节点中包含的样本数越少。当节点样本数小于等于指定阈值，则停止对该节点细分。\n\n## 七、随机森林\n这个算法会生成N(可能会有几百棵以上）棵树，这样可以大大的减少单决策树带来的毛病，有点类似于三个臭皮匠等于一个诸葛亮的做法，虽然这几百棵决策树中的每一棵都很简单（相对于C4.5这种单决策树来说），但是他们组合起来确是很强大。\n\n随机森林算法过程如下：\n\n1. 以“有放回”的形式随机抽取目前提供的全部特征中的M个特征出来，然后对取出来的M个特征进行建树。假设原有特征为{A,B,C,D,E,F}，我们有放回的随机抽取4个特征，抽取的结果可能会是{A,C,D,D}、{B,B,B,A}, {A,C,E,F}等，然后根据抽取出来的4个特征用来构建一棵决策树。\n2. 重复步骤1的方法构建N棵决策树，就形成了随机森林。\n3. 当有测试数据传入进行分类预测时，把测试数据分别传入这N棵决策树中进行测试，从而得到N个预测结果。取这N个预测结果中出现频率最高的那个结果作为算法的最终预测值。\n","source":"_drafts/决策树.md","raw":"<script type=\"text/javascript\" async src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML\"> </script>\n\n# 一、决策树概要\n日常生活中，我们脑海中对一个物体进行分类会用一大堆条件一步步地判断来得出答案，比如要判别一个动物是鸡，还是鹅，还是鸭，或三者都不是。我们会通过一些体征一步步地进行判断，例如：  \n1. 先判断该动物是否有翅膀。如果没有，则三者（鸡、鹅、鸭）都不是  \n2. 判断嘴巴是否扁平。如果不是，则它是鸡  \n3. 判断额部是否有橙黄色或黑褐色肉质突起。如果有，则为鹅；否则为鸭  \n\n这样一步步的条件判断，最终分类出该动物物种的方法，我们可以通过决策树来完成，下面给出该例子的图示：\n\n                           _____________有翅膀____________\n                       有  |                            |  否\n                ________嘴巴扁平________             *不是鸡、鹅、鸭*\n            是  |                     | 否\n        有橙黄色或黑褐色肉质突起          *鸡*\n     是 |                  | 否\n       *鹅*               *鸭*\n\n人类脑海中这样的条件判断其实都是基于对一系列特征数据的学习而得出的结论。决策树就是根据这个原理，从一大堆特征数据以及其对应的分类结果中进行学习并自动求得一棵决策树，过后再遇到同样的分类问题，就可以直接把决策树上的决策条件拿来使用就可以了。\n\n观察上图中的叶子节点，所有叶子节点都是最终分类结果值，算法通过从树的根节点上根据判断条件往下走，走到最终叶子节点即为分类结果。\n\n## 如何评判决策树的好坏？\n下面我们给出几个判断决策树好坏的指标，决策树算法就是针对这些指标建立数学模型，通过数学模型求得最优值，从而得到最优决策方案：\n\n1. 分类不纯。样本根据决策树算法走到了叶子节点进行归类，但依然存在多个不同分类的样本被归类到同一个叶子节点上，这样的决策树是不好的，没办法帮我们起到分类效果。\n2. 树的深度太大。一棵决策树的深度太大，说明判断条件过多，这样的分类及其复杂，不易于理解，效率也不高。\n3. 节点分支太多。为了使得分类够纯净，而对某个节点产生非常多的分支。例如：错误的对ID字段作为特征属性来条件判断，得出了ID=1,2,3...无数多个分支，这样跟没有分类区别不大，并且容易造成训练过拟合。 \n4. 决策树泛化能力差。如果某棵决策树在训练集中训练结果非常完美，但放到实际应用中得到的效果不佳，就是泛化能力差。\n\n## 决策树的优缺点\n\n优点：\n\n1. 可以生成可以理解的规则。\n2. 计算量相对来说不是很大。\n3. 可以处理连续和种类字段。\n4. 决策树可以清晰的显示哪些字段比较重要\n\n缺点：\n\n1. 对连续性的字段比较难预测。\n2. 对有时间顺序的数据，需要很多预处理的工作。\n3. 当类别太多时，错误可能就会增加的比较快。\n4. 一般的算法分类的时候，只是根据一个字段来分类。\n\n\n# 二、预备知识\n\n## 特征\n下文开始，笔者所谓特征就是对分类有影响的“对象属性”。比如上述鸡鸭鹅分类例子中，我们会为该对象设计这样的一些属性：\n\n```\nclass Animal {\n\tint ID\n\tbool 有翅膀\n\tbool 嘴巴扁平\n\tbool 有橙黄色或黑褐色肉质突起\n\tint 年龄\n\tbool 性别\n\t\n\t...\n}\n```\n其中“ID、年龄、性别\"属性对分类没有起到作用，我们就不选取这些属性作为分类**特征**。\n\n## 熵函数\n熵函数标准定义为：\n\n$$\nF(P) = - \\sum^n_{i=1} p_i \\cdot \\log p_i\n\\\\\\\\\ns.t \\space\\space\\space\\space \\sum^n_{i=1} p_i = 1, p_i \\ge 0, i=1,2,…,n\n$$\n\n当 $p_i=\\frac{1}{n}$ 时，熵函数取得最大值，并且n越大熵函数的最大值也随之增大。\n\n## 信息熵\n判断分类纯不纯使用“信息熵”进行判断。\n\n设实际分类总数为*N*，$P(Y|C=c_i)=\\frac{|S_{c_i}|}{|Y|}$ 表示分类i的样本数占整个样本集总数的比率，其中 $S_{c_i}$ 表示样本集Y中分类为$c_i$的子集。\n\n求取信息熵的函数如下：\n\n$$\n\\begin{aligned}\nH(X) &= - \\sum^n_{i=1} P(Y|C=c_i) \\cdot \\log P(Y|C=c_i) \\\\\\\\\n&= - \\sum^n_{i=1} \\frac{|S_{c_i}|}{|Y|} \\cdot \\log \\frac{|S_{c_i}|}{|Y|}\n\\end{aligned}\n$$\n\n当样本集中仅有一种分类的样本时，$H(X)=0$。  \n当样本集中混杂的样本分类数很多，且每个分类的样本数量越平均，H(X)的值越大。即H(X)越大，分类越不纯。\n\n由此，信息熵就作为决策树中节点分类好坏的一个关键评判因素。\n\n## 条件熵\n假设有随机变量(X,Y)，其联合概率分布为: $P(Y|X=x_i)=\\frac{|S^{(x_i)}|}{|Y|}(i=1,2,⋯,m)$\n\n定义 $S^{(x_i)}$ 为样本集Y中特征 $X=x_i$ 的子集，$S_{c_i}^{(x_i)}$ 为 $S_{c_i}$ 中特征 $X=x_i$ 的子集。\n\n则条件熵 $H(Y∣X)$ 表示对给定样本集Y在基于特征X进行分类所得结果的混乱程度：\n$$\n\\begin{aligned}\nH(Y|X) &= \\sum^m_{i=1} P(Y|X=x_i) \\cdot H(Y|X=x_i)\\\\\\\\\n\t\t&= \\sum^m_{i=1} \\frac{|S^{(x_i)}|}{|Y|} \\cdot H(Y|X=x_i)\\\\\\\\\n\t\t&= \\sum^m_{i=1} \\Bigg( \\frac{|S^{(x_i)}|}{|Y|} \\cdot \\bigg( \\sum^n_{i=1} \\frac{|S_{c_i}^{(x_i)}|}{|S_{x_i}|} \\cdot \\log \\frac{|S_{c_i}^{(x_i)}|}{|S_{x_i}|} \\bigg) \\Bigg)\n\\end{aligned}\n$$\n\n这个值越小，说明按照特征X进行分类后所得到的结果越纯净。\n\n## 信息增益\n**信息增益** 表示对给定样本集Y在基于特征X进行分类后所得结果的混乱程度与原样本集Y的混乱程度的差值。\n$$\ng(Y,X)=H(Y)-H(Y|X)\n$$\n\n通过信息增益，我们可以判断对某个节点Y进行再分类时，应采取信息增益最大的特征X进行分类。\n\n# 三、ID3算法\n有了上面的预备知识，接下来讲解ID3算法就非常简单了，和其它机器学习算法一样，ID3算法分为 __训练__ 和 __测试__ 两个过程。\n\n## 训练\nID3的训练过程就是建树过程，其具体步骤如下：\n\n1. 将输入的全部样本作为根节点的样本集，对根节点进行 __步骤2__ 的操作。\n2. 计算当前节点的信息熵，如果其信息熵为0，则 __停止操作__ ；否则，进入 __步骤3__ 。\n3. 若所有特征都被祖先节点用来作为\"分类特征\"，则也 __停止操作__; 否则，进入 __步骤4__\n4. 选取每一个祖先节点未用来作为“分类特征”的特征计算其信息增益。如果所有特征的信息增益都不大于0，则 __停止操作__ ；否则，选取信息增益最大的特征作为该节点的“分类特征”。\n5. 假设分类特征X有N种特征值，则把该节点的样本集分为N份(对于第i份样本集中的特征保证X=xi{i=1,2,…,N})。将这N份样本集作为当前节点的N个子节点，遍历这N个子节点，分别对其进行 __步骤2__ 的操作 (递归操作)。\n\n下面给出建树过程的图示：\n\n```\n                                      Y                  \n                    {c1,c2,c3,c1,c1,c2,c1,c3,c2,c1,...}      g(Y|A)=0.43\n                                      |                      g(Y|B)=1.24     \n                                      |                      g(Y|C)=0.87\n               __________________________________________________\n       B=b1    |               B=b2 |                           |  B=b3\n               |                    |                           |\n              N1                    N2                          N3\n         {c1,c2,...}           {c2,c2,...}                   {c1,c3,...}\ng(N1|A)=0.42  |                  H(N2)=0                        |       g(N1|A)=0.35\ng(N1|C)=0.13  |                                                 |       g(N1|C)=0.51\n         ______________                          ______________________________________\n   A=a1  |            | A=a2                     |           |            |           | \n         |            |                          |           |            |           |\n         |            |                    C=c1  |      C=c2 |            | C=c3      | C=c4\n        N4            N5                        N6          N7           N8           N9\n  {c1,c1,...}     {c2,c2,...}                {c1,..}      {c1,..}      {c3,..}     {c1,c3,..}\n   H(N4)=0          H(N5)=0                  H(N6)=0      H(N7)=0      H(N8)=0        |  H(N7)>0\n                                                                                      |  g(N7|A)>0\n                                                                                      |\n                                                                                  __________\n                                                                                  |        |  \n                                                                            A=a1  |        |  A=a2\n                                                                                  |        |\n                                                                                 N10      N11\n                                                                               {c1,..}  {c3,c3,c3,c1}\n                                                                             H(N10)=0       H(N11)>0\n```\n\n## 测试\nID3算法的测试阶段是根据测试数据的特征值按照树节点的分类特征的分支一直往下走，走到叶子节点就能得到该测试数据的 __预测分类__ 。\n\n算法步骤如下：\n\n1. 按照 _分类特征_ 以及 _测试数据_ 的特征值，选取对应特征值的分支路径，一直往下走，直到叶子节点为止。\n2. 到达叶子节点后，判断该叶子节点的信息熵是否为0。  \n如果为0，说明该节点样本集中的样本分类一致，直接拿样本集中的一个样本的分类作为 __预测结果__ ；如果信息熵不为0，说明该节点样本集中夹杂了多个分类的样本，这时我们取样本集中样本数量最多的分类作为 __预测结果__。\n\n下面给出例子：  \n继续用上图的建好的决策树进行分类测试，假设有一个测试数据：T1={A=a1, B=b1, C=c1}, T2={A=a1,B=b2,C=c1}, T3={A=a2,B=b3,C=c4}。\n\n对于T1的探索路径为：Y -> N1 -> N4。因为H(N4)=0，得出T1的 __预测分类__ 为c1。  \n对于T2的探索路径为：Y -> N2。因为H(N4)=0，得出T2的 __预测分类__ 为c2。  \n对于T3的探索路径为：Y -> N3 -> N9 -> N11。因为H(N11)>0，说明该节点的数据不纯，我们以该节点样本集中数量最多的分类作为T3的 __预测分类__ ，即为c3。\n\n\n# 四、C4.5算法\nC4.5算法与ID3算法的区别在于C4.5算法选择最优分类特征时采用信息增益率代替ID3的信息增益来评判分类的纯度，其余部分完全一样。\n\n但如果同时存在多个特征求得的信息增益量相近，应该优先选择分支数最少的特征。这样分支数较多的特征会留到更底层的节点做划分，越底层的节点熵值越小，甚至到达阈值时就能对其进行剪枝，从而减少整个决策树的分支数量，提升效率以及泛化能力。\n\n为了解决这个问题，C4.5采用**信息增益率**评估选取一个特征进行划分的优劣。\n\n**信息增益率**公式如下：\n\n$$\ng(Y,X)=H(Y)-H(Y|X)\n\\\\\\\\\nS(Y,X) = - \\sum^m_{i=1} \\frac{|S^{(x_i)}|}{|Y|} \\log \\frac{|S^{(x_i)}|}{|Y|}\n\\\\\\\\\nGainRatio(Y,X)= \\frac{g(Y,X)}{S(Y,X)}\n$$\n\n注意，S(Y,X)是熵函数，当分支数m越多，该函数的值就越大，信息增益率就会随之减少。这样C4.5算法就会在信息增益量相近的特征中，优先选取分支数最少的特征进行子集划分，从而解决ID3算法“更倾向于选择分支数较多的特征”的缺陷。\n\n笔者的疑惑：笔者认为“信息增益率函数能使算法优先选择分支数少的特征做子集划分”这个观点不全对，观察一下S(Y,X)函数，即使分支数很多(即m很大)，但是有一个$|S^{(x_i)}|$趋向于1，剩余部分$|S^{(x_i)}|$则趋向于0时，函数S(Y,X)得到的值依然很小，这样一来信息增益率依然很大，会导致挑选了一个分支数非常多的特征进行子集划分。\n\n# 五、CART算法\nCART树是一棵二叉树，每个非叶子节点只划分两个子节点，每个节点上只会把一个特征的特征值分为两个子集。\n\n比如“学历”特征，分别有3个特征值：{本科、硕士、博士}，CART有以下三种可能的分法：\n\n* {本科,硕士}, {博士}\n* {本科,博士}, {硕士}\n* {硕士,博士}, {本科}\n\n分别把两个特征值子集对应的样本分到两个子节点上，而选取哪一种划分方案，需要通过枚举每一种划分方案的__Gini系数__计算完毕后，选取__Gini系数__最小的划分方案为最优划分方案。\t\n\nCART算法采用Gini系数计算衡量分类不纯度。\n\n$$\nGini(Y) = \\sum^n_{i=1} \\frac{|S_{c_i}|}{|Y|} (1 - \\frac{|S_{c_i}|}{|Y|}) = 1 - \\sum^n_{i=1} (\\frac{|S_{c_i}|}{|Y|})^2\n\\\\\\\\\n0 \\le Gini(Y) \\le 1\n$$\n\n划分时，把节点Y的样本集划分为两个集合$S_1$和$S_2$，则对于样本集Y的不纯度计算函数为：\n\n$$\nGAIN(Y) = \\frac{|S_1|}{Y} Gini(S_1) + \\frac{|S_2|}{Y} Gini(S_2)\n$$\n\n而对训练集进行划分时，划分的规则是利用二叉树的表示形式，CART算法的开始是从根节点进行划分，对各个结点进行重复递归的过程：\n\n1. 对于每个结点，计算各个剩余特征的最优分界点，并得到各个特征对应的最小Gini系数。注意：这里的剩余特征X可能在祖先节点处被用做过划分，它们两个节点对特征X的处理区别在于祖先节点中特征X的特征值子集比子节点关于特征X的特征值子集更大。\n2. 选择Gini系数最小的特征按照最优分界点进行分割，分割成两个字节点。\n3. 重复对此结点分割出来的两个子节点进行分割这一过程。\n4. 节点划分的终止条件可以为：节点Gini系数下降到指定阈值、持续到叶结点样本个数极少（如少于5个）、树的深度达到指定阈值等。\n\n## 六、剪枝\n剪枝的作用除了简化决策树构造，提高算法效率之外，更重要的是“防止过拟合”。\n\n防止决策树过拟合的方法就是：在训练时，生成的决策树节点细分程度不要过细，也就是所谓的“训练过度”。\n\n可以设定一些指标的阈值，当决策树的某个指标到达预设的阈值时，即使该叶子节点的分类不纯也停止再细分。\n\n这里给出一些常用的剪枝方案：\n\n1. 节点混乱度(信息增益，信息增益率，Gini系数)下降到指定阈值时，停止对该节点再细分。\n2. 限制树的最大深度。当决策树达到一定深度时，停止对该节点再细分。\n3. 限制节点最小样本数。节点不断细分更多的子节点，层数越低的节点中包含的样本数越少。当节点样本数小于等于指定阈值，则停止对该节点细分。\n\n## 七、随机森林\n这个算法会生成N(可能会有几百棵以上）棵树，这样可以大大的减少单决策树带来的毛病，有点类似于三个臭皮匠等于一个诸葛亮的做法，虽然这几百棵决策树中的每一棵都很简单（相对于C4.5这种单决策树来说），但是他们组合起来确是很强大。\n\n随机森林算法过程如下：\n\n1. 以“有放回”的形式随机抽取目前提供的全部特征中的M个特征出来，然后对取出来的M个特征进行建树。假设原有特征为{A,B,C,D,E,F}，我们有放回的随机抽取4个特征，抽取的结果可能会是{A,C,D,D}、{B,B,B,A}, {A,C,E,F}等，然后根据抽取出来的4个特征用来构建一棵决策树。\n2. 重复步骤1的方法构建N棵决策树，就形成了随机森林。\n3. 当有测试数据传入进行分类预测时，把测试数据分别传入这N棵决策树中进行测试，从而得到N个预测结果。取这N个预测结果中出现频率最高的那个结果作为算法的最终预测值。\n","slug":"决策树","published":0,"date":"2020-01-23T07:05:52.988Z","updated":"2018-06-08T00:03:43.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ck679mts7000ulbmd8n1tetax","content":"<script type=\"text/javascript\" async src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML\"> </script>\n\n<h1 id=\"一、决策树概要\"><a href=\"#一、决策树概要\" class=\"headerlink\" title=\"一、决策树概要\"></a>一、决策树概要</h1><p>日常生活中，我们脑海中对一个物体进行分类会用一大堆条件一步步地判断来得出答案，比如要判别一个动物是鸡，还是鹅，还是鸭，或三者都不是。我们会通过一些体征一步步地进行判断，例如：  </p>\n<ol>\n<li>先判断该动物是否有翅膀。如果没有，则三者（鸡、鹅、鸭）都不是  </li>\n<li>判断嘴巴是否扁平。如果不是，则它是鸡  </li>\n<li>判断额部是否有橙黄色或黑褐色肉质突起。如果有，则为鹅；否则为鸭  </li>\n</ol>\n<p>这样一步步的条件判断，最终分类出该动物物种的方法，我们可以通过决策树来完成，下面给出该例子的图示：</p>\n<pre><code>                      _____________有翅膀____________\n                  有  |                            |  否\n           ________嘴巴扁平________             *不是鸡、鹅、鸭*\n       是  |                     | 否\n   有橙黄色或黑褐色肉质突起          *鸡*\n是 |                  | 否\n  *鹅*               *鸭*</code></pre><p>人类脑海中这样的条件判断其实都是基于对一系列特征数据的学习而得出的结论。决策树就是根据这个原理，从一大堆特征数据以及其对应的分类结果中进行学习并自动求得一棵决策树，过后再遇到同样的分类问题，就可以直接把决策树上的决策条件拿来使用就可以了。</p>\n<p>观察上图中的叶子节点，所有叶子节点都是最终分类结果值，算法通过从树的根节点上根据判断条件往下走，走到最终叶子节点即为分类结果。</p>\n<h2 id=\"如何评判决策树的好坏？\"><a href=\"#如何评判决策树的好坏？\" class=\"headerlink\" title=\"如何评判决策树的好坏？\"></a>如何评判决策树的好坏？</h2><p>下面我们给出几个判断决策树好坏的指标，决策树算法就是针对这些指标建立数学模型，通过数学模型求得最优值，从而得到最优决策方案：</p>\n<ol>\n<li>分类不纯。样本根据决策树算法走到了叶子节点进行归类，但依然存在多个不同分类的样本被归类到同一个叶子节点上，这样的决策树是不好的，没办法帮我们起到分类效果。</li>\n<li>树的深度太大。一棵决策树的深度太大，说明判断条件过多，这样的分类及其复杂，不易于理解，效率也不高。</li>\n<li>节点分支太多。为了使得分类够纯净，而对某个节点产生非常多的分支。例如：错误的对ID字段作为特征属性来条件判断，得出了ID=1,2,3…无数多个分支，这样跟没有分类区别不大，并且容易造成训练过拟合。 </li>\n<li>决策树泛化能力差。如果某棵决策树在训练集中训练结果非常完美，但放到实际应用中得到的效果不佳，就是泛化能力差。</li>\n</ol>\n<h2 id=\"决策树的优缺点\"><a href=\"#决策树的优缺点\" class=\"headerlink\" title=\"决策树的优缺点\"></a>决策树的优缺点</h2><p>优点：</p>\n<ol>\n<li>可以生成可以理解的规则。</li>\n<li>计算量相对来说不是很大。</li>\n<li>可以处理连续和种类字段。</li>\n<li>决策树可以清晰的显示哪些字段比较重要</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>对连续性的字段比较难预测。</li>\n<li>对有时间顺序的数据，需要很多预处理的工作。</li>\n<li>当类别太多时，错误可能就会增加的比较快。</li>\n<li>一般的算法分类的时候，只是根据一个字段来分类。</li>\n</ol>\n<h1 id=\"二、预备知识\"><a href=\"#二、预备知识\" class=\"headerlink\" title=\"二、预备知识\"></a>二、预备知识</h1><h2 id=\"特征\"><a href=\"#特征\" class=\"headerlink\" title=\"特征\"></a>特征</h2><p>下文开始，笔者所谓特征就是对分类有影响的“对象属性”。比如上述鸡鸭鹅分类例子中，我们会为该对象设计这样的一些属性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Animal &#123;</span><br><span class=\"line\">\tint ID</span><br><span class=\"line\">\tbool 有翅膀</span><br><span class=\"line\">\tbool 嘴巴扁平</span><br><span class=\"line\">\tbool 有橙黄色或黑褐色肉质突起</span><br><span class=\"line\">\tint 年龄</span><br><span class=\"line\">\tbool 性别</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中“ID、年龄、性别”属性对分类没有起到作用，我们就不选取这些属性作为分类<strong>特征</strong>。</p>\n<h2 id=\"熵函数\"><a href=\"#熵函数\" class=\"headerlink\" title=\"熵函数\"></a>熵函数</h2><p>熵函数标准定义为：</p>\n<p>$$<br>F(P) = - \\sum^n_{i=1} p_i \\cdot \\log p_i<br>\\\\<br>s.t \\space\\space\\space\\space \\sum^n_{i=1} p_i = 1, p_i \\ge 0, i=1,2,…,n<br>$$</p>\n<p>当 $p_i=\\frac{1}{n}$ 时，熵函数取得最大值，并且n越大熵函数的最大值也随之增大。</p>\n<h2 id=\"信息熵\"><a href=\"#信息熵\" class=\"headerlink\" title=\"信息熵\"></a>信息熵</h2><p>判断分类纯不纯使用“信息熵”进行判断。</p>\n<p>设实际分类总数为<em>N</em>，$P(Y|C=c_i)=\\frac{|S_{c_i}|}{|Y|}$ 表示分类i的样本数占整个样本集总数的比率，其中 $S_{c_i}$ 表示样本集Y中分类为$c_i$的子集。</p>\n<p>求取信息熵的函数如下：</p>\n<p>$$<br>\\begin{aligned}<br>H(X) &amp;= - \\sum^n_{i=1} P(Y|C=c_i) \\cdot \\log P(Y|C=c_i) \\\\<br>&amp;= - \\sum^n_{i=1} \\frac{|S_{c_i}|}{|Y|} \\cdot \\log \\frac{|S_{c_i}|}{|Y|}<br>\\end{aligned}<br>$$</p>\n<p>当样本集中仅有一种分类的样本时，$H(X)=0$。<br>当样本集中混杂的样本分类数很多，且每个分类的样本数量越平均，H(X)的值越大。即H(X)越大，分类越不纯。</p>\n<p>由此，信息熵就作为决策树中节点分类好坏的一个关键评判因素。</p>\n<h2 id=\"条件熵\"><a href=\"#条件熵\" class=\"headerlink\" title=\"条件熵\"></a>条件熵</h2><p>假设有随机变量(X,Y)，其联合概率分布为: $P(Y|X=x_i)=\\frac{|S^{(x_i)}|}{|Y|}(i=1,2,⋯,m)$</p>\n<p>定义 $S^{(x_i)}$ 为样本集Y中特征 $X=x_i$ 的子集，$S_{c_i}^{(x_i)}$ 为 $S_{c_i}$ 中特征 $X=x_i$ 的子集。</p>\n<p>则条件熵 $H(Y∣X)$ 表示对给定样本集Y在基于特征X进行分类所得结果的混乱程度：<br>$$<br>\\begin{aligned}<br>H(Y|X) &amp;= \\sum^m_{i=1} P(Y|X=x_i) \\cdot H(Y|X=x_i)\\\\<br>        &amp;= \\sum^m_{i=1} \\frac{|S^{(x_i)}|}{|Y|} \\cdot H(Y|X=x_i)\\\\<br>        &amp;= \\sum^m_{i=1} \\Bigg( \\frac{|S^{(x_i)}|}{|Y|} \\cdot \\bigg( \\sum^n_{i=1} \\frac{|S_{c_i}^{(x_i)}|}{|S_{x_i}|} \\cdot \\log \\frac{|S_{c_i}^{(x_i)}|}{|S_{x_i}|} \\bigg) \\Bigg)<br>\\end{aligned}<br>$$</p>\n<p>这个值越小，说明按照特征X进行分类后所得到的结果越纯净。</p>\n<h2 id=\"信息增益\"><a href=\"#信息增益\" class=\"headerlink\" title=\"信息增益\"></a>信息增益</h2><p><strong>信息增益</strong> 表示对给定样本集Y在基于特征X进行分类后所得结果的混乱程度与原样本集Y的混乱程度的差值。<br>$$<br>g(Y,X)=H(Y)-H(Y|X)<br>$$</p>\n<p>通过信息增益，我们可以判断对某个节点Y进行再分类时，应采取信息增益最大的特征X进行分类。</p>\n<h1 id=\"三、ID3算法\"><a href=\"#三、ID3算法\" class=\"headerlink\" title=\"三、ID3算法\"></a>三、ID3算法</h1><p>有了上面的预备知识，接下来讲解ID3算法就非常简单了，和其它机器学习算法一样，ID3算法分为 <strong>训练</strong> 和 <strong>测试</strong> 两个过程。</p>\n<h2 id=\"训练\"><a href=\"#训练\" class=\"headerlink\" title=\"训练\"></a>训练</h2><p>ID3的训练过程就是建树过程，其具体步骤如下：</p>\n<ol>\n<li>将输入的全部样本作为根节点的样本集，对根节点进行 <strong>步骤2</strong> 的操作。</li>\n<li>计算当前节点的信息熵，如果其信息熵为0，则 <strong>停止操作</strong> ；否则，进入 <strong>步骤3</strong> 。</li>\n<li>若所有特征都被祖先节点用来作为”分类特征”，则也 <strong>停止操作</strong>; 否则，进入 <strong>步骤4</strong></li>\n<li>选取每一个祖先节点未用来作为“分类特征”的特征计算其信息增益。如果所有特征的信息增益都不大于0，则 <strong>停止操作</strong> ；否则，选取信息增益最大的特征作为该节点的“分类特征”。</li>\n<li>假设分类特征X有N种特征值，则把该节点的样本集分为N份(对于第i份样本集中的特征保证X=xi{i=1,2,…,N})。将这N份样本集作为当前节点的N个子节点，遍历这N个子节点，分别对其进行 <strong>步骤2</strong> 的操作 (递归操作)。</li>\n</ol>\n<p>下面给出建树过程的图示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                                      Y                  </span><br><span class=\"line\">                    &#123;c1,c2,c3,c1,c1,c2,c1,c3,c2,c1,...&#125;      g(Y|A)=0.43</span><br><span class=\"line\">                                      |                      g(Y|B)=1.24     </span><br><span class=\"line\">                                      |                      g(Y|C)=0.87</span><br><span class=\"line\">               __________________________________________________</span><br><span class=\"line\">       B=b1    |               B=b2 |                           |  B=b3</span><br><span class=\"line\">               |                    |                           |</span><br><span class=\"line\">              N1                    N2                          N3</span><br><span class=\"line\">         &#123;c1,c2,...&#125;           &#123;c2,c2,...&#125;                   &#123;c1,c3,...&#125;</span><br><span class=\"line\">g(N1|A)=0.42  |                  H(N2)=0                        |       g(N1|A)=0.35</span><br><span class=\"line\">g(N1|C)=0.13  |                                                 |       g(N1|C)=0.51</span><br><span class=\"line\">         ______________                          ______________________________________</span><br><span class=\"line\">   A=a1  |            | A=a2                     |           |            |           | </span><br><span class=\"line\">         |            |                          |           |            |           |</span><br><span class=\"line\">         |            |                    C=c1  |      C=c2 |            | C=c3      | C=c4</span><br><span class=\"line\">        N4            N5                        N6          N7           N8           N9</span><br><span class=\"line\">  &#123;c1,c1,...&#125;     &#123;c2,c2,...&#125;                &#123;c1,..&#125;      &#123;c1,..&#125;      &#123;c3,..&#125;     &#123;c1,c3,..&#125;</span><br><span class=\"line\">   H(N4)=0          H(N5)=0                  H(N6)=0      H(N7)=0      H(N8)=0        |  H(N7)&gt;0</span><br><span class=\"line\">                                                                                      |  g(N7|A)&gt;0</span><br><span class=\"line\">                                                                                      |</span><br><span class=\"line\">                                                                                  __________</span><br><span class=\"line\">                                                                                  |        |  </span><br><span class=\"line\">                                                                            A=a1  |        |  A=a2</span><br><span class=\"line\">                                                                                  |        |</span><br><span class=\"line\">                                                                                 N10      N11</span><br><span class=\"line\">                                                                               &#123;c1,..&#125;  &#123;c3,c3,c3,c1&#125;</span><br><span class=\"line\">                                                                             H(N10)=0       H(N11)&gt;0</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>ID3算法的测试阶段是根据测试数据的特征值按照树节点的分类特征的分支一直往下走，走到叶子节点就能得到该测试数据的 <strong>预测分类</strong> 。</p>\n<p>算法步骤如下：</p>\n<ol>\n<li>按照 <em>分类特征</em> 以及 <em>测试数据</em> 的特征值，选取对应特征值的分支路径，一直往下走，直到叶子节点为止。</li>\n<li>到达叶子节点后，判断该叶子节点的信息熵是否为0。<br>如果为0，说明该节点样本集中的样本分类一致，直接拿样本集中的一个样本的分类作为 <strong>预测结果</strong> ；如果信息熵不为0，说明该节点样本集中夹杂了多个分类的样本，这时我们取样本集中样本数量最多的分类作为 <strong>预测结果</strong>。</li>\n</ol>\n<p>下面给出例子：<br>继续用上图的建好的决策树进行分类测试，假设有一个测试数据：T1={A=a1, B=b1, C=c1}, T2={A=a1,B=b2,C=c1}, T3={A=a2,B=b3,C=c4}。</p>\n<p>对于T1的探索路径为：Y -&gt; N1 -&gt; N4。因为H(N4)=0，得出T1的 <strong>预测分类</strong> 为c1。<br>对于T2的探索路径为：Y -&gt; N2。因为H(N4)=0，得出T2的 <strong>预测分类</strong> 为c2。<br>对于T3的探索路径为：Y -&gt; N3 -&gt; N9 -&gt; N11。因为H(N11)&gt;0，说明该节点的数据不纯，我们以该节点样本集中数量最多的分类作为T3的 <strong>预测分类</strong> ，即为c3。</p>\n<h1 id=\"四、C4-5算法\"><a href=\"#四、C4-5算法\" class=\"headerlink\" title=\"四、C4.5算法\"></a>四、C4.5算法</h1><p>C4.5算法与ID3算法的区别在于C4.5算法选择最优分类特征时采用信息增益率代替ID3的信息增益来评判分类的纯度，其余部分完全一样。</p>\n<p>但如果同时存在多个特征求得的信息增益量相近，应该优先选择分支数最少的特征。这样分支数较多的特征会留到更底层的节点做划分，越底层的节点熵值越小，甚至到达阈值时就能对其进行剪枝，从而减少整个决策树的分支数量，提升效率以及泛化能力。</p>\n<p>为了解决这个问题，C4.5采用<strong>信息增益率</strong>评估选取一个特征进行划分的优劣。</p>\n<p><strong>信息增益率</strong>公式如下：</p>\n<p>$$<br>g(Y,X)=H(Y)-H(Y|X)<br>\\\\<br>S(Y,X) = - \\sum^m_{i=1} \\frac{|S^{(x_i)}|}{|Y|} \\log \\frac{|S^{(x_i)}|}{|Y|}<br>\\\\<br>GainRatio(Y,X)= \\frac{g(Y,X)}{S(Y,X)}<br>$$</p>\n<p>注意，S(Y,X)是熵函数，当分支数m越多，该函数的值就越大，信息增益率就会随之减少。这样C4.5算法就会在信息增益量相近的特征中，优先选取分支数最少的特征进行子集划分，从而解决ID3算法“更倾向于选择分支数较多的特征”的缺陷。</p>\n<p>笔者的疑惑：笔者认为“信息增益率函数能使算法优先选择分支数少的特征做子集划分”这个观点不全对，观察一下S(Y,X)函数，即使分支数很多(即m很大)，但是有一个$|S^{(x_i)}|$趋向于1，剩余部分$|S^{(x_i)}|$则趋向于0时，函数S(Y,X)得到的值依然很小，这样一来信息增益率依然很大，会导致挑选了一个分支数非常多的特征进行子集划分。</p>\n<h1 id=\"五、CART算法\"><a href=\"#五、CART算法\" class=\"headerlink\" title=\"五、CART算法\"></a>五、CART算法</h1><p>CART树是一棵二叉树，每个非叶子节点只划分两个子节点，每个节点上只会把一个特征的特征值分为两个子集。</p>\n<p>比如“学历”特征，分别有3个特征值：{本科、硕士、博士}，CART有以下三种可能的分法：</p>\n<ul>\n<li>{本科,硕士}, {博士}</li>\n<li>{本科,博士}, {硕士}</li>\n<li>{硕士,博士}, {本科}</li>\n</ul>\n<p>分别把两个特征值子集对应的样本分到两个子节点上，而选取哪一种划分方案，需要通过枚举每一种划分方案的<strong>Gini系数</strong>计算完毕后，选取<strong>Gini系数</strong>最小的划分方案为最优划分方案。    </p>\n<p>CART算法采用Gini系数计算衡量分类不纯度。</p>\n<p>$$<br>Gini(Y) = \\sum^n_{i=1} \\frac{|S_{c_i}|}{|Y|} (1 - \\frac{|S_{c_i}|}{|Y|}) = 1 - \\sum^n_{i=1} (\\frac{|S_{c_i}|}{|Y|})^2<br>\\\\<br>0 \\le Gini(Y) \\le 1<br>$$</p>\n<p>划分时，把节点Y的样本集划分为两个集合$S_1$和$S_2$，则对于样本集Y的不纯度计算函数为：</p>\n<p>$$<br>GAIN(Y) = \\frac{|S_1|}{Y} Gini(S_1) + \\frac{|S_2|}{Y} Gini(S_2)<br>$$</p>\n<p>而对训练集进行划分时，划分的规则是利用二叉树的表示形式，CART算法的开始是从根节点进行划分，对各个结点进行重复递归的过程：</p>\n<ol>\n<li>对于每个结点，计算各个剩余特征的最优分界点，并得到各个特征对应的最小Gini系数。注意：这里的剩余特征X可能在祖先节点处被用做过划分，它们两个节点对特征X的处理区别在于祖先节点中特征X的特征值子集比子节点关于特征X的特征值子集更大。</li>\n<li>选择Gini系数最小的特征按照最优分界点进行分割，分割成两个字节点。</li>\n<li>重复对此结点分割出来的两个子节点进行分割这一过程。</li>\n<li>节点划分的终止条件可以为：节点Gini系数下降到指定阈值、持续到叶结点样本个数极少（如少于5个）、树的深度达到指定阈值等。</li>\n</ol>\n<h2 id=\"六、剪枝\"><a href=\"#六、剪枝\" class=\"headerlink\" title=\"六、剪枝\"></a>六、剪枝</h2><p>剪枝的作用除了简化决策树构造，提高算法效率之外，更重要的是“防止过拟合”。</p>\n<p>防止决策树过拟合的方法就是：在训练时，生成的决策树节点细分程度不要过细，也就是所谓的“训练过度”。</p>\n<p>可以设定一些指标的阈值，当决策树的某个指标到达预设的阈值时，即使该叶子节点的分类不纯也停止再细分。</p>\n<p>这里给出一些常用的剪枝方案：</p>\n<ol>\n<li>节点混乱度(信息增益，信息增益率，Gini系数)下降到指定阈值时，停止对该节点再细分。</li>\n<li>限制树的最大深度。当决策树达到一定深度时，停止对该节点再细分。</li>\n<li>限制节点最小样本数。节点不断细分更多的子节点，层数越低的节点中包含的样本数越少。当节点样本数小于等于指定阈值，则停止对该节点细分。</li>\n</ol>\n<h2 id=\"七、随机森林\"><a href=\"#七、随机森林\" class=\"headerlink\" title=\"七、随机森林\"></a>七、随机森林</h2><p>这个算法会生成N(可能会有几百棵以上）棵树，这样可以大大的减少单决策树带来的毛病，有点类似于三个臭皮匠等于一个诸葛亮的做法，虽然这几百棵决策树中的每一棵都很简单（相对于C4.5这种单决策树来说），但是他们组合起来确是很强大。</p>\n<p>随机森林算法过程如下：</p>\n<ol>\n<li>以“有放回”的形式随机抽取目前提供的全部特征中的M个特征出来，然后对取出来的M个特征进行建树。假设原有特征为{A,B,C,D,E,F}，我们有放回的随机抽取4个特征，抽取的结果可能会是{A,C,D,D}、{B,B,B,A}, {A,C,E,F}等，然后根据抽取出来的4个特征用来构建一棵决策树。</li>\n<li>重复步骤1的方法构建N棵决策树，就形成了随机森林。</li>\n<li>当有测试数据传入进行分类预测时，把测试数据分别传入这N棵决策树中进行测试，从而得到N个预测结果。取这N个预测结果中出现频率最高的那个结果作为算法的最终预测值。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<script type=\"text/javascript\" async src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML\"> </script>\n\n<h1 id=\"一、决策树概要\"><a href=\"#一、决策树概要\" class=\"headerlink\" title=\"一、决策树概要\"></a>一、决策树概要</h1><p>日常生活中，我们脑海中对一个物体进行分类会用一大堆条件一步步地判断来得出答案，比如要判别一个动物是鸡，还是鹅，还是鸭，或三者都不是。我们会通过一些体征一步步地进行判断，例如：  </p>\n<ol>\n<li>先判断该动物是否有翅膀。如果没有，则三者（鸡、鹅、鸭）都不是  </li>\n<li>判断嘴巴是否扁平。如果不是，则它是鸡  </li>\n<li>判断额部是否有橙黄色或黑褐色肉质突起。如果有，则为鹅；否则为鸭  </li>\n</ol>\n<p>这样一步步的条件判断，最终分类出该动物物种的方法，我们可以通过决策树来完成，下面给出该例子的图示：</p>\n<pre><code>                      _____________有翅膀____________\n                  有  |                            |  否\n           ________嘴巴扁平________             *不是鸡、鹅、鸭*\n       是  |                     | 否\n   有橙黄色或黑褐色肉质突起          *鸡*\n是 |                  | 否\n  *鹅*               *鸭*</code></pre><p>人类脑海中这样的条件判断其实都是基于对一系列特征数据的学习而得出的结论。决策树就是根据这个原理，从一大堆特征数据以及其对应的分类结果中进行学习并自动求得一棵决策树，过后再遇到同样的分类问题，就可以直接把决策树上的决策条件拿来使用就可以了。</p>\n<p>观察上图中的叶子节点，所有叶子节点都是最终分类结果值，算法通过从树的根节点上根据判断条件往下走，走到最终叶子节点即为分类结果。</p>\n<h2 id=\"如何评判决策树的好坏？\"><a href=\"#如何评判决策树的好坏？\" class=\"headerlink\" title=\"如何评判决策树的好坏？\"></a>如何评判决策树的好坏？</h2><p>下面我们给出几个判断决策树好坏的指标，决策树算法就是针对这些指标建立数学模型，通过数学模型求得最优值，从而得到最优决策方案：</p>\n<ol>\n<li>分类不纯。样本根据决策树算法走到了叶子节点进行归类，但依然存在多个不同分类的样本被归类到同一个叶子节点上，这样的决策树是不好的，没办法帮我们起到分类效果。</li>\n<li>树的深度太大。一棵决策树的深度太大，说明判断条件过多，这样的分类及其复杂，不易于理解，效率也不高。</li>\n<li>节点分支太多。为了使得分类够纯净，而对某个节点产生非常多的分支。例如：错误的对ID字段作为特征属性来条件判断，得出了ID=1,2,3…无数多个分支，这样跟没有分类区别不大，并且容易造成训练过拟合。 </li>\n<li>决策树泛化能力差。如果某棵决策树在训练集中训练结果非常完美，但放到实际应用中得到的效果不佳，就是泛化能力差。</li>\n</ol>\n<h2 id=\"决策树的优缺点\"><a href=\"#决策树的优缺点\" class=\"headerlink\" title=\"决策树的优缺点\"></a>决策树的优缺点</h2><p>优点：</p>\n<ol>\n<li>可以生成可以理解的规则。</li>\n<li>计算量相对来说不是很大。</li>\n<li>可以处理连续和种类字段。</li>\n<li>决策树可以清晰的显示哪些字段比较重要</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>对连续性的字段比较难预测。</li>\n<li>对有时间顺序的数据，需要很多预处理的工作。</li>\n<li>当类别太多时，错误可能就会增加的比较快。</li>\n<li>一般的算法分类的时候，只是根据一个字段来分类。</li>\n</ol>\n<h1 id=\"二、预备知识\"><a href=\"#二、预备知识\" class=\"headerlink\" title=\"二、预备知识\"></a>二、预备知识</h1><h2 id=\"特征\"><a href=\"#特征\" class=\"headerlink\" title=\"特征\"></a>特征</h2><p>下文开始，笔者所谓特征就是对分类有影响的“对象属性”。比如上述鸡鸭鹅分类例子中，我们会为该对象设计这样的一些属性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Animal &#123;</span><br><span class=\"line\">\tint ID</span><br><span class=\"line\">\tbool 有翅膀</span><br><span class=\"line\">\tbool 嘴巴扁平</span><br><span class=\"line\">\tbool 有橙黄色或黑褐色肉质突起</span><br><span class=\"line\">\tint 年龄</span><br><span class=\"line\">\tbool 性别</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中“ID、年龄、性别”属性对分类没有起到作用，我们就不选取这些属性作为分类<strong>特征</strong>。</p>\n<h2 id=\"熵函数\"><a href=\"#熵函数\" class=\"headerlink\" title=\"熵函数\"></a>熵函数</h2><p>熵函数标准定义为：</p>\n<p>$$<br>F(P) = - \\sum^n_{i=1} p_i \\cdot \\log p_i<br>\\\\<br>s.t \\space\\space\\space\\space \\sum^n_{i=1} p_i = 1, p_i \\ge 0, i=1,2,…,n<br>$$</p>\n<p>当 $p_i=\\frac{1}{n}$ 时，熵函数取得最大值，并且n越大熵函数的最大值也随之增大。</p>\n<h2 id=\"信息熵\"><a href=\"#信息熵\" class=\"headerlink\" title=\"信息熵\"></a>信息熵</h2><p>判断分类纯不纯使用“信息熵”进行判断。</p>\n<p>设实际分类总数为<em>N</em>，$P(Y|C=c_i)=\\frac{|S_{c_i}|}{|Y|}$ 表示分类i的样本数占整个样本集总数的比率，其中 $S_{c_i}$ 表示样本集Y中分类为$c_i$的子集。</p>\n<p>求取信息熵的函数如下：</p>\n<p>$$<br>\\begin{aligned}<br>H(X) &amp;= - \\sum^n_{i=1} P(Y|C=c_i) \\cdot \\log P(Y|C=c_i) \\\\<br>&amp;= - \\sum^n_{i=1} \\frac{|S_{c_i}|}{|Y|} \\cdot \\log \\frac{|S_{c_i}|}{|Y|}<br>\\end{aligned}<br>$$</p>\n<p>当样本集中仅有一种分类的样本时，$H(X)=0$。<br>当样本集中混杂的样本分类数很多，且每个分类的样本数量越平均，H(X)的值越大。即H(X)越大，分类越不纯。</p>\n<p>由此，信息熵就作为决策树中节点分类好坏的一个关键评判因素。</p>\n<h2 id=\"条件熵\"><a href=\"#条件熵\" class=\"headerlink\" title=\"条件熵\"></a>条件熵</h2><p>假设有随机变量(X,Y)，其联合概率分布为: $P(Y|X=x_i)=\\frac{|S^{(x_i)}|}{|Y|}(i=1,2,⋯,m)$</p>\n<p>定义 $S^{(x_i)}$ 为样本集Y中特征 $X=x_i$ 的子集，$S_{c_i}^{(x_i)}$ 为 $S_{c_i}$ 中特征 $X=x_i$ 的子集。</p>\n<p>则条件熵 $H(Y∣X)$ 表示对给定样本集Y在基于特征X进行分类所得结果的混乱程度：<br>$$<br>\\begin{aligned}<br>H(Y|X) &amp;= \\sum^m_{i=1} P(Y|X=x_i) \\cdot H(Y|X=x_i)\\\\<br>        &amp;= \\sum^m_{i=1} \\frac{|S^{(x_i)}|}{|Y|} \\cdot H(Y|X=x_i)\\\\<br>        &amp;= \\sum^m_{i=1} \\Bigg( \\frac{|S^{(x_i)}|}{|Y|} \\cdot \\bigg( \\sum^n_{i=1} \\frac{|S_{c_i}^{(x_i)}|}{|S_{x_i}|} \\cdot \\log \\frac{|S_{c_i}^{(x_i)}|}{|S_{x_i}|} \\bigg) \\Bigg)<br>\\end{aligned}<br>$$</p>\n<p>这个值越小，说明按照特征X进行分类后所得到的结果越纯净。</p>\n<h2 id=\"信息增益\"><a href=\"#信息增益\" class=\"headerlink\" title=\"信息增益\"></a>信息增益</h2><p><strong>信息增益</strong> 表示对给定样本集Y在基于特征X进行分类后所得结果的混乱程度与原样本集Y的混乱程度的差值。<br>$$<br>g(Y,X)=H(Y)-H(Y|X)<br>$$</p>\n<p>通过信息增益，我们可以判断对某个节点Y进行再分类时，应采取信息增益最大的特征X进行分类。</p>\n<h1 id=\"三、ID3算法\"><a href=\"#三、ID3算法\" class=\"headerlink\" title=\"三、ID3算法\"></a>三、ID3算法</h1><p>有了上面的预备知识，接下来讲解ID3算法就非常简单了，和其它机器学习算法一样，ID3算法分为 <strong>训练</strong> 和 <strong>测试</strong> 两个过程。</p>\n<h2 id=\"训练\"><a href=\"#训练\" class=\"headerlink\" title=\"训练\"></a>训练</h2><p>ID3的训练过程就是建树过程，其具体步骤如下：</p>\n<ol>\n<li>将输入的全部样本作为根节点的样本集，对根节点进行 <strong>步骤2</strong> 的操作。</li>\n<li>计算当前节点的信息熵，如果其信息熵为0，则 <strong>停止操作</strong> ；否则，进入 <strong>步骤3</strong> 。</li>\n<li>若所有特征都被祖先节点用来作为”分类特征”，则也 <strong>停止操作</strong>; 否则，进入 <strong>步骤4</strong></li>\n<li>选取每一个祖先节点未用来作为“分类特征”的特征计算其信息增益。如果所有特征的信息增益都不大于0，则 <strong>停止操作</strong> ；否则，选取信息增益最大的特征作为该节点的“分类特征”。</li>\n<li>假设分类特征X有N种特征值，则把该节点的样本集分为N份(对于第i份样本集中的特征保证X=xi{i=1,2,…,N})。将这N份样本集作为当前节点的N个子节点，遍历这N个子节点，分别对其进行 <strong>步骤2</strong> 的操作 (递归操作)。</li>\n</ol>\n<p>下面给出建树过程的图示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                                      Y                  </span><br><span class=\"line\">                    &#123;c1,c2,c3,c1,c1,c2,c1,c3,c2,c1,...&#125;      g(Y|A)=0.43</span><br><span class=\"line\">                                      |                      g(Y|B)=1.24     </span><br><span class=\"line\">                                      |                      g(Y|C)=0.87</span><br><span class=\"line\">               __________________________________________________</span><br><span class=\"line\">       B=b1    |               B=b2 |                           |  B=b3</span><br><span class=\"line\">               |                    |                           |</span><br><span class=\"line\">              N1                    N2                          N3</span><br><span class=\"line\">         &#123;c1,c2,...&#125;           &#123;c2,c2,...&#125;                   &#123;c1,c3,...&#125;</span><br><span class=\"line\">g(N1|A)=0.42  |                  H(N2)=0                        |       g(N1|A)=0.35</span><br><span class=\"line\">g(N1|C)=0.13  |                                                 |       g(N1|C)=0.51</span><br><span class=\"line\">         ______________                          ______________________________________</span><br><span class=\"line\">   A=a1  |            | A=a2                     |           |            |           | </span><br><span class=\"line\">         |            |                          |           |            |           |</span><br><span class=\"line\">         |            |                    C=c1  |      C=c2 |            | C=c3      | C=c4</span><br><span class=\"line\">        N4            N5                        N6          N7           N8           N9</span><br><span class=\"line\">  &#123;c1,c1,...&#125;     &#123;c2,c2,...&#125;                &#123;c1,..&#125;      &#123;c1,..&#125;      &#123;c3,..&#125;     &#123;c1,c3,..&#125;</span><br><span class=\"line\">   H(N4)=0          H(N5)=0                  H(N6)=0      H(N7)=0      H(N8)=0        |  H(N7)&gt;0</span><br><span class=\"line\">                                                                                      |  g(N7|A)&gt;0</span><br><span class=\"line\">                                                                                      |</span><br><span class=\"line\">                                                                                  __________</span><br><span class=\"line\">                                                                                  |        |  </span><br><span class=\"line\">                                                                            A=a1  |        |  A=a2</span><br><span class=\"line\">                                                                                  |        |</span><br><span class=\"line\">                                                                                 N10      N11</span><br><span class=\"line\">                                                                               &#123;c1,..&#125;  &#123;c3,c3,c3,c1&#125;</span><br><span class=\"line\">                                                                             H(N10)=0       H(N11)&gt;0</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>ID3算法的测试阶段是根据测试数据的特征值按照树节点的分类特征的分支一直往下走，走到叶子节点就能得到该测试数据的 <strong>预测分类</strong> 。</p>\n<p>算法步骤如下：</p>\n<ol>\n<li>按照 <em>分类特征</em> 以及 <em>测试数据</em> 的特征值，选取对应特征值的分支路径，一直往下走，直到叶子节点为止。</li>\n<li>到达叶子节点后，判断该叶子节点的信息熵是否为0。<br>如果为0，说明该节点样本集中的样本分类一致，直接拿样本集中的一个样本的分类作为 <strong>预测结果</strong> ；如果信息熵不为0，说明该节点样本集中夹杂了多个分类的样本，这时我们取样本集中样本数量最多的分类作为 <strong>预测结果</strong>。</li>\n</ol>\n<p>下面给出例子：<br>继续用上图的建好的决策树进行分类测试，假设有一个测试数据：T1={A=a1, B=b1, C=c1}, T2={A=a1,B=b2,C=c1}, T3={A=a2,B=b3,C=c4}。</p>\n<p>对于T1的探索路径为：Y -&gt; N1 -&gt; N4。因为H(N4)=0，得出T1的 <strong>预测分类</strong> 为c1。<br>对于T2的探索路径为：Y -&gt; N2。因为H(N4)=0，得出T2的 <strong>预测分类</strong> 为c2。<br>对于T3的探索路径为：Y -&gt; N3 -&gt; N9 -&gt; N11。因为H(N11)&gt;0，说明该节点的数据不纯，我们以该节点样本集中数量最多的分类作为T3的 <strong>预测分类</strong> ，即为c3。</p>\n<h1 id=\"四、C4-5算法\"><a href=\"#四、C4-5算法\" class=\"headerlink\" title=\"四、C4.5算法\"></a>四、C4.5算法</h1><p>C4.5算法与ID3算法的区别在于C4.5算法选择最优分类特征时采用信息增益率代替ID3的信息增益来评判分类的纯度，其余部分完全一样。</p>\n<p>但如果同时存在多个特征求得的信息增益量相近，应该优先选择分支数最少的特征。这样分支数较多的特征会留到更底层的节点做划分，越底层的节点熵值越小，甚至到达阈值时就能对其进行剪枝，从而减少整个决策树的分支数量，提升效率以及泛化能力。</p>\n<p>为了解决这个问题，C4.5采用<strong>信息增益率</strong>评估选取一个特征进行划分的优劣。</p>\n<p><strong>信息增益率</strong>公式如下：</p>\n<p>$$<br>g(Y,X)=H(Y)-H(Y|X)<br>\\\\<br>S(Y,X) = - \\sum^m_{i=1} \\frac{|S^{(x_i)}|}{|Y|} \\log \\frac{|S^{(x_i)}|}{|Y|}<br>\\\\<br>GainRatio(Y,X)= \\frac{g(Y,X)}{S(Y,X)}<br>$$</p>\n<p>注意，S(Y,X)是熵函数，当分支数m越多，该函数的值就越大，信息增益率就会随之减少。这样C4.5算法就会在信息增益量相近的特征中，优先选取分支数最少的特征进行子集划分，从而解决ID3算法“更倾向于选择分支数较多的特征”的缺陷。</p>\n<p>笔者的疑惑：笔者认为“信息增益率函数能使算法优先选择分支数少的特征做子集划分”这个观点不全对，观察一下S(Y,X)函数，即使分支数很多(即m很大)，但是有一个$|S^{(x_i)}|$趋向于1，剩余部分$|S^{(x_i)}|$则趋向于0时，函数S(Y,X)得到的值依然很小，这样一来信息增益率依然很大，会导致挑选了一个分支数非常多的特征进行子集划分。</p>\n<h1 id=\"五、CART算法\"><a href=\"#五、CART算法\" class=\"headerlink\" title=\"五、CART算法\"></a>五、CART算法</h1><p>CART树是一棵二叉树，每个非叶子节点只划分两个子节点，每个节点上只会把一个特征的特征值分为两个子集。</p>\n<p>比如“学历”特征，分别有3个特征值：{本科、硕士、博士}，CART有以下三种可能的分法：</p>\n<ul>\n<li>{本科,硕士}, {博士}</li>\n<li>{本科,博士}, {硕士}</li>\n<li>{硕士,博士}, {本科}</li>\n</ul>\n<p>分别把两个特征值子集对应的样本分到两个子节点上，而选取哪一种划分方案，需要通过枚举每一种划分方案的<strong>Gini系数</strong>计算完毕后，选取<strong>Gini系数</strong>最小的划分方案为最优划分方案。    </p>\n<p>CART算法采用Gini系数计算衡量分类不纯度。</p>\n<p>$$<br>Gini(Y) = \\sum^n_{i=1} \\frac{|S_{c_i}|}{|Y|} (1 - \\frac{|S_{c_i}|}{|Y|}) = 1 - \\sum^n_{i=1} (\\frac{|S_{c_i}|}{|Y|})^2<br>\\\\<br>0 \\le Gini(Y) \\le 1<br>$$</p>\n<p>划分时，把节点Y的样本集划分为两个集合$S_1$和$S_2$，则对于样本集Y的不纯度计算函数为：</p>\n<p>$$<br>GAIN(Y) = \\frac{|S_1|}{Y} Gini(S_1) + \\frac{|S_2|}{Y} Gini(S_2)<br>$$</p>\n<p>而对训练集进行划分时，划分的规则是利用二叉树的表示形式，CART算法的开始是从根节点进行划分，对各个结点进行重复递归的过程：</p>\n<ol>\n<li>对于每个结点，计算各个剩余特征的最优分界点，并得到各个特征对应的最小Gini系数。注意：这里的剩余特征X可能在祖先节点处被用做过划分，它们两个节点对特征X的处理区别在于祖先节点中特征X的特征值子集比子节点关于特征X的特征值子集更大。</li>\n<li>选择Gini系数最小的特征按照最优分界点进行分割，分割成两个字节点。</li>\n<li>重复对此结点分割出来的两个子节点进行分割这一过程。</li>\n<li>节点划分的终止条件可以为：节点Gini系数下降到指定阈值、持续到叶结点样本个数极少（如少于5个）、树的深度达到指定阈值等。</li>\n</ol>\n<h2 id=\"六、剪枝\"><a href=\"#六、剪枝\" class=\"headerlink\" title=\"六、剪枝\"></a>六、剪枝</h2><p>剪枝的作用除了简化决策树构造，提高算法效率之外，更重要的是“防止过拟合”。</p>\n<p>防止决策树过拟合的方法就是：在训练时，生成的决策树节点细分程度不要过细，也就是所谓的“训练过度”。</p>\n<p>可以设定一些指标的阈值，当决策树的某个指标到达预设的阈值时，即使该叶子节点的分类不纯也停止再细分。</p>\n<p>这里给出一些常用的剪枝方案：</p>\n<ol>\n<li>节点混乱度(信息增益，信息增益率，Gini系数)下降到指定阈值时，停止对该节点再细分。</li>\n<li>限制树的最大深度。当决策树达到一定深度时，停止对该节点再细分。</li>\n<li>限制节点最小样本数。节点不断细分更多的子节点，层数越低的节点中包含的样本数越少。当节点样本数小于等于指定阈值，则停止对该节点细分。</li>\n</ol>\n<h2 id=\"七、随机森林\"><a href=\"#七、随机森林\" class=\"headerlink\" title=\"七、随机森林\"></a>七、随机森林</h2><p>这个算法会生成N(可能会有几百棵以上）棵树，这样可以大大的减少单决策树带来的毛病，有点类似于三个臭皮匠等于一个诸葛亮的做法，虽然这几百棵决策树中的每一棵都很简单（相对于C4.5这种单决策树来说），但是他们组合起来确是很强大。</p>\n<p>随机森林算法过程如下：</p>\n<ol>\n<li>以“有放回”的形式随机抽取目前提供的全部特征中的M个特征出来，然后对取出来的M个特征进行建树。假设原有特征为{A,B,C,D,E,F}，我们有放回的随机抽取4个特征，抽取的结果可能会是{A,C,D,D}、{B,B,B,A}, {A,C,E,F}等，然后根据抽取出来的4个特征用来构建一棵决策树。</li>\n<li>重复步骤1的方法构建N棵决策树，就形成了随机森林。</li>\n<li>当有测试数据传入进行分类预测时，把测试数据分别传入这N棵决策树中进行测试，从而得到N个预测结果。取这N个预测结果中出现频率最高的那个结果作为算法的最终预测值。</li>\n</ol>\n"},{"_content":"<script type=\"text/javascript\" async src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML\"> </script>\n\n# 一、概述\n支持向量机(Support Vector Machines, SVM)是 Vapnik 等人根据统计学习理论中结构风险最小化原则提出的，SVM能够尽量提高学习机的推广能力，即使由有限数据集得到的判别函数对独立的测试集仍能够得到较小的误差。此外，支持向量机是一个凸二次优化问题，能够保证找到极值解就是全局最优解。这个特点使支持向量机成为一种优秀的基于数据的机器学习算法。\n\n# 二、算法思想\nSVM算法的主要思想是：在N维空间中寻找一个最优划分超平面，使得用于分类训练的样本点根据自身类别完全划分在这个分割超平面的两侧，并且要求所有样本点到分割超平面的距离的最小值要最大。\n\n下面用一个二维空间的图来解释这句话\n![](http://www.blogjava.net/images/blogjava_net/zhenandaci/WindowsLiveWriter/SVMRefresh_9B92/image_thumb.png)\n\n因为这里是二维空间，分割超平面就是一条直线，我们简称它是**分类线**。$H_1$、$H_2$ 分别为过各类中离分类线最近的数据样本且平行于分类线的直线，$H_1,H_2$之间的间隔我们称为**分类间隔**。我们的目标就是求得这条**最优分类线**的方程，所谓**最优分类线**就是要做到分类错误率为0，且分类间隔最大。\n\n## 2.1 最优分类超平面\n在n维空间中，定义一个超平面的一般形式为\n$$\n\\omega^T \\mathbf{x} + \\mathbf{b} = 0\n$$\n\n假设单个训练样本的特征值为 $\\mathbf{x}=[x_1, x_2, \\cdots, x_n]$ 对应样本点坐标为 $(x_1, x_2, \\cdots, x_n)$。我们可以通过以下线性判别函数判别样本点的分类情况：\n$$\nf(\\mathbf{x}) = \\omega^T \\mathbf{x} + \\mathbf{b}\n$$\n\n它把 $f(\\mathbf{x}) > 0$ 和 $f(\\mathbf{x}) < 0$ 的样本点分为了两类，所以我们定义分类标签为 $y$，$y$ 的取值为 -1 或 +1 分别表示不同的两个类别：\n$$\ny = sign(f(\\mathbf{x})) = sign(\\omega^T \\mathbf{x} + \\mathbf{b})\n$$\n\n因为y在训练样本中是已知的，因此我们可以用这样的函数表示样本点 $\\mathbf{x}$ 到分割超平面的距离值：\n$$\nD(\\mathbf{x}) = \\frac{|f(\\mathbf{x})|}{\\|\\omega\\|} = \\frac{y(\\omega^T \\mathbf{x} + \\mathbf{b})}{\\|\\omega\\|}\n$$\n\n我们可以线性变换 $f(x)$ 使得它对于所有的样本点都能满足： $|f(x)| \\ge 1$，其中离分类超平面最近的样本点 $\\mathbf{x}^\\ast$ 满足 $ | f(\\mathbf{x}^\\ast) |=1 $。我们的距离函数 $D(\\mathbf{x})$ 就得到如下不等式关系：\n$$\n\\begin{aligned}\nD(\\mathbf{x}) \\ge \\frac{1}{\\|\\omega\\|}\n\\end{aligned}\n$$\n\n只要找到 $\\omega^\\ast$ 使得 $\\|\\omega^\\ast\\| = \\min{\\|\\omega\\|}$，$\\min D(\\mathbf{x})$ 就能取得最大值，此时的 $f(\\mathbf{x})=0$ 就是我们要找的**最优分割超平面**的一般形式。\n\n求 $\\frac{1}{\\|\\omega\\|}$ 的最大值，相当于求 $\\frac{1}{2}\\|\\omega\\|^2$ 的最小值(乘上 $\\frac{1}{2}$ 是为了后面求导方便)。\n\n这样我们把整体目标定为：求 \n$$\n\\begin{aligned}\n& &\\min_{\\omega,b} \\frac{1}{2} \\omega^T\\omega \\\\\\\\\n&\\text{s.t.}    &y_i(\\mathbf{\\omega} \\cdot \\mathbf{x}_i + \\mathbf{b}) \\ge 1\n\\end{aligned}\n$$\n\n它是一个只有不等式约束的优化问题，我们构建拉格朗日函数(参考 [拉格朗日对偶](http://blog.csdn.net/wangkr111/article/details/21170809) 以及 [拉格朗日乘子法和KKT条件](http://www.cnblogs.com/zhangchaoyang/articles/2726873.html))：\n$$\n\\begin{aligned}\nL(\\omega, b, \\mathbf{a}) &= \\frac{1}{2} \\omega^T\\omega - \\sum^n_{i=1} a_i \\big( y_i(\\omega^T \\mathbf{x}_i + b) - 1 \\big), &\\text{其中拉格朗日乘子 } a_i \\ge 0\n\\end{aligned}\n$$\n\n当 $\\omega, b, \\mathbf{a}$ 满足KKT条件时，拉格朗日对偶问题的解就是原问题的最优解，即 \n$$\n\\displaystyle\\min_{w,b} \\displaystyle\\max_{a} L(\\omega, b, \\mathbf{a}) \n= \\displaystyle\\max_{a} \\displaystyle\\min_{w,b} L(\\omega, b, \\mathbf{a}) \n= \\min \\frac{1}{2} \\omega^T\\omega\n$$\n\n以下列出KKT条件：\n$$\n\\begin{cases}\n\\frac{\\partial L(\\omega, b, \\mathbf{a})}{\\partial \\omega} = 0\\\\\\\\\n\\frac{\\partial L(\\omega, b, \\mathbf{a})}{\\partial b} = 0\\\\\\\\\na_i \\big( y_i(\\omega^T \\mathbf{x}_i + b) - 1 \\big) = 0\\\\\\\\\ny_i(\\omega^T \\mathbf{x}_i + b) \\ge 1\\\\\\\\\na_i \\ge 0\n\\end{cases}\n$$\n\n因为该式子的最小值出现在各个变量偏求导等于0处：\n$$\n\\begin{aligned}\n\\frac{\\partial L(\\omega, b, \\mathbf{a})}{\\partial \\omega} = 0 &\\implies \\omega = \\sum\\_{i=1}^n a_i y_i \\mathbf{x}_i\\\\\\\\\n\\frac{\\partial L(\\omega, b, \\mathbf{a})}{\\partial b} = 0 &\\implies \\sum\\_{i=1}^n a_i y_i = 0\n\\end{aligned}\n$$\n\n将上述二式代入目标函数：\n$$\n\\begin{aligned}\nL(\\omega, b, \\mathbf{a}) &= \\frac{1}{2} \\omega^T\\omega - \\sum^n_{i=1} a_i \\big( y_i(\\omega^T \\mathbf{x}_i + b) - 1 \\big)\\\\\\\\\n&= \\frac{1}{2} \\bigg( \\sum\\_{i=1}^n a_i y_i \\mathbf{x}_i^T \\bigg) \\bigg( \\sum\\_{j=1}^n a_j y_j \\mathbf{x}_j \\bigg) - \\sum^n\\_{i=1} a_i \\bigg( y_i(\\sum\\_{j=1}^n a_j y_j \\mathbf{x}_j^T) \\cdot \\mathbf{x}_i + b) - 1 \\bigg)\\\\\\\\\n&= \\frac{1}{2}  \\sum\\_{i,j=1}^n a_i a_j y_i y_j \\mathbf{x}_i^T \\mathbf{x}_j - \\sum\\_{i,j=1}^n a_i a_j y_i y_j \\mathbf{x}_i^T \\mathbf{x}_j - b \\sum\\_{i=1}^n a_i y_i + \\sum\\_{i=1}^n a_i\\\\\\\\\n&= \\sum\\_{i=1}^n a_i - \\frac{1}{2}  \\sum\\_{i,j=1}^n a_i a_j y_i y_j \\mathbf{x}_i^T \\mathbf{x}_j\n\\end{aligned}\n$$\n\n来到这里，这个最优化问题已经跟 $\\omega$ 以及 $b$ 无关了，可以把上述问题转化为如下凸二次规划寻优的对偶问题：\n$$\n\\begin{cases}\n\\max \\displaystyle\\sum\\_{i=1}^n a_i - \\frac{1}{2}  \\sum\\_{i,j=1}^n a_i a_j y_i y_j \\mathbf{x}_i^T \\mathbf{x}_j\\\\\\\\\na_i \\ge 0\\\\\\\\\n\\displaystyle\\sum\\_{i=1}^n a_i y_i = 0\n\\end{cases}\n$$\n\n若找到一个最优解 $\\mathbf{a}^\\star$，我们就可以通过如下式子求出 $\\omega^\\star$:\n$$\n\\omega^\\star = \\sum\\_{i=1}^n a^\\star_i y_i \\mathbf{x}_i\n$$\n\n求完 $\\omega^\\star$ 之后我们来求 $b^\\star$。分布在决策边界上的样本集，即为**支持向量**，只有它们会对决策边界产生影响。因此，我们只要利用其中一个支持向量 $\\mathbf{x}_i$ 它们必定满足下列等式，从而求得 $b^\\star$:\n$$\n\\begin{aligned}\n&y_i(\\omega^T \\mathbf{x}_i + b^\\star) = 1, &\\text{其中 } \\mathbf{x}_i \\text{ 为支持向量}\n\\end{aligned}\n$$\n\n在拉格朗日对偶问题求解时，若 $y_i(\\omega^T \\mathbf{x}_i + b) > 1$ 时，对偶函数 $\\displaystyle\\min\\_{w,b} \\displaystyle\\max\\_{a} L(\\omega, b, \\mathbf{a})$ 会调整系数 $a_i = 0$ 使得结果最大，所以对于 $a_i \\ne 0$ 对应的样本就是我们要找的**支持向量**，这些样本满足 $y_i(\\omega^T \\mathbf{x}_i + b) = 1$。\n\n## 2.2 防止过拟合\n有些时候，可能会因为数据有误差或者是为了防止数据过拟合而允许分类器容忍一定程度的误差，我们为原来的约束条件 $|f(\\mathbf{x})| \\ge 1$ 添加一个松弛变量:\n$$\n\\begin{aligned}\n|f(\\mathbf{x})| &\\ge 1 - \\xi,     &\\text{其中 }0 \\le \\xi\\\\\\\\\n\\implies y_i( \\omega^T \\mathbf{x} + \\mathbf{b} ) &\\ge 1 - \\xi\n\\end{aligned}\n$$\n\n添加松弛变量后效果如下图:\n![](http://images.cnitblog.com/blog/458371/201212/31223704-0758d0b56ff7413985d4dacd3b0431d5.jpg)\n\n从图中我们可以看出，当 $0 \\le \\xi \\lt 1$ 时，分类器依然能正确分类；当 $1 \\lt \\xi$ 时，分类器得到的分类结果会有错误。\n\n我们在能容忍分类器存在一定错误的情况下，希望总体误差很小，并且使得分类间隔足够大，我们把目标函数改为求：\n$$\n\\begin{aligned}\n&\\displaystyle\\min_{\\omega,b,\\xi} \\bigg( \\frac{1}{2} \\omega^T\\omega + C \\sum^n_{i=1} \\xi_i \\bigg), &\\text{其中 } C > 0 \\text{ 且 } \\xi_i \\ge 0\\\\\\\\\n&s.t. \\space\\space\\space\\space y( \\omega^T \\mathbf{x} + \\mathbf{b} ) \\ge 1 - \\xi\\\\\\\\\n&\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space \\xi_i \\ge 0\n\\end{aligned}\n$$\n\n其中 $C$ 是我们预设的参数，它的大小影响误差值 $\\xi$ 所占的权重。当 $C=+\\infty$ 只要有一个 $\\xi_i \\ne 0$ 则整个目标函数就等于无穷大，这意味着分类器不能容忍有一丝误差（相当于回归到2.1节的目标函数：$\\displaystyle\\min_{\\omega,b} \\frac{1}{2} \\omega^T\\omega$）。\n\n我们依然使用“拉格朗日乘子法”解决带约束的最优化问题：\n$$\n\\begin{aligned}\nL(\\omega, b, \\xi, \\mathbf{a}, \\mathbf{u}) &= \\frac{1}{2} \\omega^T\\omega + C \\sum^n_{i=1} \\xi_i - \\sum^n_{i=1} a_i \\big( y_i(\\omega^T \\mathbf{x}_i + b) - 1 + \\xi_i \\big) - \\sum\\_{i=1}^n u_i \\xi_i, &\\text{其中拉格朗日乘子 } a_i, u_i \\ge 0\n\\end{aligned}\n$$\n\n因为该式子的最小值出现在各个变量偏求导等于0处：\n$$\n\\begin{aligned}\n\\frac{\\partial L(\\omega, b, \\xi, \\mathbf{a}, \\mathbf{u})}{\\partial \\omega} = 0 &\\implies \\omega = \\sum\\_{i=1}^n a_i y_i \\mathbf{x}_i\\\\\\\\\n\\frac{\\partial L(\\omega, b, \\xi, \\mathbf{a}, \\mathbf{u})}{\\partial b} = 0 &\\implies \\sum\\_{i=1}^n a_i y_i = 0\\\\\\\\\n\\frac{\\partial L(\\omega, b, \\xi, \\mathbf{a}, \\mathbf{u})}{\\partial \\xi_i} = 0 &\\implies C - a_i - u_i = 0\n\\end{aligned}\n$$\n\n我们将上面三个式子代入目标函数：\n$$\n\\begin{aligned}\nL(\\omega, b, \\xi, \\mathbf{a}, \\mathbf{u}) &= \\frac{1}{2} \\omega^T\\omega + C \\sum^n_{i=1} \\xi_i - \\sum^n_{i=1} a_i \\big( y_i(\\omega^T \\mathbf{x}_i + b) - 1 + \\xi_i \\big) - \\sum\\_{i=1}^n u_i \\xi_i\\\\\\\\\n&= \\frac{1}{2} \\bigg( \\sum\\_{i=1}^n a_i y_i \\mathbf{x}_i^T \\bigg) \\bigg( \\sum\\_{j=1}^n a_j y_j \\mathbf{x}_j \\bigg) + C \\sum^n\\_{i=1} \\xi_i - \\sum^n\\_{i=1} a_i \\bigg( y_i(\\sum\\_{j=1}^n a_j y_j \\mathbf{x}_j^T) \\cdot \\mathbf{x}_i + b) - 1 + \\xi_i \\bigg) - \\sum\\_{i=1}^n (C - a_i) \\xi_i\\\\\\\\\n&= \\frac{1}{2}  \\sum\\_{i,j=1}^n a_i a_j y_i y_j \\mathbf{x}_i^T \\mathbf{x}_j - \\sum\\_{i,j=1}^n a_i a_j y_i y_j \\mathbf{x}_i^T \\mathbf{x}_j - b \\sum\\_{i=1}^n a_i y_i + \\sum\\_{i=1}^n a_i\\\\\\\\\n&= \\sum\\_{i=1}^n a_i - \\frac{1}{2}  \\sum\\_{i,j=1}^n a_i a_j y_i y_j \\mathbf{x}_i^T \\mathbf{x}_j\n\\end{aligned}\n$$\n\n其中通过 $C - a_i - u_i = 0$ 推导出约束条件：\n$$\nC \\ge a_i \\ge 0\n$$\n\n来到这里发现式子跟2.1节的一模一样，它们的区别只在于约束条件：\n$$\n\\begin{aligned}\n&C \\ge a_i \\ge 0, &\\sum\\_{i=1}^n a_i y_i = 0\n\\end{aligned}\n$$\n","source":"_drafts/支持向量机.md","raw":"<script type=\"text/javascript\" async src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML\"> </script>\n\n# 一、概述\n支持向量机(Support Vector Machines, SVM)是 Vapnik 等人根据统计学习理论中结构风险最小化原则提出的，SVM能够尽量提高学习机的推广能力，即使由有限数据集得到的判别函数对独立的测试集仍能够得到较小的误差。此外，支持向量机是一个凸二次优化问题，能够保证找到极值解就是全局最优解。这个特点使支持向量机成为一种优秀的基于数据的机器学习算法。\n\n# 二、算法思想\nSVM算法的主要思想是：在N维空间中寻找一个最优划分超平面，使得用于分类训练的样本点根据自身类别完全划分在这个分割超平面的两侧，并且要求所有样本点到分割超平面的距离的最小值要最大。\n\n下面用一个二维空间的图来解释这句话\n![](http://www.blogjava.net/images/blogjava_net/zhenandaci/WindowsLiveWriter/SVMRefresh_9B92/image_thumb.png)\n\n因为这里是二维空间，分割超平面就是一条直线，我们简称它是**分类线**。$H_1$、$H_2$ 分别为过各类中离分类线最近的数据样本且平行于分类线的直线，$H_1,H_2$之间的间隔我们称为**分类间隔**。我们的目标就是求得这条**最优分类线**的方程，所谓**最优分类线**就是要做到分类错误率为0，且分类间隔最大。\n\n## 2.1 最优分类超平面\n在n维空间中，定义一个超平面的一般形式为\n$$\n\\omega^T \\mathbf{x} + \\mathbf{b} = 0\n$$\n\n假设单个训练样本的特征值为 $\\mathbf{x}=[x_1, x_2, \\cdots, x_n]$ 对应样本点坐标为 $(x_1, x_2, \\cdots, x_n)$。我们可以通过以下线性判别函数判别样本点的分类情况：\n$$\nf(\\mathbf{x}) = \\omega^T \\mathbf{x} + \\mathbf{b}\n$$\n\n它把 $f(\\mathbf{x}) > 0$ 和 $f(\\mathbf{x}) < 0$ 的样本点分为了两类，所以我们定义分类标签为 $y$，$y$ 的取值为 -1 或 +1 分别表示不同的两个类别：\n$$\ny = sign(f(\\mathbf{x})) = sign(\\omega^T \\mathbf{x} + \\mathbf{b})\n$$\n\n因为y在训练样本中是已知的，因此我们可以用这样的函数表示样本点 $\\mathbf{x}$ 到分割超平面的距离值：\n$$\nD(\\mathbf{x}) = \\frac{|f(\\mathbf{x})|}{\\|\\omega\\|} = \\frac{y(\\omega^T \\mathbf{x} + \\mathbf{b})}{\\|\\omega\\|}\n$$\n\n我们可以线性变换 $f(x)$ 使得它对于所有的样本点都能满足： $|f(x)| \\ge 1$，其中离分类超平面最近的样本点 $\\mathbf{x}^\\ast$ 满足 $ | f(\\mathbf{x}^\\ast) |=1 $。我们的距离函数 $D(\\mathbf{x})$ 就得到如下不等式关系：\n$$\n\\begin{aligned}\nD(\\mathbf{x}) \\ge \\frac{1}{\\|\\omega\\|}\n\\end{aligned}\n$$\n\n只要找到 $\\omega^\\ast$ 使得 $\\|\\omega^\\ast\\| = \\min{\\|\\omega\\|}$，$\\min D(\\mathbf{x})$ 就能取得最大值，此时的 $f(\\mathbf{x})=0$ 就是我们要找的**最优分割超平面**的一般形式。\n\n求 $\\frac{1}{\\|\\omega\\|}$ 的最大值，相当于求 $\\frac{1}{2}\\|\\omega\\|^2$ 的最小值(乘上 $\\frac{1}{2}$ 是为了后面求导方便)。\n\n这样我们把整体目标定为：求 \n$$\n\\begin{aligned}\n& &\\min_{\\omega,b} \\frac{1}{2} \\omega^T\\omega \\\\\\\\\n&\\text{s.t.}    &y_i(\\mathbf{\\omega} \\cdot \\mathbf{x}_i + \\mathbf{b}) \\ge 1\n\\end{aligned}\n$$\n\n它是一个只有不等式约束的优化问题，我们构建拉格朗日函数(参考 [拉格朗日对偶](http://blog.csdn.net/wangkr111/article/details/21170809) 以及 [拉格朗日乘子法和KKT条件](http://www.cnblogs.com/zhangchaoyang/articles/2726873.html))：\n$$\n\\begin{aligned}\nL(\\omega, b, \\mathbf{a}) &= \\frac{1}{2} \\omega^T\\omega - \\sum^n_{i=1} a_i \\big( y_i(\\omega^T \\mathbf{x}_i + b) - 1 \\big), &\\text{其中拉格朗日乘子 } a_i \\ge 0\n\\end{aligned}\n$$\n\n当 $\\omega, b, \\mathbf{a}$ 满足KKT条件时，拉格朗日对偶问题的解就是原问题的最优解，即 \n$$\n\\displaystyle\\min_{w,b} \\displaystyle\\max_{a} L(\\omega, b, \\mathbf{a}) \n= \\displaystyle\\max_{a} \\displaystyle\\min_{w,b} L(\\omega, b, \\mathbf{a}) \n= \\min \\frac{1}{2} \\omega^T\\omega\n$$\n\n以下列出KKT条件：\n$$\n\\begin{cases}\n\\frac{\\partial L(\\omega, b, \\mathbf{a})}{\\partial \\omega} = 0\\\\\\\\\n\\frac{\\partial L(\\omega, b, \\mathbf{a})}{\\partial b} = 0\\\\\\\\\na_i \\big( y_i(\\omega^T \\mathbf{x}_i + b) - 1 \\big) = 0\\\\\\\\\ny_i(\\omega^T \\mathbf{x}_i + b) \\ge 1\\\\\\\\\na_i \\ge 0\n\\end{cases}\n$$\n\n因为该式子的最小值出现在各个变量偏求导等于0处：\n$$\n\\begin{aligned}\n\\frac{\\partial L(\\omega, b, \\mathbf{a})}{\\partial \\omega} = 0 &\\implies \\omega = \\sum\\_{i=1}^n a_i y_i \\mathbf{x}_i\\\\\\\\\n\\frac{\\partial L(\\omega, b, \\mathbf{a})}{\\partial b} = 0 &\\implies \\sum\\_{i=1}^n a_i y_i = 0\n\\end{aligned}\n$$\n\n将上述二式代入目标函数：\n$$\n\\begin{aligned}\nL(\\omega, b, \\mathbf{a}) &= \\frac{1}{2} \\omega^T\\omega - \\sum^n_{i=1} a_i \\big( y_i(\\omega^T \\mathbf{x}_i + b) - 1 \\big)\\\\\\\\\n&= \\frac{1}{2} \\bigg( \\sum\\_{i=1}^n a_i y_i \\mathbf{x}_i^T \\bigg) \\bigg( \\sum\\_{j=1}^n a_j y_j \\mathbf{x}_j \\bigg) - \\sum^n\\_{i=1} a_i \\bigg( y_i(\\sum\\_{j=1}^n a_j y_j \\mathbf{x}_j^T) \\cdot \\mathbf{x}_i + b) - 1 \\bigg)\\\\\\\\\n&= \\frac{1}{2}  \\sum\\_{i,j=1}^n a_i a_j y_i y_j \\mathbf{x}_i^T \\mathbf{x}_j - \\sum\\_{i,j=1}^n a_i a_j y_i y_j \\mathbf{x}_i^T \\mathbf{x}_j - b \\sum\\_{i=1}^n a_i y_i + \\sum\\_{i=1}^n a_i\\\\\\\\\n&= \\sum\\_{i=1}^n a_i - \\frac{1}{2}  \\sum\\_{i,j=1}^n a_i a_j y_i y_j \\mathbf{x}_i^T \\mathbf{x}_j\n\\end{aligned}\n$$\n\n来到这里，这个最优化问题已经跟 $\\omega$ 以及 $b$ 无关了，可以把上述问题转化为如下凸二次规划寻优的对偶问题：\n$$\n\\begin{cases}\n\\max \\displaystyle\\sum\\_{i=1}^n a_i - \\frac{1}{2}  \\sum\\_{i,j=1}^n a_i a_j y_i y_j \\mathbf{x}_i^T \\mathbf{x}_j\\\\\\\\\na_i \\ge 0\\\\\\\\\n\\displaystyle\\sum\\_{i=1}^n a_i y_i = 0\n\\end{cases}\n$$\n\n若找到一个最优解 $\\mathbf{a}^\\star$，我们就可以通过如下式子求出 $\\omega^\\star$:\n$$\n\\omega^\\star = \\sum\\_{i=1}^n a^\\star_i y_i \\mathbf{x}_i\n$$\n\n求完 $\\omega^\\star$ 之后我们来求 $b^\\star$。分布在决策边界上的样本集，即为**支持向量**，只有它们会对决策边界产生影响。因此，我们只要利用其中一个支持向量 $\\mathbf{x}_i$ 它们必定满足下列等式，从而求得 $b^\\star$:\n$$\n\\begin{aligned}\n&y_i(\\omega^T \\mathbf{x}_i + b^\\star) = 1, &\\text{其中 } \\mathbf{x}_i \\text{ 为支持向量}\n\\end{aligned}\n$$\n\n在拉格朗日对偶问题求解时，若 $y_i(\\omega^T \\mathbf{x}_i + b) > 1$ 时，对偶函数 $\\displaystyle\\min\\_{w,b} \\displaystyle\\max\\_{a} L(\\omega, b, \\mathbf{a})$ 会调整系数 $a_i = 0$ 使得结果最大，所以对于 $a_i \\ne 0$ 对应的样本就是我们要找的**支持向量**，这些样本满足 $y_i(\\omega^T \\mathbf{x}_i + b) = 1$。\n\n## 2.2 防止过拟合\n有些时候，可能会因为数据有误差或者是为了防止数据过拟合而允许分类器容忍一定程度的误差，我们为原来的约束条件 $|f(\\mathbf{x})| \\ge 1$ 添加一个松弛变量:\n$$\n\\begin{aligned}\n|f(\\mathbf{x})| &\\ge 1 - \\xi,     &\\text{其中 }0 \\le \\xi\\\\\\\\\n\\implies y_i( \\omega^T \\mathbf{x} + \\mathbf{b} ) &\\ge 1 - \\xi\n\\end{aligned}\n$$\n\n添加松弛变量后效果如下图:\n![](http://images.cnitblog.com/blog/458371/201212/31223704-0758d0b56ff7413985d4dacd3b0431d5.jpg)\n\n从图中我们可以看出，当 $0 \\le \\xi \\lt 1$ 时，分类器依然能正确分类；当 $1 \\lt \\xi$ 时，分类器得到的分类结果会有错误。\n\n我们在能容忍分类器存在一定错误的情况下，希望总体误差很小，并且使得分类间隔足够大，我们把目标函数改为求：\n$$\n\\begin{aligned}\n&\\displaystyle\\min_{\\omega,b,\\xi} \\bigg( \\frac{1}{2} \\omega^T\\omega + C \\sum^n_{i=1} \\xi_i \\bigg), &\\text{其中 } C > 0 \\text{ 且 } \\xi_i \\ge 0\\\\\\\\\n&s.t. \\space\\space\\space\\space y( \\omega^T \\mathbf{x} + \\mathbf{b} ) \\ge 1 - \\xi\\\\\\\\\n&\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space \\xi_i \\ge 0\n\\end{aligned}\n$$\n\n其中 $C$ 是我们预设的参数，它的大小影响误差值 $\\xi$ 所占的权重。当 $C=+\\infty$ 只要有一个 $\\xi_i \\ne 0$ 则整个目标函数就等于无穷大，这意味着分类器不能容忍有一丝误差（相当于回归到2.1节的目标函数：$\\displaystyle\\min_{\\omega,b} \\frac{1}{2} \\omega^T\\omega$）。\n\n我们依然使用“拉格朗日乘子法”解决带约束的最优化问题：\n$$\n\\begin{aligned}\nL(\\omega, b, \\xi, \\mathbf{a}, \\mathbf{u}) &= \\frac{1}{2} \\omega^T\\omega + C \\sum^n_{i=1} \\xi_i - \\sum^n_{i=1} a_i \\big( y_i(\\omega^T \\mathbf{x}_i + b) - 1 + \\xi_i \\big) - \\sum\\_{i=1}^n u_i \\xi_i, &\\text{其中拉格朗日乘子 } a_i, u_i \\ge 0\n\\end{aligned}\n$$\n\n因为该式子的最小值出现在各个变量偏求导等于0处：\n$$\n\\begin{aligned}\n\\frac{\\partial L(\\omega, b, \\xi, \\mathbf{a}, \\mathbf{u})}{\\partial \\omega} = 0 &\\implies \\omega = \\sum\\_{i=1}^n a_i y_i \\mathbf{x}_i\\\\\\\\\n\\frac{\\partial L(\\omega, b, \\xi, \\mathbf{a}, \\mathbf{u})}{\\partial b} = 0 &\\implies \\sum\\_{i=1}^n a_i y_i = 0\\\\\\\\\n\\frac{\\partial L(\\omega, b, \\xi, \\mathbf{a}, \\mathbf{u})}{\\partial \\xi_i} = 0 &\\implies C - a_i - u_i = 0\n\\end{aligned}\n$$\n\n我们将上面三个式子代入目标函数：\n$$\n\\begin{aligned}\nL(\\omega, b, \\xi, \\mathbf{a}, \\mathbf{u}) &= \\frac{1}{2} \\omega^T\\omega + C \\sum^n_{i=1} \\xi_i - \\sum^n_{i=1} a_i \\big( y_i(\\omega^T \\mathbf{x}_i + b) - 1 + \\xi_i \\big) - \\sum\\_{i=1}^n u_i \\xi_i\\\\\\\\\n&= \\frac{1}{2} \\bigg( \\sum\\_{i=1}^n a_i y_i \\mathbf{x}_i^T \\bigg) \\bigg( \\sum\\_{j=1}^n a_j y_j \\mathbf{x}_j \\bigg) + C \\sum^n\\_{i=1} \\xi_i - \\sum^n\\_{i=1} a_i \\bigg( y_i(\\sum\\_{j=1}^n a_j y_j \\mathbf{x}_j^T) \\cdot \\mathbf{x}_i + b) - 1 + \\xi_i \\bigg) - \\sum\\_{i=1}^n (C - a_i) \\xi_i\\\\\\\\\n&= \\frac{1}{2}  \\sum\\_{i,j=1}^n a_i a_j y_i y_j \\mathbf{x}_i^T \\mathbf{x}_j - \\sum\\_{i,j=1}^n a_i a_j y_i y_j \\mathbf{x}_i^T \\mathbf{x}_j - b \\sum\\_{i=1}^n a_i y_i + \\sum\\_{i=1}^n a_i\\\\\\\\\n&= \\sum\\_{i=1}^n a_i - \\frac{1}{2}  \\sum\\_{i,j=1}^n a_i a_j y_i y_j \\mathbf{x}_i^T \\mathbf{x}_j\n\\end{aligned}\n$$\n\n其中通过 $C - a_i - u_i = 0$ 推导出约束条件：\n$$\nC \\ge a_i \\ge 0\n$$\n\n来到这里发现式子跟2.1节的一模一样，它们的区别只在于约束条件：\n$$\n\\begin{aligned}\n&C \\ge a_i \\ge 0, &\\sum\\_{i=1}^n a_i y_i = 0\n\\end{aligned}\n$$\n","slug":"支持向量机","published":0,"date":"2020-01-23T07:05:52.988Z","updated":"2018-06-08T00:03:46.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ck679mts8000xlbmd4ksqw3qa","content":"<script type=\"text/javascript\" async src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML\"> </script>\n\n<h1 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h1><p>支持向量机(Support Vector Machines, SVM)是 Vapnik 等人根据统计学习理论中结构风险最小化原则提出的，SVM能够尽量提高学习机的推广能力，即使由有限数据集得到的判别函数对独立的测试集仍能够得到较小的误差。此外，支持向量机是一个凸二次优化问题，能够保证找到极值解就是全局最优解。这个特点使支持向量机成为一种优秀的基于数据的机器学习算法。</p>\n<h1 id=\"二、算法思想\"><a href=\"#二、算法思想\" class=\"headerlink\" title=\"二、算法思想\"></a>二、算法思想</h1><p>SVM算法的主要思想是：在N维空间中寻找一个最优划分超平面，使得用于分类训练的样本点根据自身类别完全划分在这个分割超平面的两侧，并且要求所有样本点到分割超平面的距离的最小值要最大。</p>\n<p>下面用一个二维空间的图来解释这句话<br><img src=\"http://www.blogjava.net/images/blogjava_net/zhenandaci/WindowsLiveWriter/SVMRefresh_9B92/image_thumb.png\" alt></p>\n<p>因为这里是二维空间，分割超平面就是一条直线，我们简称它是<strong>分类线</strong>。$H_1$、$H_2$ 分别为过各类中离分类线最近的数据样本且平行于分类线的直线，$H_1,H_2$之间的间隔我们称为<strong>分类间隔</strong>。我们的目标就是求得这条<strong>最优分类线</strong>的方程，所谓<strong>最优分类线</strong>就是要做到分类错误率为0，且分类间隔最大。</p>\n<h2 id=\"2-1-最优分类超平面\"><a href=\"#2-1-最优分类超平面\" class=\"headerlink\" title=\"2.1 最优分类超平面\"></a>2.1 最优分类超平面</h2><p>在n维空间中，定义一个超平面的一般形式为<br>$$<br>\\omega^T \\mathbf{x} + \\mathbf{b} = 0<br>$$</p>\n<p>假设单个训练样本的特征值为 $\\mathbf{x}=[x_1, x_2, \\cdots, x_n]$ 对应样本点坐标为 $(x_1, x_2, \\cdots, x_n)$。我们可以通过以下线性判别函数判别样本点的分类情况：<br>$$<br>f(\\mathbf{x}) = \\omega^T \\mathbf{x} + \\mathbf{b}<br>$$</p>\n<p>它把 $f(\\mathbf{x}) &gt; 0$ 和 $f(\\mathbf{x}) &lt; 0$ 的样本点分为了两类，所以我们定义分类标签为 $y$，$y$ 的取值为 -1 或 +1 分别表示不同的两个类别：<br>$$<br>y = sign(f(\\mathbf{x})) = sign(\\omega^T \\mathbf{x} + \\mathbf{b})<br>$$</p>\n<p>因为y在训练样本中是已知的，因此我们可以用这样的函数表示样本点 $\\mathbf{x}$ 到分割超平面的距离值：<br>$$<br>D(\\mathbf{x}) = \\frac{|f(\\mathbf{x})|}{|\\omega|} = \\frac{y(\\omega^T \\mathbf{x} + \\mathbf{b})}{|\\omega|}<br>$$</p>\n<p>我们可以线性变换 $f(x)$ 使得它对于所有的样本点都能满足： $|f(x)| \\ge 1$，其中离分类超平面最近的样本点 $\\mathbf{x}^\\ast$ 满足 $ | f(\\mathbf{x}^\\ast) |=1 $。我们的距离函数 $D(\\mathbf{x})$ 就得到如下不等式关系：<br>$$<br>\\begin{aligned}<br>D(\\mathbf{x}) \\ge \\frac{1}{|\\omega|}<br>\\end{aligned}<br>$$</p>\n<p>只要找到 $\\omega^\\ast$ 使得 $|\\omega^\\ast| = \\min{|\\omega|}$，$\\min D(\\mathbf{x})$ 就能取得最大值，此时的 $f(\\mathbf{x})=0$ 就是我们要找的<strong>最优分割超平面</strong>的一般形式。</p>\n<p>求 $\\frac{1}{|\\omega|}$ 的最大值，相当于求 $\\frac{1}{2}|\\omega|^2$ 的最小值(乘上 $\\frac{1}{2}$ 是为了后面求导方便)。</p>\n<p>这样我们把整体目标定为：求<br>$$<br>\\begin{aligned}<br>&amp; &amp;\\min_{\\omega,b} \\frac{1}{2} \\omega^T\\omega \\\\<br>&amp;\\text{s.t.}    &amp;y_i(\\mathbf{\\omega} \\cdot \\mathbf{x}_i + \\mathbf{b}) \\ge 1<br>\\end{aligned}<br>$$</p>\n<p>它是一个只有不等式约束的优化问题，我们构建拉格朗日函数(参考 <a href=\"http://blog.csdn.net/wangkr111/article/details/21170809\" target=\"_blank\" rel=\"noopener\">拉格朗日对偶</a> 以及 <a href=\"http://www.cnblogs.com/zhangchaoyang/articles/2726873.html\" target=\"_blank\" rel=\"noopener\">拉格朗日乘子法和KKT条件</a>)：<br>$$<br>\\begin{aligned}<br>L(\\omega, b, \\mathbf{a}) &amp;= \\frac{1}{2} \\omega^T\\omega - \\sum^n_{i=1} a_i \\big( y_i(\\omega^T \\mathbf{x}_i + b) - 1 \\big), &amp;\\text{其中拉格朗日乘子 } a_i \\ge 0<br>\\end{aligned}<br>$$</p>\n<p>当 $\\omega, b, \\mathbf{a}$ 满足KKT条件时，拉格朗日对偶问题的解就是原问题的最优解，即<br>$$<br>\\displaystyle\\min_{w,b} \\displaystyle\\max_{a} L(\\omega, b, \\mathbf{a})<br>= \\displaystyle\\max_{a} \\displaystyle\\min_{w,b} L(\\omega, b, \\mathbf{a})<br>= \\min \\frac{1}{2} \\omega^T\\omega<br>$$</p>\n<p>以下列出KKT条件：<br>$$<br>\\begin{cases}<br>\\frac{\\partial L(\\omega, b, \\mathbf{a})}{\\partial \\omega} = 0\\\\<br>\\frac{\\partial L(\\omega, b, \\mathbf{a})}{\\partial b} = 0\\\\<br>a_i \\big( y_i(\\omega^T \\mathbf{x}_i + b) - 1 \\big) = 0\\\\<br>y_i(\\omega^T \\mathbf{x}_i + b) \\ge 1\\\\<br>a_i \\ge 0<br>\\end{cases}<br>$$</p>\n<p>因为该式子的最小值出现在各个变量偏求导等于0处：<br>$$<br>\\begin{aligned}<br>\\frac{\\partial L(\\omega, b, \\mathbf{a})}{\\partial \\omega} = 0 &amp;\\implies \\omega = \\sum_{i=1}^n a_i y_i \\mathbf{x}<em>i\\\\<br>\\frac{\\partial L(\\omega, b, \\mathbf{a})}{\\partial b} = 0 &amp;\\implies \\sum\\</em>{i=1}^n a_i y_i = 0<br>\\end{aligned}<br>$$</p>\n<p>将上述二式代入目标函数：<br>$$<br>\\begin{aligned}<br>L(\\omega, b, \\mathbf{a}) &amp;= \\frac{1}{2} \\omega^T\\omega - \\sum^n_{i=1} a_i \\big( y_i(\\omega^T \\mathbf{x}<em>i + b) - 1 \\big)\\\\<br>&amp;= \\frac{1}{2} \\bigg( \\sum\\</em>{i=1}^n a_i y_i \\mathbf{x}<em>i^T \\bigg) \\bigg( \\sum\\</em>{j=1}^n a_j y_j \\mathbf{x}<em>j \\bigg) - \\sum^n\\</em>{i=1} a_i \\bigg( y_i(\\sum_{j=1}^n a_j y_j \\mathbf{x}<em>j^T) \\cdot \\mathbf{x}_i + b) - 1 \\bigg)\\\\<br>&amp;= \\frac{1}{2}  \\sum\\</em>{i,j=1}^n a_i a_j y_i y_j \\mathbf{x}<em>i^T \\mathbf{x}_j - \\sum\\</em>{i,j=1}^n a_i a_j y_i y_j \\mathbf{x}<em>i^T \\mathbf{x}_j - b \\sum\\</em>{i=1}^n a_i y_i + \\sum_{i=1}^n a_i\\\\<br>&amp;= \\sum_{i=1}^n a_i - \\frac{1}{2}  \\sum_{i,j=1}^n a_i a_j y_i y_j \\mathbf{x}_i^T \\mathbf{x}_j<br>\\end{aligned}<br>$$</p>\n<p>来到这里，这个最优化问题已经跟 $\\omega$ 以及 $b$ 无关了，可以把上述问题转化为如下凸二次规划寻优的对偶问题：<br>$$<br>\\begin{cases}<br>\\max \\displaystyle\\sum_{i=1}^n a_i - \\frac{1}{2}  \\sum_{i,j=1}^n a_i a_j y_i y_j \\mathbf{x}<em>i^T \\mathbf{x}_j\\\\<br>a_i \\ge 0\\\\<br>\\displaystyle\\sum\\</em>{i=1}^n a_i y_i = 0<br>\\end{cases}<br>$$</p>\n<p>若找到一个最优解 $\\mathbf{a}^\\star$，我们就可以通过如下式子求出 $\\omega^\\star$:<br>$$<br>\\omega^\\star = \\sum_{i=1}^n a^\\star_i y_i \\mathbf{x}_i<br>$$</p>\n<p>求完 $\\omega^\\star$ 之后我们来求 $b^\\star$。分布在决策边界上的样本集，即为<strong>支持向量</strong>，只有它们会对决策边界产生影响。因此，我们只要利用其中一个支持向量 $\\mathbf{x}_i$ 它们必定满足下列等式，从而求得 $b^\\star$:<br>$$<br>\\begin{aligned}<br>&amp;y_i(\\omega^T \\mathbf{x}_i + b^\\star) = 1, &amp;\\text{其中 } \\mathbf{x}_i \\text{ 为支持向量}<br>\\end{aligned}<br>$$</p>\n<p>在拉格朗日对偶问题求解时，若 $y_i(\\omega^T \\mathbf{x}<em>i + b) &gt; 1$ 时，对偶函数 $\\displaystyle\\min\\</em>{w,b} \\displaystyle\\max_{a} L(\\omega, b, \\mathbf{a})$ 会调整系数 $a_i = 0$ 使得结果最大，所以对于 $a_i \\ne 0$ 对应的样本就是我们要找的<strong>支持向量</strong>，这些样本满足 $y_i(\\omega^T \\mathbf{x}_i + b) = 1$。</p>\n<h2 id=\"2-2-防止过拟合\"><a href=\"#2-2-防止过拟合\" class=\"headerlink\" title=\"2.2 防止过拟合\"></a>2.2 防止过拟合</h2><p>有些时候，可能会因为数据有误差或者是为了防止数据过拟合而允许分类器容忍一定程度的误差，我们为原来的约束条件 $|f(\\mathbf{x})| \\ge 1$ 添加一个松弛变量:<br>$$<br>\\begin{aligned}<br>|f(\\mathbf{x})| &amp;\\ge 1 - \\xi,     &amp;\\text{其中 }0 \\le \\xi\\\\<br>\\implies y_i( \\omega^T \\mathbf{x} + \\mathbf{b} ) &amp;\\ge 1 - \\xi<br>\\end{aligned}<br>$$</p>\n<p>添加松弛变量后效果如下图:<br><img src=\"http://images.cnitblog.com/blog/458371/201212/31223704-0758d0b56ff7413985d4dacd3b0431d5.jpg\" alt></p>\n<p>从图中我们可以看出，当 $0 \\le \\xi \\lt 1$ 时，分类器依然能正确分类；当 $1 \\lt \\xi$ 时，分类器得到的分类结果会有错误。</p>\n<p>我们在能容忍分类器存在一定错误的情况下，希望总体误差很小，并且使得分类间隔足够大，我们把目标函数改为求：<br>$$<br>\\begin{aligned}<br>&amp;\\displaystyle\\min_{\\omega,b,\\xi} \\bigg( \\frac{1}{2} \\omega^T\\omega + C \\sum^n_{i=1} \\xi_i \\bigg), &amp;\\text{其中 } C &gt; 0 \\text{ 且 } \\xi_i \\ge 0\\\\<br>&amp;s.t. \\space\\space\\space\\space y( \\omega^T \\mathbf{x} + \\mathbf{b} ) \\ge 1 - \\xi\\\\<br>&amp;\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space \\xi_i \\ge 0<br>\\end{aligned}<br>$$</p>\n<p>其中 $C$ 是我们预设的参数，它的大小影响误差值 $\\xi$ 所占的权重。当 $C=+\\infty$ 只要有一个 $\\xi_i \\ne 0$ 则整个目标函数就等于无穷大，这意味着分类器不能容忍有一丝误差（相当于回归到2.1节的目标函数：$\\displaystyle\\min_{\\omega,b} \\frac{1}{2} \\omega^T\\omega$）。</p>\n<p>我们依然使用“拉格朗日乘子法”解决带约束的最优化问题：<br>$$<br>\\begin{aligned}<br>L(\\omega, b, \\xi, \\mathbf{a}, \\mathbf{u}) &amp;= \\frac{1}{2} \\omega^T\\omega + C \\sum^n_{i=1} \\xi_i - \\sum^n_{i=1} a_i \\big( y_i(\\omega^T \\mathbf{x}<em>i + b) - 1 + \\xi_i \\big) - \\sum\\</em>{i=1}^n u_i \\xi_i, &amp;\\text{其中拉格朗日乘子 } a_i, u_i \\ge 0<br>\\end{aligned}<br>$$</p>\n<p>因为该式子的最小值出现在各个变量偏求导等于0处：<br>$$<br>\\begin{aligned}<br>\\frac{\\partial L(\\omega, b, \\xi, \\mathbf{a}, \\mathbf{u})}{\\partial \\omega} = 0 &amp;\\implies \\omega = \\sum_{i=1}^n a_i y_i \\mathbf{x}<em>i\\\\<br>\\frac{\\partial L(\\omega, b, \\xi, \\mathbf{a}, \\mathbf{u})}{\\partial b} = 0 &amp;\\implies \\sum\\</em>{i=1}^n a_i y_i = 0\\\\<br>\\frac{\\partial L(\\omega, b, \\xi, \\mathbf{a}, \\mathbf{u})}{\\partial \\xi_i} = 0 &amp;\\implies C - a_i - u_i = 0<br>\\end{aligned}<br>$$</p>\n<p>我们将上面三个式子代入目标函数：<br>$$<br>\\begin{aligned}<br>L(\\omega, b, \\xi, \\mathbf{a}, \\mathbf{u}) &amp;= \\frac{1}{2} \\omega^T\\omega + C \\sum^n_{i=1} \\xi_i - \\sum^n_{i=1} a_i \\big( y_i(\\omega^T \\mathbf{x}<em>i + b) - 1 + \\xi_i \\big) - \\sum\\</em>{i=1}^n u_i \\xi_i\\\\<br>&amp;= \\frac{1}{2} \\bigg( \\sum_{i=1}^n a_i y_i \\mathbf{x}<em>i^T \\bigg) \\bigg( \\sum\\</em>{j=1}^n a_j y_j \\mathbf{x}<em>j \\bigg) + C \\sum^n\\</em>{i=1} \\xi_i - \\sum^n_{i=1} a_i \\bigg( y_i(\\sum_{j=1}^n a_j y_j \\mathbf{x}<em>j^T) \\cdot \\mathbf{x}_i + b) - 1 + \\xi_i \\bigg) - \\sum\\</em>{i=1}^n (C - a_i) \\xi_i\\\\<br>&amp;= \\frac{1}{2}  \\sum_{i,j=1}^n a_i a_j y_i y_j \\mathbf{x}<em>i^T \\mathbf{x}_j - \\sum\\</em>{i,j=1}^n a_i a_j y_i y_j \\mathbf{x}<em>i^T \\mathbf{x}_j - b \\sum\\</em>{i=1}^n a_i y_i + \\sum_{i=1}^n a_i\\\\<br>&amp;= \\sum_{i=1}^n a_i - \\frac{1}{2}  \\sum_{i,j=1}^n a_i a_j y_i y_j \\mathbf{x}_i^T \\mathbf{x}_j<br>\\end{aligned}<br>$$</p>\n<p>其中通过 $C - a_i - u_i = 0$ 推导出约束条件：<br>$$<br>C \\ge a_i \\ge 0<br>$$</p>\n<p>来到这里发现式子跟2.1节的一模一样，它们的区别只在于约束条件：<br>$$<br>\\begin{aligned}<br>&amp;C \\ge a_i \\ge 0, &amp;\\sum_{i=1}^n a_i y_i = 0<br>\\end{aligned}<br>$$</p>\n","site":{"data":{}},"excerpt":"","more":"<script type=\"text/javascript\" async src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML\"> </script>\n\n<h1 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h1><p>支持向量机(Support Vector Machines, SVM)是 Vapnik 等人根据统计学习理论中结构风险最小化原则提出的，SVM能够尽量提高学习机的推广能力，即使由有限数据集得到的判别函数对独立的测试集仍能够得到较小的误差。此外，支持向量机是一个凸二次优化问题，能够保证找到极值解就是全局最优解。这个特点使支持向量机成为一种优秀的基于数据的机器学习算法。</p>\n<h1 id=\"二、算法思想\"><a href=\"#二、算法思想\" class=\"headerlink\" title=\"二、算法思想\"></a>二、算法思想</h1><p>SVM算法的主要思想是：在N维空间中寻找一个最优划分超平面，使得用于分类训练的样本点根据自身类别完全划分在这个分割超平面的两侧，并且要求所有样本点到分割超平面的距离的最小值要最大。</p>\n<p>下面用一个二维空间的图来解释这句话<br><img src=\"http://www.blogjava.net/images/blogjava_net/zhenandaci/WindowsLiveWriter/SVMRefresh_9B92/image_thumb.png\" alt></p>\n<p>因为这里是二维空间，分割超平面就是一条直线，我们简称它是<strong>分类线</strong>。$H_1$、$H_2$ 分别为过各类中离分类线最近的数据样本且平行于分类线的直线，$H_1,H_2$之间的间隔我们称为<strong>分类间隔</strong>。我们的目标就是求得这条<strong>最优分类线</strong>的方程，所谓<strong>最优分类线</strong>就是要做到分类错误率为0，且分类间隔最大。</p>\n<h2 id=\"2-1-最优分类超平面\"><a href=\"#2-1-最优分类超平面\" class=\"headerlink\" title=\"2.1 最优分类超平面\"></a>2.1 最优分类超平面</h2><p>在n维空间中，定义一个超平面的一般形式为<br>$$<br>\\omega^T \\mathbf{x} + \\mathbf{b} = 0<br>$$</p>\n<p>假设单个训练样本的特征值为 $\\mathbf{x}=[x_1, x_2, \\cdots, x_n]$ 对应样本点坐标为 $(x_1, x_2, \\cdots, x_n)$。我们可以通过以下线性判别函数判别样本点的分类情况：<br>$$<br>f(\\mathbf{x}) = \\omega^T \\mathbf{x} + \\mathbf{b}<br>$$</p>\n<p>它把 $f(\\mathbf{x}) &gt; 0$ 和 $f(\\mathbf{x}) &lt; 0$ 的样本点分为了两类，所以我们定义分类标签为 $y$，$y$ 的取值为 -1 或 +1 分别表示不同的两个类别：<br>$$<br>y = sign(f(\\mathbf{x})) = sign(\\omega^T \\mathbf{x} + \\mathbf{b})<br>$$</p>\n<p>因为y在训练样本中是已知的，因此我们可以用这样的函数表示样本点 $\\mathbf{x}$ 到分割超平面的距离值：<br>$$<br>D(\\mathbf{x}) = \\frac{|f(\\mathbf{x})|}{|\\omega|} = \\frac{y(\\omega^T \\mathbf{x} + \\mathbf{b})}{|\\omega|}<br>$$</p>\n<p>我们可以线性变换 $f(x)$ 使得它对于所有的样本点都能满足： $|f(x)| \\ge 1$，其中离分类超平面最近的样本点 $\\mathbf{x}^\\ast$ 满足 $ | f(\\mathbf{x}^\\ast) |=1 $。我们的距离函数 $D(\\mathbf{x})$ 就得到如下不等式关系：<br>$$<br>\\begin{aligned}<br>D(\\mathbf{x}) \\ge \\frac{1}{|\\omega|}<br>\\end{aligned}<br>$$</p>\n<p>只要找到 $\\omega^\\ast$ 使得 $|\\omega^\\ast| = \\min{|\\omega|}$，$\\min D(\\mathbf{x})$ 就能取得最大值，此时的 $f(\\mathbf{x})=0$ 就是我们要找的<strong>最优分割超平面</strong>的一般形式。</p>\n<p>求 $\\frac{1}{|\\omega|}$ 的最大值，相当于求 $\\frac{1}{2}|\\omega|^2$ 的最小值(乘上 $\\frac{1}{2}$ 是为了后面求导方便)。</p>\n<p>这样我们把整体目标定为：求<br>$$<br>\\begin{aligned}<br>&amp; &amp;\\min_{\\omega,b} \\frac{1}{2} \\omega^T\\omega \\\\<br>&amp;\\text{s.t.}    &amp;y_i(\\mathbf{\\omega} \\cdot \\mathbf{x}_i + \\mathbf{b}) \\ge 1<br>\\end{aligned}<br>$$</p>\n<p>它是一个只有不等式约束的优化问题，我们构建拉格朗日函数(参考 <a href=\"http://blog.csdn.net/wangkr111/article/details/21170809\" target=\"_blank\" rel=\"noopener\">拉格朗日对偶</a> 以及 <a href=\"http://www.cnblogs.com/zhangchaoyang/articles/2726873.html\" target=\"_blank\" rel=\"noopener\">拉格朗日乘子法和KKT条件</a>)：<br>$$<br>\\begin{aligned}<br>L(\\omega, b, \\mathbf{a}) &amp;= \\frac{1}{2} \\omega^T\\omega - \\sum^n_{i=1} a_i \\big( y_i(\\omega^T \\mathbf{x}_i + b) - 1 \\big), &amp;\\text{其中拉格朗日乘子 } a_i \\ge 0<br>\\end{aligned}<br>$$</p>\n<p>当 $\\omega, b, \\mathbf{a}$ 满足KKT条件时，拉格朗日对偶问题的解就是原问题的最优解，即<br>$$<br>\\displaystyle\\min_{w,b} \\displaystyle\\max_{a} L(\\omega, b, \\mathbf{a})<br>= \\displaystyle\\max_{a} \\displaystyle\\min_{w,b} L(\\omega, b, \\mathbf{a})<br>= \\min \\frac{1}{2} \\omega^T\\omega<br>$$</p>\n<p>以下列出KKT条件：<br>$$<br>\\begin{cases}<br>\\frac{\\partial L(\\omega, b, \\mathbf{a})}{\\partial \\omega} = 0\\\\<br>\\frac{\\partial L(\\omega, b, \\mathbf{a})}{\\partial b} = 0\\\\<br>a_i \\big( y_i(\\omega^T \\mathbf{x}_i + b) - 1 \\big) = 0\\\\<br>y_i(\\omega^T \\mathbf{x}_i + b) \\ge 1\\\\<br>a_i \\ge 0<br>\\end{cases}<br>$$</p>\n<p>因为该式子的最小值出现在各个变量偏求导等于0处：<br>$$<br>\\begin{aligned}<br>\\frac{\\partial L(\\omega, b, \\mathbf{a})}{\\partial \\omega} = 0 &amp;\\implies \\omega = \\sum_{i=1}^n a_i y_i \\mathbf{x}<em>i\\\\<br>\\frac{\\partial L(\\omega, b, \\mathbf{a})}{\\partial b} = 0 &amp;\\implies \\sum\\</em>{i=1}^n a_i y_i = 0<br>\\end{aligned}<br>$$</p>\n<p>将上述二式代入目标函数：<br>$$<br>\\begin{aligned}<br>L(\\omega, b, \\mathbf{a}) &amp;= \\frac{1}{2} \\omega^T\\omega - \\sum^n_{i=1} a_i \\big( y_i(\\omega^T \\mathbf{x}<em>i + b) - 1 \\big)\\\\<br>&amp;= \\frac{1}{2} \\bigg( \\sum\\</em>{i=1}^n a_i y_i \\mathbf{x}<em>i^T \\bigg) \\bigg( \\sum\\</em>{j=1}^n a_j y_j \\mathbf{x}<em>j \\bigg) - \\sum^n\\</em>{i=1} a_i \\bigg( y_i(\\sum_{j=1}^n a_j y_j \\mathbf{x}<em>j^T) \\cdot \\mathbf{x}_i + b) - 1 \\bigg)\\\\<br>&amp;= \\frac{1}{2}  \\sum\\</em>{i,j=1}^n a_i a_j y_i y_j \\mathbf{x}<em>i^T \\mathbf{x}_j - \\sum\\</em>{i,j=1}^n a_i a_j y_i y_j \\mathbf{x}<em>i^T \\mathbf{x}_j - b \\sum\\</em>{i=1}^n a_i y_i + \\sum_{i=1}^n a_i\\\\<br>&amp;= \\sum_{i=1}^n a_i - \\frac{1}{2}  \\sum_{i,j=1}^n a_i a_j y_i y_j \\mathbf{x}_i^T \\mathbf{x}_j<br>\\end{aligned}<br>$$</p>\n<p>来到这里，这个最优化问题已经跟 $\\omega$ 以及 $b$ 无关了，可以把上述问题转化为如下凸二次规划寻优的对偶问题：<br>$$<br>\\begin{cases}<br>\\max \\displaystyle\\sum_{i=1}^n a_i - \\frac{1}{2}  \\sum_{i,j=1}^n a_i a_j y_i y_j \\mathbf{x}<em>i^T \\mathbf{x}_j\\\\<br>a_i \\ge 0\\\\<br>\\displaystyle\\sum\\</em>{i=1}^n a_i y_i = 0<br>\\end{cases}<br>$$</p>\n<p>若找到一个最优解 $\\mathbf{a}^\\star$，我们就可以通过如下式子求出 $\\omega^\\star$:<br>$$<br>\\omega^\\star = \\sum_{i=1}^n a^\\star_i y_i \\mathbf{x}_i<br>$$</p>\n<p>求完 $\\omega^\\star$ 之后我们来求 $b^\\star$。分布在决策边界上的样本集，即为<strong>支持向量</strong>，只有它们会对决策边界产生影响。因此，我们只要利用其中一个支持向量 $\\mathbf{x}_i$ 它们必定满足下列等式，从而求得 $b^\\star$:<br>$$<br>\\begin{aligned}<br>&amp;y_i(\\omega^T \\mathbf{x}_i + b^\\star) = 1, &amp;\\text{其中 } \\mathbf{x}_i \\text{ 为支持向量}<br>\\end{aligned}<br>$$</p>\n<p>在拉格朗日对偶问题求解时，若 $y_i(\\omega^T \\mathbf{x}<em>i + b) &gt; 1$ 时，对偶函数 $\\displaystyle\\min\\</em>{w,b} \\displaystyle\\max_{a} L(\\omega, b, \\mathbf{a})$ 会调整系数 $a_i = 0$ 使得结果最大，所以对于 $a_i \\ne 0$ 对应的样本就是我们要找的<strong>支持向量</strong>，这些样本满足 $y_i(\\omega^T \\mathbf{x}_i + b) = 1$。</p>\n<h2 id=\"2-2-防止过拟合\"><a href=\"#2-2-防止过拟合\" class=\"headerlink\" title=\"2.2 防止过拟合\"></a>2.2 防止过拟合</h2><p>有些时候，可能会因为数据有误差或者是为了防止数据过拟合而允许分类器容忍一定程度的误差，我们为原来的约束条件 $|f(\\mathbf{x})| \\ge 1$ 添加一个松弛变量:<br>$$<br>\\begin{aligned}<br>|f(\\mathbf{x})| &amp;\\ge 1 - \\xi,     &amp;\\text{其中 }0 \\le \\xi\\\\<br>\\implies y_i( \\omega^T \\mathbf{x} + \\mathbf{b} ) &amp;\\ge 1 - \\xi<br>\\end{aligned}<br>$$</p>\n<p>添加松弛变量后效果如下图:<br><img src=\"http://images.cnitblog.com/blog/458371/201212/31223704-0758d0b56ff7413985d4dacd3b0431d5.jpg\" alt></p>\n<p>从图中我们可以看出，当 $0 \\le \\xi \\lt 1$ 时，分类器依然能正确分类；当 $1 \\lt \\xi$ 时，分类器得到的分类结果会有错误。</p>\n<p>我们在能容忍分类器存在一定错误的情况下，希望总体误差很小，并且使得分类间隔足够大，我们把目标函数改为求：<br>$$<br>\\begin{aligned}<br>&amp;\\displaystyle\\min_{\\omega,b,\\xi} \\bigg( \\frac{1}{2} \\omega^T\\omega + C \\sum^n_{i=1} \\xi_i \\bigg), &amp;\\text{其中 } C &gt; 0 \\text{ 且 } \\xi_i \\ge 0\\\\<br>&amp;s.t. \\space\\space\\space\\space y( \\omega^T \\mathbf{x} + \\mathbf{b} ) \\ge 1 - \\xi\\\\<br>&amp;\\space\\space\\space\\space\\space\\space\\space\\space\\space\\space \\xi_i \\ge 0<br>\\end{aligned}<br>$$</p>\n<p>其中 $C$ 是我们预设的参数，它的大小影响误差值 $\\xi$ 所占的权重。当 $C=+\\infty$ 只要有一个 $\\xi_i \\ne 0$ 则整个目标函数就等于无穷大，这意味着分类器不能容忍有一丝误差（相当于回归到2.1节的目标函数：$\\displaystyle\\min_{\\omega,b} \\frac{1}{2} \\omega^T\\omega$）。</p>\n<p>我们依然使用“拉格朗日乘子法”解决带约束的最优化问题：<br>$$<br>\\begin{aligned}<br>L(\\omega, b, \\xi, \\mathbf{a}, \\mathbf{u}) &amp;= \\frac{1}{2} \\omega^T\\omega + C \\sum^n_{i=1} \\xi_i - \\sum^n_{i=1} a_i \\big( y_i(\\omega^T \\mathbf{x}<em>i + b) - 1 + \\xi_i \\big) - \\sum\\</em>{i=1}^n u_i \\xi_i, &amp;\\text{其中拉格朗日乘子 } a_i, u_i \\ge 0<br>\\end{aligned}<br>$$</p>\n<p>因为该式子的最小值出现在各个变量偏求导等于0处：<br>$$<br>\\begin{aligned}<br>\\frac{\\partial L(\\omega, b, \\xi, \\mathbf{a}, \\mathbf{u})}{\\partial \\omega} = 0 &amp;\\implies \\omega = \\sum_{i=1}^n a_i y_i \\mathbf{x}<em>i\\\\<br>\\frac{\\partial L(\\omega, b, \\xi, \\mathbf{a}, \\mathbf{u})}{\\partial b} = 0 &amp;\\implies \\sum\\</em>{i=1}^n a_i y_i = 0\\\\<br>\\frac{\\partial L(\\omega, b, \\xi, \\mathbf{a}, \\mathbf{u})}{\\partial \\xi_i} = 0 &amp;\\implies C - a_i - u_i = 0<br>\\end{aligned}<br>$$</p>\n<p>我们将上面三个式子代入目标函数：<br>$$<br>\\begin{aligned}<br>L(\\omega, b, \\xi, \\mathbf{a}, \\mathbf{u}) &amp;= \\frac{1}{2} \\omega^T\\omega + C \\sum^n_{i=1} \\xi_i - \\sum^n_{i=1} a_i \\big( y_i(\\omega^T \\mathbf{x}<em>i + b) - 1 + \\xi_i \\big) - \\sum\\</em>{i=1}^n u_i \\xi_i\\\\<br>&amp;= \\frac{1}{2} \\bigg( \\sum_{i=1}^n a_i y_i \\mathbf{x}<em>i^T \\bigg) \\bigg( \\sum\\</em>{j=1}^n a_j y_j \\mathbf{x}<em>j \\bigg) + C \\sum^n\\</em>{i=1} \\xi_i - \\sum^n_{i=1} a_i \\bigg( y_i(\\sum_{j=1}^n a_j y_j \\mathbf{x}<em>j^T) \\cdot \\mathbf{x}_i + b) - 1 + \\xi_i \\bigg) - \\sum\\</em>{i=1}^n (C - a_i) \\xi_i\\\\<br>&amp;= \\frac{1}{2}  \\sum_{i,j=1}^n a_i a_j y_i y_j \\mathbf{x}<em>i^T \\mathbf{x}_j - \\sum\\</em>{i,j=1}^n a_i a_j y_i y_j \\mathbf{x}<em>i^T \\mathbf{x}_j - b \\sum\\</em>{i=1}^n a_i y_i + \\sum_{i=1}^n a_i\\\\<br>&amp;= \\sum_{i=1}^n a_i - \\frac{1}{2}  \\sum_{i,j=1}^n a_i a_j y_i y_j \\mathbf{x}_i^T \\mathbf{x}_j<br>\\end{aligned}<br>$$</p>\n<p>其中通过 $C - a_i - u_i = 0$ 推导出约束条件：<br>$$<br>C \\ge a_i \\ge 0<br>$$</p>\n<p>来到这里发现式子跟2.1节的一模一样，它们的区别只在于约束条件：<br>$$<br>\\begin{aligned}<br>&amp;C \\ge a_i \\ge 0, &amp;\\sum_{i=1}^n a_i y_i = 0<br>\\end{aligned}<br>$$</p>\n"},{"_content":"<script type=\"text/javascript\" async src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML\"> </script>\n\n# 一、分类问题概述\n对于分类问题，其实谁都不会陌生，说我们每个人每天都在执行分类操作一点都不夸张，只是我们没有意识到罢了。例如，当你看到一个陌生人，你的脑子下意识判断TA是男是女；你可能经常会走在路上对身旁的朋友说“这个人一看就很有钱、那边有个非主流”之类的话，其实这就是一种分类操作。\n\n从数学角度来说，分类问题可做如下定义：\n\n已知集合：$C={y_1,y_2,\\cdots,y_n}$ 和 $I={x_1,x_2,\\cdots,x_n}$，确定映射规则$y=f(x)$，使得任意$x_i \\in I$有且仅有$y_j \\in C$一个使得$y_j=f(x_i)$成立。（不考虑模糊数学里的模糊集情况）\n\n其中C叫做类别集合，其中每一个元素是一个类别，而I叫做项集合，其中每一个元素是一个待分类项，f叫做分类器。分类算法的任务就是构造分类器f。\n\n这里要着重强调，分类问题往往采用经验性方法构造映射规则，即一般情况下的分类问题缺少足够的信息来构造100%正确的映射规则，而是通过对经验数据的学习从而实现一定概率意义上正确的分类，因此所训练出的分类器并不是一定能将每个待分类项准确映射到其分类，分类器的质量与分类器构造方法、待分类数据的特性以及训练样本数量等诸多因素有关。\n\n例如，医生对病人进行诊断就是一个典型的分类过程，任何一个医生都无法直接看到病人的病情，只能观察病人表现出的症状和各种化验检测数据来推断病情，这时医生就好比一个分类器，而这个医生诊断的准确率，与他当初受到的教育方式（构造方法）、病人的症状是否突出（待分类数据的特性）以及医生的经验多少（训练样本数量）都有密切关系。\n\n# 二、 预备知识\n## 2.1 条件概率公式\n设A,B两个事件，P(B)>0，则在事件B发生条件下，事件A发生的条件概率为：\n$$\nP(A|B)=\\frac{P(AB)}{P(B)}\n$$\n\n实例：盒子里面有黑色和白色两种颜色的模具，它们的比例是6:4(黑:白)。黑色模具全都是立方体，白色模具有一半是立方体一半是球体(5:5)。\n\n假设摸到白球的事件为A，摸到黑球的事件为$\\bar{A}$，摸到立方体模具的事件为B，摸到球体模具的事件为$\\bar{B}$。\n\n假设我伸手到盒子里摸到了一个立方体模具(事件B)，那么这个模具是白色(事件A)的概率就是$P(A|B)$。\n反过来，我们假设我已经知道摸到的模具是白色(事件A)，那么这个模具是球体(事件$\\bar{B}$)的概率就是$P(\\bar{B}|A)$\n\n## 2.2 乘法公式\n由条件概率公式得乘法公式：\n$$\nP(AB) = P(A|B)P(B) = P(B|A)P(A)\n$$\n\n推广：对于任何正数$n \\ge 2$，当$P(A_1 A_2 \\cdots A_{n-1}) > 0$时，有\n$$\nP(A_1 A_2 \\cdots A_{n-1} A_n) = P(A_n | A_1 A_2 \\cdots A_{n-1}) P(A_1 A_2 \\cdots A_{n-1})\n$$\n\n## 2.3 全概率公式\n如果事件组 $B_1,B_2,\\cdots, B_n$ 满足\n\n1. $B_i \\cap B_j = \\emptyset$, $i \\ne j$ 且 $P(B_i)>0$ 且 $i,j=1,2,\\cdots,n$\n2. $B_1 \\cup B_2 \\cup \\cdots \\cup B_n = \\Omega$，则称事件组 $B_1,B_2, \\cdots ,B_n$ 是样本空间$\\Omega$的一个划分\n\n设 $B_1 B_2 \\cdots$ 是样本空间$\\Omega$的一个划分，A为任一事件，则：\n$$\nP(A) = \\sum^n_{i=1} P(B_i)P(A|B_i)\n$$\n上式即为全概率公式.\n\n全概率公式的意义在于，当直接计算$P(A)$较为困难,而$P(B_i),P(A|B_i) \\space\\space (i=1,2,\\cdots,n)$的计算较为简单时，可以利用全概率公式计算$P(A)$。思想就是，将事件A分解成几个小事件，通过求小事件的概率，然后相加从而求得事件A的概率，而将事件A进行分割的时候，不是直接对A进行分割，而是先找到样本空间$\\Omega$的一个个划分$B_1,B_2,\\cdots,B_n$,这样事件A就被事件$AB_1,AB_2,\\cdots,AB_n$分解成了n部分，即$A=AB_1+AB_2+...+AB_n$, 每一$B_i$发生都可能导致A发生相应的概率是P(A|Bi)，由加法公式得\n$$\n\\begin{aligned}\n         P(A)&=P(AB_1)+P(AB_2)+\\cdots+P(AB_n)\\\\\\\\\n             &=P(A|B_1)P(B_1)+P(A|B_2)P(B_2)+\\cdots+P(A|B_n)P(PB_n)\n\\end{aligned}\n$$\n\n实例：某车间用甲、乙、丙三台机床进行生产，各台机床次品率分别为5%，4%，2%，它们各自的产品分别占总量的25%，35%，40%，将它们的产品混在一起，求任取一个产品是次品的概率。\n\n设: 抽取一个产品是甲、乙、丙机床生产的事件分别为$A_1, A_2, A_3$，抽取到产品是次品的事件为$B$。根据全概率公式得:\n$$\n\\begin{aligned}\nP(B) &= P(A_1B) + P(A_2B) + P(A_3B)\\\\\\\\\n     &= P(B|A_1)P(A_1) + P(B|A_2)P(A_2) + P(B|A_3)P(A_3)\\\\\\\\\n     &= 0.05 * 0.25 + 0.04 * 0.35 + 0.02 * 0.40\\\\\\\\\n     &= 0.0345\n\\end{aligned}\n$$\n\n## 2.4 贝叶斯公式\n与全概率公式解决的问题相反，贝叶斯公式是建立在条件概率的基础上寻找事件发生的原因（即大事件A已经发生的条件下，分割中的小事件$B_i$的概率），设$B_1,B_2,\\cdots$是样本空间$\\Omega$的一个划分，则对任一事件A（P(A)>0),有\n$$\n\\begin{aligned}\nP(B_i|A) &= \\frac{P(AB_i)}{P(A)}                                            &\\text{条件概率}\\\\\\\\\n         &= \\frac{P(A|B_i)P(B_i)}{P(A)}                                     &\\text{乘法公式}\\\\\\\\\n         &= \\frac{P(A|B_i)P(B_i)}{ \\sum^n_{j=1} P(AB_j) }                   &\\text{全概率公式}\\\\\\\\\n         &= \\frac{P(A|B_i)P(B_i)}{ \\sum^n_{j=1} P(A|B_j)P(B_j) }\n\\end{aligned}\n$$\n\n上式即为贝叶斯公式，$B_i$常被视为导致试验结果A发生的”原因“，$P(B_i)(i=1,2,\\cdots,n)$表示各种原因发生的可能性大小，故称**先验概率**；$P(B_i|A)(i=1,2,\\cdots,n)$则反映当试验产生了结果A之后，再对各种原因概率的新认识，故称**后验概率**。\n\n实例：发报台分别以概率0.6和0.4发出信号“∪”和“—”。由于通信系统受到干扰，当发出信号“∪”时，收报台分别以概率0.8和0.2收到信号“∪”和“—”；又当发出信号“—”时，收报台分别以概率0.9和0.1收到信号“—”和“∪”。求当收报台收到信号“∪”时，发报台确系发出“∪”的概率。\n\n设: 发报台发送信号\"u\"的事件为$A$，发送信号\"-\"的事件为$\\bar{A}$，收报台收到信号\"u\"的事件为$B$。根据贝叶斯公式得：\n$$\n\\begin{aligned}\nP(A|B)  &= \\frac{P(B|A)P(A)}{P(B|A)P(A) + P(B|\\bar{A})P(\\bar{A})}\\\\\\\\\n        &= \\frac{0.8 * 0.6}{0.8 * 0.6 + 0.1 * 0.4}\\\\\\\\\n        &\\approx 0.923\n\\end{aligned}\n$$\n\n## 2.5 相互独立事件\n相互独立事件: 就是事件A（或B）是否发生对事件B（A）发生的概率没有影响，这样的两个事件叫做相互独立事件。所以有\n$$\nP(A) = P(A|B)\\\\\\\\\nP(B) = P(B|A)\n$$\n\n根据条件概率公式可以推导出\n$$\nP(AB) = P(A|B)P(B) = P(B|A)P(A) = P(A)P(B)\n$$\n\n**相互独立事件**的性质将会在下面”朴素贝叶斯“算法中用到。\n\n# 三、朴素贝叶斯分类\n朴素贝叶斯分类是一种十分简单的分类算法，叫它朴素贝叶斯分类是因为这种方法的思想真的很朴素，朴素贝叶斯的思想基础是这样的：对于给出的待分类项，求解在此项出现的条件下各个类别出现的概率，哪个最大，就认为此待分类项属于哪个类别。通俗来说，就好比这么个道理，你在街上看到一个黑人，我问你你猜这哥们哪里来的，你十有八九猜非洲。为什么呢？因为黑人中非洲人的比率最高，当然人家也可能是美洲人或亚洲人，但在没有其它可用信息下，我们会选择条件概率最大的类别，这就是朴素贝叶斯的思想基础。\n\n## 训练\n\n先给出一些定义：\n1. 待分类数据的特征集为${X_1, X_2, \\cdots, X_n}$，其中对于每个特征$X_i$有特征值$x_i^{(1)},x_i^{(2)},\\cdots,x_i^{(|X_i|)}$\n2. 有实际类别集合为$Y={y_1, y_2, \\cdots, y_m}$。那么当$Y=y_j$时， $X_i=x_i^{(c_i)} (c_i=1,2,\\cdots,|X_i|)$ 的概率为$P(X_i=x_i^{(c_i)}|Y=y_j)$\n3. 假设所有特征是**条件独立**的，即满足\n$$\nP \\bigg( X_1=x_1^{(c_1)} \\cap X_2=x_2^{(c_2)} \\cap  \\cdots \\cap  X_n=x_n^{(c_n)} | Y=y_j \\bigg) = \\prod^n_{i=1} P(X_i=x_i^{(c_i)}|Y=y_j)\n$$\n其中 $c_i=1,2,\\cdots,|X_i|$。\n\n训练过程其实十分简单：\n1. 计算**先验概率**: $P(Y=y_j)(j=1,2,\\cdots,m)$，这个值就是类别为$y_i$的样本数除以整个训练集的样本数。\n2. 因为我们假设所有特征是**条件独立**的，则只需这样计算**后验概率**: $P(X_i=x_i^{(c_i)}|Y=y_j)(i=1,2,\\cdots,n;j=1,2,\\cdots,m)$ 的值\n\n**注意**：在训练集中，某个特征$X_i$取值为$x_i^{(c_i)}$的出现次数为0时，会导致$P(X_1=x_1^{(c_1)} \\cap X_2=x_2^{(c_2)} \\cap  \\cdots \\cap  X_n=x_n^{(c_n)} | Y=y_j)=0$。但实际中，可能只是训练集里面没有给出这样的数据，并不代表这样的事件就一定不发生，所以概率为0这个情况太绝对了，不符合实际要求。我们的解决方案是把那些出现次数为0的次数都设为1，让它的出现概率变得十分微小但也不至于是0.\n\n## 测试\n**贝叶斯分类器**的测试阶段十分简单，将传入的测试数据$X'$利用预先训练好的**贝叶斯分类器**计算 \n$$\n\\begin{aligned}\ny'_j &= argmax \\bigg( P(Y=y_j)P(X_1=x'_1 \\cap X_2=x'_2 \\cap  \\cdots \\cap  X_n=x'_n | Y=y_j) \\bigg) &(j=1,2,\\cdots,m)\\\\\\\\\n   &= argmax \\bigg( P(Y=y\\_j) \\prod^n\\_{i=1} P(X_i=x'_i | Y=y_j) \\bigg)\n\\end{aligned}\n$$\n得到的$y'_j$就是**贝叶斯分类器**的预测结果。\n\n## 实例：检测SNS社区中不真实账号\n这个问题是这样的，对于SNS社区来说，不真实账号（使用虚假身份或用户的小号）是一个普遍存在的问题，作为SNS社区的运营商，希望可以检测出这些不真实账号，从而在一些运营分析报告中避免这些账号的干扰，亦可以加强对SNS社区的了解与监管。\n\n如果通过纯人工检测，需要耗费大量的人力，效率也十分低下，如能引入自动检测机制，必将大大提升工作效率。这个问题说白了，就是要将社区中所有账号在真实账号和不真实账号两个类别上进行分类，下面我们一步一步实现这个过程。\n\n首先设 C=0 表示**真实账号**，C=1 表示**不真实账号**。\n\n### 1. 确定特征属性及划分\n\n这一步要找出可以帮助我们区分真实账号与不真实账号的特征属性，在实际应用中，特征属性的数量是很多的，划分也会比较细致，但这里为了简单起见，我们用少量的特征属性以及较粗的划分，并对数据做了修改。\n\n我们选择三个特征属性：\n\n* $a_1$ - 日志数量/注册天数\n* $a_2$ - 好友数量/注册天数\n* $a_3$ - 是否使用真实头像。\n \n在SNS社区中这三项都是可以直接从数据库里得到或计算出来的。\n\n下面对数值型特征进行离散化：\n\n* $a_1$ - {$a_1 \\le 0.05$, $0.05 < a_1 < 0.2$, $a_1 \\ge 0.2$}\n* $a_2$ - {$a_2 \\le 0.1$, $0.1 < a_2 < 0.8$, $a_2 \\ge 0.8$}\n* $a_3$ - {$a_3=0$ (不是), $a_3=1$ (是)}\n\n### 2. 获取训练样本\n这里使用运维人员曾经人工检测过的1万个账号作为训练样本。\n\n### 3. 计算先验概率\n用训练样本中真实账号和不真实账号数量分别除以一万，得到：\n$$\nP(C=0)=8900/10000=0.89\\\\\\\\\nP(C=1)=1100/100000=0.11\n$$\n\n### 4. 计算后验概率\n我们用表格表示每个类别条件下各个特征属性划分的频率。\n\n$P(a_1$ &#124; $C)$ | $a_1 \\le 0.05$ | $0.05 < a_1 < 0.2$ | $a_1 \\ge 0.2$\n------------------|----------------|--------------------|--------------\nC=0               |0.3             |0.5                 |0.2\nC=1               |0.8             |0.1                 |0.1\n\n$P(a_2$ &#124; $C)$ | $a_2 \\le 0.1$ | $0.1 < a_2 < 0.8$ | $a_2 \\ge 0.8$\n------------------|---------------|-------------------|--------------\nC=0               |0.1            |0.7                |0.2\nC=1               |0.7            |0.2                |0.1\n\n$P(a_3$ &#124; $C)$ | $a_3=0$ | $a_3=1$\n------------------|---------|--------\nC=0               |0.2      |0.8\nC=1               |0.9      |0.1\n\n### 5. 使用分类器进行鉴别\n下面我们使用上面训练得到的分类器鉴别一个账号，这个账号的特征属性为：$X'$ = {$a_1=0.1$, $a_2=0.2$, $a_3=0$}\n$$\n\\begin{aligned}\nP(C=0)P(X'|C=0) &= P(C=0) \\cdot P(0.05 < a_1 < 0.2|C=0) \\cdot P(0.1 < a_2 < 0.8|C=0) \\cdot P(a_3=0|C=0)\\\\\\\\\n                &= 0.89 * 0.5 * 0.7 * 0.2\\\\\\\\\n                &= 0.0623\\\\\\\\\n\\\\\\\\\nP(C=1)P(X'|C=1) &= P(C=1) \\cdot P(0.05 < a_1 < 0.2|C=1) \\cdot P(0.1 < a_2 < 0.8|C=1) \\cdot P(a_3=0|C=1)\\\\\\\\\n                &= 0.11 * 0.1 * 0.2 * 0.9\\\\\\\\\n                &= 0.00198\n\\end{aligned}\n$$\n算得C=0的概率更大一些，所以预测分类结果为“该账号是**真实账号**”。\n\n# 四、贝叶斯网络简介\n朴素贝叶斯分类有一个限制条件，就是特征属性必须有条件独立或基本独立（实际上在现实应用中几乎不可能做到完全独立）。当这个条件成立时，朴素贝叶斯分类法的准确率是最高的，但不幸的是，现实中各个特征属性间往往并不条件独立，而是具有较强的相关性，这样就限制了朴素贝叶斯分类的能力。我们接着上一篇文章的例子，讨论贝叶斯分类中更高级、应用范围更广的一种算法——贝叶斯网络（又称贝叶斯信念网络或信念网络）。\n\n上一篇文章我们使用朴素贝叶斯分类实现了SNS社区中不真实账号的检测。在那个解决方案中，我做了如下假设：\n\n1. 真实账号比非真实账号平均具有更大的日志密度、各大的好友密度以及更多的使用真实头像。\n2. 日志密度、好友密度和是否使用真实头像在账号真实性给定的条件下是独立的。\n\n但是，上述第二条假设很可能并不成立。一般来说，好友密度除了与账号是否真实有关，还与是否有真实头像有关，因为真实的头像会吸引更多人加其为好友。因此，我们为了获取更准确的分类，可以将假设修改如下：\n\n1. 真实账号比非真实账号平均具有更大的日志密度、各大的好友密度以及更多的使用真实头像。\n2. 日志密度与好友密度、日志密度与是否使用真实头像在账号真实性给定的条件下是独立的。\n3. 使用真实头像的用户比使用非真实头像的用户平均有更大的好友密度。\n\n上述假设更接近实际情况，但问题随之也来了，由于特征属性间存在依赖关系，使得朴素贝叶斯分类不适用了。既然这样，我去寻找另外的解决方案。下图表示特征属性之间的关联：\n\n![特征属性之间的关联](http://images.cnblogs.com/cnblogs_com/leoo2sk/WindowsLiveWriter/bc64e495f586_139A8/1_3.png)\n\n上图是一个有向无环图，每个节点代表一个随机变量，而有向边表示两个随机变量之间的联系，表示始节点影响终结点。不过仅有这个图的话，只能定性给出随机变量间的关系，如果要定量，还需要一些数据，这些数据就是每个节点对其直接前驱节点的条件概率，而没有前驱节点的节点则使用先验概率表示。\n\n继续利用上述例子中的数据，我们在训练过程中已经算好了这些概率：\n\nP(C=0)|P(C=1)\n------|------\n0.89  |0.11\n\n$P(a_3$ &#124; $C)$ | $a_3=0$ | $a_3=1$\n------------------|---------|--------\nC=0               |0.2      |0.8\nC=1               |0.9      |0.1\n\n上述得知 $P(a_3 | C)$ 以及 $P(C)$ 我们就可以通过贝叶斯公式求得反向概率，如：\n$$\n\\begin{aligned}\nP(C=1|a_3=0) &= \\frac{P(a_3=0|C=1)P(C=1)}{P(a_3=0)}\n             &= \\frac{P(a_3=0|C=1)P(C=1)}{P(a_3=0|C=1)P(C=1) + P(a_3=0|C=0)P(C=0)}\n             &= \\frac{0.9 * 0.11}{0.9 * 0.11 + 0.2 * 0.89}\n             &= 0.3574\n\\end{aligned}\n$$\n\n 也就是说，在仅知道头像为假的情况下，有大约35.7%的概率此账户也为假。\n\n## 贝叶斯网络的定义及性质\n\n一个贝叶斯网络定义包括一个有向无环图（DAG）和一个条件概率表集合。DAG中每一个节点表示一个随机变量，可以是可直接观测变量或隐藏变量，而有向边表示随机变量间的条件依赖；条件概率表中的每一个元素对应DAG中唯一的节点，存储此节点对于其所有直接前驱节点的联合条件概率。\n\n贝叶斯网络有一条极为重要的性质，就是我们断言每一个节点在其直接前驱节点的值制定后，这个节点条件独立于其所有非直接前驱前辈节点。\n\n一般情况下，多变量非独立联合条件概率分布有如下求取公式：\n$$\nP(x_1,x_2,\\cdots,x_n)=P(x_1)P(x_2|x_1)P(x_3|x_1x_2) \\cdots P(x_n|x_1x_2 \\cdots x_{n-1})\n$$\n\n而在贝叶斯网络中，由于存在前述性质，任意随机变量组合的联合条件概率分布被化简成:\n$$\nP(x_1x_2 \\cdots x_n)=\\prod^n_{i=1} P(x_i|Parent(x_i))\n$$\n\n其中Parent表示$x_i$的直接前驱节点的联合，概率值可以从相应条件概率表中查到。\n\n贝叶斯网络比朴素贝叶斯更复杂，而想构造和训练出一个好的贝叶斯网络更是异常艰难。但是贝叶斯网络是模拟人的认知思维推理模式，用一组条件概率函数以及有向无环图对不确定性的因果推理关系建模，因此其具有更高的实用价值。\n\n## 贝叶斯网络的构造及学习\n\n构造与训练贝叶斯网络分为以下两步：\n\n1. 确定随机变量间的拓扑关系，形成DAG。这一步通常需要领域专家完成，而想要建立一个好的拓扑结构，通常需要不断迭代和改进才可以。\n2. 训练贝叶斯网络。这一步也就是要完成条件概率表的构造，如果每个随机变量的值都是可以直接观察的，像我们上面的例子，那么这一步的训练是直观的，方法类似于朴素贝叶斯分类。但是通常贝叶斯网络的中存在隐藏变量节点，那么训练方法就是比较复杂，例如使用梯度下降法。由于这些内容过于晦涩以及牵扯到较深入的数学知识，在此不再赘述，有兴趣的朋友可以查阅相关文献。\n\n这里给出国内一本贝叶斯网络的书：[《动态贝叶斯网络推理学习理论及应用》](https://pan.baidu.com/s/1nuZXuzv)\n\n\n# 参考资料\n全概率公式、贝叶斯公式推导过程: http://www.cnblogs.com/ohshit/p/5629581.html  \n朴素贝叶斯、贝叶斯网络及相关实例：http://www.cnblogs.com/hexinuaa/articles/2143483.html","source":"_drafts/贝叶斯分类.md","raw":"<script type=\"text/javascript\" async src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML\"> </script>\n\n# 一、分类问题概述\n对于分类问题，其实谁都不会陌生，说我们每个人每天都在执行分类操作一点都不夸张，只是我们没有意识到罢了。例如，当你看到一个陌生人，你的脑子下意识判断TA是男是女；你可能经常会走在路上对身旁的朋友说“这个人一看就很有钱、那边有个非主流”之类的话，其实这就是一种分类操作。\n\n从数学角度来说，分类问题可做如下定义：\n\n已知集合：$C={y_1,y_2,\\cdots,y_n}$ 和 $I={x_1,x_2,\\cdots,x_n}$，确定映射规则$y=f(x)$，使得任意$x_i \\in I$有且仅有$y_j \\in C$一个使得$y_j=f(x_i)$成立。（不考虑模糊数学里的模糊集情况）\n\n其中C叫做类别集合，其中每一个元素是一个类别，而I叫做项集合，其中每一个元素是一个待分类项，f叫做分类器。分类算法的任务就是构造分类器f。\n\n这里要着重强调，分类问题往往采用经验性方法构造映射规则，即一般情况下的分类问题缺少足够的信息来构造100%正确的映射规则，而是通过对经验数据的学习从而实现一定概率意义上正确的分类，因此所训练出的分类器并不是一定能将每个待分类项准确映射到其分类，分类器的质量与分类器构造方法、待分类数据的特性以及训练样本数量等诸多因素有关。\n\n例如，医生对病人进行诊断就是一个典型的分类过程，任何一个医生都无法直接看到病人的病情，只能观察病人表现出的症状和各种化验检测数据来推断病情，这时医生就好比一个分类器，而这个医生诊断的准确率，与他当初受到的教育方式（构造方法）、病人的症状是否突出（待分类数据的特性）以及医生的经验多少（训练样本数量）都有密切关系。\n\n# 二、 预备知识\n## 2.1 条件概率公式\n设A,B两个事件，P(B)>0，则在事件B发生条件下，事件A发生的条件概率为：\n$$\nP(A|B)=\\frac{P(AB)}{P(B)}\n$$\n\n实例：盒子里面有黑色和白色两种颜色的模具，它们的比例是6:4(黑:白)。黑色模具全都是立方体，白色模具有一半是立方体一半是球体(5:5)。\n\n假设摸到白球的事件为A，摸到黑球的事件为$\\bar{A}$，摸到立方体模具的事件为B，摸到球体模具的事件为$\\bar{B}$。\n\n假设我伸手到盒子里摸到了一个立方体模具(事件B)，那么这个模具是白色(事件A)的概率就是$P(A|B)$。\n反过来，我们假设我已经知道摸到的模具是白色(事件A)，那么这个模具是球体(事件$\\bar{B}$)的概率就是$P(\\bar{B}|A)$\n\n## 2.2 乘法公式\n由条件概率公式得乘法公式：\n$$\nP(AB) = P(A|B)P(B) = P(B|A)P(A)\n$$\n\n推广：对于任何正数$n \\ge 2$，当$P(A_1 A_2 \\cdots A_{n-1}) > 0$时，有\n$$\nP(A_1 A_2 \\cdots A_{n-1} A_n) = P(A_n | A_1 A_2 \\cdots A_{n-1}) P(A_1 A_2 \\cdots A_{n-1})\n$$\n\n## 2.3 全概率公式\n如果事件组 $B_1,B_2,\\cdots, B_n$ 满足\n\n1. $B_i \\cap B_j = \\emptyset$, $i \\ne j$ 且 $P(B_i)>0$ 且 $i,j=1,2,\\cdots,n$\n2. $B_1 \\cup B_2 \\cup \\cdots \\cup B_n = \\Omega$，则称事件组 $B_1,B_2, \\cdots ,B_n$ 是样本空间$\\Omega$的一个划分\n\n设 $B_1 B_2 \\cdots$ 是样本空间$\\Omega$的一个划分，A为任一事件，则：\n$$\nP(A) = \\sum^n_{i=1} P(B_i)P(A|B_i)\n$$\n上式即为全概率公式.\n\n全概率公式的意义在于，当直接计算$P(A)$较为困难,而$P(B_i),P(A|B_i) \\space\\space (i=1,2,\\cdots,n)$的计算较为简单时，可以利用全概率公式计算$P(A)$。思想就是，将事件A分解成几个小事件，通过求小事件的概率，然后相加从而求得事件A的概率，而将事件A进行分割的时候，不是直接对A进行分割，而是先找到样本空间$\\Omega$的一个个划分$B_1,B_2,\\cdots,B_n$,这样事件A就被事件$AB_1,AB_2,\\cdots,AB_n$分解成了n部分，即$A=AB_1+AB_2+...+AB_n$, 每一$B_i$发生都可能导致A发生相应的概率是P(A|Bi)，由加法公式得\n$$\n\\begin{aligned}\n         P(A)&=P(AB_1)+P(AB_2)+\\cdots+P(AB_n)\\\\\\\\\n             &=P(A|B_1)P(B_1)+P(A|B_2)P(B_2)+\\cdots+P(A|B_n)P(PB_n)\n\\end{aligned}\n$$\n\n实例：某车间用甲、乙、丙三台机床进行生产，各台机床次品率分别为5%，4%，2%，它们各自的产品分别占总量的25%，35%，40%，将它们的产品混在一起，求任取一个产品是次品的概率。\n\n设: 抽取一个产品是甲、乙、丙机床生产的事件分别为$A_1, A_2, A_3$，抽取到产品是次品的事件为$B$。根据全概率公式得:\n$$\n\\begin{aligned}\nP(B) &= P(A_1B) + P(A_2B) + P(A_3B)\\\\\\\\\n     &= P(B|A_1)P(A_1) + P(B|A_2)P(A_2) + P(B|A_3)P(A_3)\\\\\\\\\n     &= 0.05 * 0.25 + 0.04 * 0.35 + 0.02 * 0.40\\\\\\\\\n     &= 0.0345\n\\end{aligned}\n$$\n\n## 2.4 贝叶斯公式\n与全概率公式解决的问题相反，贝叶斯公式是建立在条件概率的基础上寻找事件发生的原因（即大事件A已经发生的条件下，分割中的小事件$B_i$的概率），设$B_1,B_2,\\cdots$是样本空间$\\Omega$的一个划分，则对任一事件A（P(A)>0),有\n$$\n\\begin{aligned}\nP(B_i|A) &= \\frac{P(AB_i)}{P(A)}                                            &\\text{条件概率}\\\\\\\\\n         &= \\frac{P(A|B_i)P(B_i)}{P(A)}                                     &\\text{乘法公式}\\\\\\\\\n         &= \\frac{P(A|B_i)P(B_i)}{ \\sum^n_{j=1} P(AB_j) }                   &\\text{全概率公式}\\\\\\\\\n         &= \\frac{P(A|B_i)P(B_i)}{ \\sum^n_{j=1} P(A|B_j)P(B_j) }\n\\end{aligned}\n$$\n\n上式即为贝叶斯公式，$B_i$常被视为导致试验结果A发生的”原因“，$P(B_i)(i=1,2,\\cdots,n)$表示各种原因发生的可能性大小，故称**先验概率**；$P(B_i|A)(i=1,2,\\cdots,n)$则反映当试验产生了结果A之后，再对各种原因概率的新认识，故称**后验概率**。\n\n实例：发报台分别以概率0.6和0.4发出信号“∪”和“—”。由于通信系统受到干扰，当发出信号“∪”时，收报台分别以概率0.8和0.2收到信号“∪”和“—”；又当发出信号“—”时，收报台分别以概率0.9和0.1收到信号“—”和“∪”。求当收报台收到信号“∪”时，发报台确系发出“∪”的概率。\n\n设: 发报台发送信号\"u\"的事件为$A$，发送信号\"-\"的事件为$\\bar{A}$，收报台收到信号\"u\"的事件为$B$。根据贝叶斯公式得：\n$$\n\\begin{aligned}\nP(A|B)  &= \\frac{P(B|A)P(A)}{P(B|A)P(A) + P(B|\\bar{A})P(\\bar{A})}\\\\\\\\\n        &= \\frac{0.8 * 0.6}{0.8 * 0.6 + 0.1 * 0.4}\\\\\\\\\n        &\\approx 0.923\n\\end{aligned}\n$$\n\n## 2.5 相互独立事件\n相互独立事件: 就是事件A（或B）是否发生对事件B（A）发生的概率没有影响，这样的两个事件叫做相互独立事件。所以有\n$$\nP(A) = P(A|B)\\\\\\\\\nP(B) = P(B|A)\n$$\n\n根据条件概率公式可以推导出\n$$\nP(AB) = P(A|B)P(B) = P(B|A)P(A) = P(A)P(B)\n$$\n\n**相互独立事件**的性质将会在下面”朴素贝叶斯“算法中用到。\n\n# 三、朴素贝叶斯分类\n朴素贝叶斯分类是一种十分简单的分类算法，叫它朴素贝叶斯分类是因为这种方法的思想真的很朴素，朴素贝叶斯的思想基础是这样的：对于给出的待分类项，求解在此项出现的条件下各个类别出现的概率，哪个最大，就认为此待分类项属于哪个类别。通俗来说，就好比这么个道理，你在街上看到一个黑人，我问你你猜这哥们哪里来的，你十有八九猜非洲。为什么呢？因为黑人中非洲人的比率最高，当然人家也可能是美洲人或亚洲人，但在没有其它可用信息下，我们会选择条件概率最大的类别，这就是朴素贝叶斯的思想基础。\n\n## 训练\n\n先给出一些定义：\n1. 待分类数据的特征集为${X_1, X_2, \\cdots, X_n}$，其中对于每个特征$X_i$有特征值$x_i^{(1)},x_i^{(2)},\\cdots,x_i^{(|X_i|)}$\n2. 有实际类别集合为$Y={y_1, y_2, \\cdots, y_m}$。那么当$Y=y_j$时， $X_i=x_i^{(c_i)} (c_i=1,2,\\cdots,|X_i|)$ 的概率为$P(X_i=x_i^{(c_i)}|Y=y_j)$\n3. 假设所有特征是**条件独立**的，即满足\n$$\nP \\bigg( X_1=x_1^{(c_1)} \\cap X_2=x_2^{(c_2)} \\cap  \\cdots \\cap  X_n=x_n^{(c_n)} | Y=y_j \\bigg) = \\prod^n_{i=1} P(X_i=x_i^{(c_i)}|Y=y_j)\n$$\n其中 $c_i=1,2,\\cdots,|X_i|$。\n\n训练过程其实十分简单：\n1. 计算**先验概率**: $P(Y=y_j)(j=1,2,\\cdots,m)$，这个值就是类别为$y_i$的样本数除以整个训练集的样本数。\n2. 因为我们假设所有特征是**条件独立**的，则只需这样计算**后验概率**: $P(X_i=x_i^{(c_i)}|Y=y_j)(i=1,2,\\cdots,n;j=1,2,\\cdots,m)$ 的值\n\n**注意**：在训练集中，某个特征$X_i$取值为$x_i^{(c_i)}$的出现次数为0时，会导致$P(X_1=x_1^{(c_1)} \\cap X_2=x_2^{(c_2)} \\cap  \\cdots \\cap  X_n=x_n^{(c_n)} | Y=y_j)=0$。但实际中，可能只是训练集里面没有给出这样的数据，并不代表这样的事件就一定不发生，所以概率为0这个情况太绝对了，不符合实际要求。我们的解决方案是把那些出现次数为0的次数都设为1，让它的出现概率变得十分微小但也不至于是0.\n\n## 测试\n**贝叶斯分类器**的测试阶段十分简单，将传入的测试数据$X'$利用预先训练好的**贝叶斯分类器**计算 \n$$\n\\begin{aligned}\ny'_j &= argmax \\bigg( P(Y=y_j)P(X_1=x'_1 \\cap X_2=x'_2 \\cap  \\cdots \\cap  X_n=x'_n | Y=y_j) \\bigg) &(j=1,2,\\cdots,m)\\\\\\\\\n   &= argmax \\bigg( P(Y=y\\_j) \\prod^n\\_{i=1} P(X_i=x'_i | Y=y_j) \\bigg)\n\\end{aligned}\n$$\n得到的$y'_j$就是**贝叶斯分类器**的预测结果。\n\n## 实例：检测SNS社区中不真实账号\n这个问题是这样的，对于SNS社区来说，不真实账号（使用虚假身份或用户的小号）是一个普遍存在的问题，作为SNS社区的运营商，希望可以检测出这些不真实账号，从而在一些运营分析报告中避免这些账号的干扰，亦可以加强对SNS社区的了解与监管。\n\n如果通过纯人工检测，需要耗费大量的人力，效率也十分低下，如能引入自动检测机制，必将大大提升工作效率。这个问题说白了，就是要将社区中所有账号在真实账号和不真实账号两个类别上进行分类，下面我们一步一步实现这个过程。\n\n首先设 C=0 表示**真实账号**，C=1 表示**不真实账号**。\n\n### 1. 确定特征属性及划分\n\n这一步要找出可以帮助我们区分真实账号与不真实账号的特征属性，在实际应用中，特征属性的数量是很多的，划分也会比较细致，但这里为了简单起见，我们用少量的特征属性以及较粗的划分，并对数据做了修改。\n\n我们选择三个特征属性：\n\n* $a_1$ - 日志数量/注册天数\n* $a_2$ - 好友数量/注册天数\n* $a_3$ - 是否使用真实头像。\n \n在SNS社区中这三项都是可以直接从数据库里得到或计算出来的。\n\n下面对数值型特征进行离散化：\n\n* $a_1$ - {$a_1 \\le 0.05$, $0.05 < a_1 < 0.2$, $a_1 \\ge 0.2$}\n* $a_2$ - {$a_2 \\le 0.1$, $0.1 < a_2 < 0.8$, $a_2 \\ge 0.8$}\n* $a_3$ - {$a_3=0$ (不是), $a_3=1$ (是)}\n\n### 2. 获取训练样本\n这里使用运维人员曾经人工检测过的1万个账号作为训练样本。\n\n### 3. 计算先验概率\n用训练样本中真实账号和不真实账号数量分别除以一万，得到：\n$$\nP(C=0)=8900/10000=0.89\\\\\\\\\nP(C=1)=1100/100000=0.11\n$$\n\n### 4. 计算后验概率\n我们用表格表示每个类别条件下各个特征属性划分的频率。\n\n$P(a_1$ &#124; $C)$ | $a_1 \\le 0.05$ | $0.05 < a_1 < 0.2$ | $a_1 \\ge 0.2$\n------------------|----------------|--------------------|--------------\nC=0               |0.3             |0.5                 |0.2\nC=1               |0.8             |0.1                 |0.1\n\n$P(a_2$ &#124; $C)$ | $a_2 \\le 0.1$ | $0.1 < a_2 < 0.8$ | $a_2 \\ge 0.8$\n------------------|---------------|-------------------|--------------\nC=0               |0.1            |0.7                |0.2\nC=1               |0.7            |0.2                |0.1\n\n$P(a_3$ &#124; $C)$ | $a_3=0$ | $a_3=1$\n------------------|---------|--------\nC=0               |0.2      |0.8\nC=1               |0.9      |0.1\n\n### 5. 使用分类器进行鉴别\n下面我们使用上面训练得到的分类器鉴别一个账号，这个账号的特征属性为：$X'$ = {$a_1=0.1$, $a_2=0.2$, $a_3=0$}\n$$\n\\begin{aligned}\nP(C=0)P(X'|C=0) &= P(C=0) \\cdot P(0.05 < a_1 < 0.2|C=0) \\cdot P(0.1 < a_2 < 0.8|C=0) \\cdot P(a_3=0|C=0)\\\\\\\\\n                &= 0.89 * 0.5 * 0.7 * 0.2\\\\\\\\\n                &= 0.0623\\\\\\\\\n\\\\\\\\\nP(C=1)P(X'|C=1) &= P(C=1) \\cdot P(0.05 < a_1 < 0.2|C=1) \\cdot P(0.1 < a_2 < 0.8|C=1) \\cdot P(a_3=0|C=1)\\\\\\\\\n                &= 0.11 * 0.1 * 0.2 * 0.9\\\\\\\\\n                &= 0.00198\n\\end{aligned}\n$$\n算得C=0的概率更大一些，所以预测分类结果为“该账号是**真实账号**”。\n\n# 四、贝叶斯网络简介\n朴素贝叶斯分类有一个限制条件，就是特征属性必须有条件独立或基本独立（实际上在现实应用中几乎不可能做到完全独立）。当这个条件成立时，朴素贝叶斯分类法的准确率是最高的，但不幸的是，现实中各个特征属性间往往并不条件独立，而是具有较强的相关性，这样就限制了朴素贝叶斯分类的能力。我们接着上一篇文章的例子，讨论贝叶斯分类中更高级、应用范围更广的一种算法——贝叶斯网络（又称贝叶斯信念网络或信念网络）。\n\n上一篇文章我们使用朴素贝叶斯分类实现了SNS社区中不真实账号的检测。在那个解决方案中，我做了如下假设：\n\n1. 真实账号比非真实账号平均具有更大的日志密度、各大的好友密度以及更多的使用真实头像。\n2. 日志密度、好友密度和是否使用真实头像在账号真实性给定的条件下是独立的。\n\n但是，上述第二条假设很可能并不成立。一般来说，好友密度除了与账号是否真实有关，还与是否有真实头像有关，因为真实的头像会吸引更多人加其为好友。因此，我们为了获取更准确的分类，可以将假设修改如下：\n\n1. 真实账号比非真实账号平均具有更大的日志密度、各大的好友密度以及更多的使用真实头像。\n2. 日志密度与好友密度、日志密度与是否使用真实头像在账号真实性给定的条件下是独立的。\n3. 使用真实头像的用户比使用非真实头像的用户平均有更大的好友密度。\n\n上述假设更接近实际情况，但问题随之也来了，由于特征属性间存在依赖关系，使得朴素贝叶斯分类不适用了。既然这样，我去寻找另外的解决方案。下图表示特征属性之间的关联：\n\n![特征属性之间的关联](http://images.cnblogs.com/cnblogs_com/leoo2sk/WindowsLiveWriter/bc64e495f586_139A8/1_3.png)\n\n上图是一个有向无环图，每个节点代表一个随机变量，而有向边表示两个随机变量之间的联系，表示始节点影响终结点。不过仅有这个图的话，只能定性给出随机变量间的关系，如果要定量，还需要一些数据，这些数据就是每个节点对其直接前驱节点的条件概率，而没有前驱节点的节点则使用先验概率表示。\n\n继续利用上述例子中的数据，我们在训练过程中已经算好了这些概率：\n\nP(C=0)|P(C=1)\n------|------\n0.89  |0.11\n\n$P(a_3$ &#124; $C)$ | $a_3=0$ | $a_3=1$\n------------------|---------|--------\nC=0               |0.2      |0.8\nC=1               |0.9      |0.1\n\n上述得知 $P(a_3 | C)$ 以及 $P(C)$ 我们就可以通过贝叶斯公式求得反向概率，如：\n$$\n\\begin{aligned}\nP(C=1|a_3=0) &= \\frac{P(a_3=0|C=1)P(C=1)}{P(a_3=0)}\n             &= \\frac{P(a_3=0|C=1)P(C=1)}{P(a_3=0|C=1)P(C=1) + P(a_3=0|C=0)P(C=0)}\n             &= \\frac{0.9 * 0.11}{0.9 * 0.11 + 0.2 * 0.89}\n             &= 0.3574\n\\end{aligned}\n$$\n\n 也就是说，在仅知道头像为假的情况下，有大约35.7%的概率此账户也为假。\n\n## 贝叶斯网络的定义及性质\n\n一个贝叶斯网络定义包括一个有向无环图（DAG）和一个条件概率表集合。DAG中每一个节点表示一个随机变量，可以是可直接观测变量或隐藏变量，而有向边表示随机变量间的条件依赖；条件概率表中的每一个元素对应DAG中唯一的节点，存储此节点对于其所有直接前驱节点的联合条件概率。\n\n贝叶斯网络有一条极为重要的性质，就是我们断言每一个节点在其直接前驱节点的值制定后，这个节点条件独立于其所有非直接前驱前辈节点。\n\n一般情况下，多变量非独立联合条件概率分布有如下求取公式：\n$$\nP(x_1,x_2,\\cdots,x_n)=P(x_1)P(x_2|x_1)P(x_3|x_1x_2) \\cdots P(x_n|x_1x_2 \\cdots x_{n-1})\n$$\n\n而在贝叶斯网络中，由于存在前述性质，任意随机变量组合的联合条件概率分布被化简成:\n$$\nP(x_1x_2 \\cdots x_n)=\\prod^n_{i=1} P(x_i|Parent(x_i))\n$$\n\n其中Parent表示$x_i$的直接前驱节点的联合，概率值可以从相应条件概率表中查到。\n\n贝叶斯网络比朴素贝叶斯更复杂，而想构造和训练出一个好的贝叶斯网络更是异常艰难。但是贝叶斯网络是模拟人的认知思维推理模式，用一组条件概率函数以及有向无环图对不确定性的因果推理关系建模，因此其具有更高的实用价值。\n\n## 贝叶斯网络的构造及学习\n\n构造与训练贝叶斯网络分为以下两步：\n\n1. 确定随机变量间的拓扑关系，形成DAG。这一步通常需要领域专家完成，而想要建立一个好的拓扑结构，通常需要不断迭代和改进才可以。\n2. 训练贝叶斯网络。这一步也就是要完成条件概率表的构造，如果每个随机变量的值都是可以直接观察的，像我们上面的例子，那么这一步的训练是直观的，方法类似于朴素贝叶斯分类。但是通常贝叶斯网络的中存在隐藏变量节点，那么训练方法就是比较复杂，例如使用梯度下降法。由于这些内容过于晦涩以及牵扯到较深入的数学知识，在此不再赘述，有兴趣的朋友可以查阅相关文献。\n\n这里给出国内一本贝叶斯网络的书：[《动态贝叶斯网络推理学习理论及应用》](https://pan.baidu.com/s/1nuZXuzv)\n\n\n# 参考资料\n全概率公式、贝叶斯公式推导过程: http://www.cnblogs.com/ohshit/p/5629581.html  \n朴素贝叶斯、贝叶斯网络及相关实例：http://www.cnblogs.com/hexinuaa/articles/2143483.html","slug":"贝叶斯分类","published":0,"date":"2020-01-23T07:05:52.988Z","updated":"2018-06-08T00:03:38.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ck679mts9000zlbmdwsak5okm","content":"<script type=\"text/javascript\" async src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML\"> </script>\n\n<h1 id=\"一、分类问题概述\"><a href=\"#一、分类问题概述\" class=\"headerlink\" title=\"一、分类问题概述\"></a>一、分类问题概述</h1><p>对于分类问题，其实谁都不会陌生，说我们每个人每天都在执行分类操作一点都不夸张，只是我们没有意识到罢了。例如，当你看到一个陌生人，你的脑子下意识判断TA是男是女；你可能经常会走在路上对身旁的朋友说“这个人一看就很有钱、那边有个非主流”之类的话，其实这就是一种分类操作。</p>\n<p>从数学角度来说，分类问题可做如下定义：</p>\n<p>已知集合：$C={y_1,y_2,\\cdots,y_n}$ 和 $I={x_1,x_2,\\cdots,x_n}$，确定映射规则$y=f(x)$，使得任意$x_i \\in I$有且仅有$y_j \\in C$一个使得$y_j=f(x_i)$成立。（不考虑模糊数学里的模糊集情况）</p>\n<p>其中C叫做类别集合，其中每一个元素是一个类别，而I叫做项集合，其中每一个元素是一个待分类项，f叫做分类器。分类算法的任务就是构造分类器f。</p>\n<p>这里要着重强调，分类问题往往采用经验性方法构造映射规则，即一般情况下的分类问题缺少足够的信息来构造100%正确的映射规则，而是通过对经验数据的学习从而实现一定概率意义上正确的分类，因此所训练出的分类器并不是一定能将每个待分类项准确映射到其分类，分类器的质量与分类器构造方法、待分类数据的特性以及训练样本数量等诸多因素有关。</p>\n<p>例如，医生对病人进行诊断就是一个典型的分类过程，任何一个医生都无法直接看到病人的病情，只能观察病人表现出的症状和各种化验检测数据来推断病情，这时医生就好比一个分类器，而这个医生诊断的准确率，与他当初受到的教育方式（构造方法）、病人的症状是否突出（待分类数据的特性）以及医生的经验多少（训练样本数量）都有密切关系。</p>\n<h1 id=\"二、-预备知识\"><a href=\"#二、-预备知识\" class=\"headerlink\" title=\"二、 预备知识\"></a>二、 预备知识</h1><h2 id=\"2-1-条件概率公式\"><a href=\"#2-1-条件概率公式\" class=\"headerlink\" title=\"2.1 条件概率公式\"></a>2.1 条件概率公式</h2><p>设A,B两个事件，P(B)&gt;0，则在事件B发生条件下，事件A发生的条件概率为：<br>$$<br>P(A|B)=\\frac{P(AB)}{P(B)}<br>$$</p>\n<p>实例：盒子里面有黑色和白色两种颜色的模具，它们的比例是6:4(黑:白)。黑色模具全都是立方体，白色模具有一半是立方体一半是球体(5:5)。</p>\n<p>假设摸到白球的事件为A，摸到黑球的事件为$\\bar{A}$，摸到立方体模具的事件为B，摸到球体模具的事件为$\\bar{B}$。</p>\n<p>假设我伸手到盒子里摸到了一个立方体模具(事件B)，那么这个模具是白色(事件A)的概率就是$P(A|B)$。<br>反过来，我们假设我已经知道摸到的模具是白色(事件A)，那么这个模具是球体(事件$\\bar{B}$)的概率就是$P(\\bar{B}|A)$</p>\n<h2 id=\"2-2-乘法公式\"><a href=\"#2-2-乘法公式\" class=\"headerlink\" title=\"2.2 乘法公式\"></a>2.2 乘法公式</h2><p>由条件概率公式得乘法公式：<br>$$<br>P(AB) = P(A|B)P(B) = P(B|A)P(A)<br>$$</p>\n<p>推广：对于任何正数$n \\ge 2$，当$P(A_1 A_2 \\cdots A_{n-1}) &gt; 0$时，有<br>$$<br>P(A_1 A_2 \\cdots A_{n-1} A_n) = P(A_n | A_1 A_2 \\cdots A_{n-1}) P(A_1 A_2 \\cdots A_{n-1})<br>$$</p>\n<h2 id=\"2-3-全概率公式\"><a href=\"#2-3-全概率公式\" class=\"headerlink\" title=\"2.3 全概率公式\"></a>2.3 全概率公式</h2><p>如果事件组 $B_1,B_2,\\cdots, B_n$ 满足</p>\n<ol>\n<li>$B_i \\cap B_j = \\emptyset$, $i \\ne j$ 且 $P(B_i)&gt;0$ 且 $i,j=1,2,\\cdots,n$</li>\n<li>$B_1 \\cup B_2 \\cup \\cdots \\cup B_n = \\Omega$，则称事件组 $B_1,B_2, \\cdots ,B_n$ 是样本空间$\\Omega$的一个划分</li>\n</ol>\n<p>设 $B_1 B_2 \\cdots$ 是样本空间$\\Omega$的一个划分，A为任一事件，则：<br>$$<br>P(A) = \\sum^n_{i=1} P(B_i)P(A|B_i)<br>$$<br>上式即为全概率公式.</p>\n<p>全概率公式的意义在于，当直接计算$P(A)$较为困难,而$P(B_i),P(A|B_i) \\space\\space (i=1,2,\\cdots,n)$的计算较为简单时，可以利用全概率公式计算$P(A)$。思想就是，将事件A分解成几个小事件，通过求小事件的概率，然后相加从而求得事件A的概率，而将事件A进行分割的时候，不是直接对A进行分割，而是先找到样本空间$\\Omega$的一个个划分$B_1,B_2,\\cdots,B_n$,这样事件A就被事件$AB_1,AB_2,\\cdots,AB_n$分解成了n部分，即$A=AB_1+AB_2+…+AB_n$, 每一$B_i$发生都可能导致A发生相应的概率是P(A|Bi)，由加法公式得<br>$$<br>\\begin{aligned}<br>         P(A)&amp;=P(AB_1)+P(AB_2)+\\cdots+P(AB_n)\\\\<br>             &amp;=P(A|B_1)P(B_1)+P(A|B_2)P(B_2)+\\cdots+P(A|B_n)P(PB_n)<br>\\end{aligned}<br>$$</p>\n<p>实例：某车间用甲、乙、丙三台机床进行生产，各台机床次品率分别为5%，4%，2%，它们各自的产品分别占总量的25%，35%，40%，将它们的产品混在一起，求任取一个产品是次品的概率。</p>\n<p>设: 抽取一个产品是甲、乙、丙机床生产的事件分别为$A_1, A_2, A_3$，抽取到产品是次品的事件为$B$。根据全概率公式得:<br>$$<br>\\begin{aligned}<br>P(B) &amp;= P(A_1B) + P(A_2B) + P(A_3B)\\\\<br>     &amp;= P(B|A_1)P(A_1) + P(B|A_2)P(A_2) + P(B|A_3)P(A_3)\\\\<br>     &amp;= 0.05 * 0.25 + 0.04 * 0.35 + 0.02 * 0.40\\\\<br>     &amp;= 0.0345<br>\\end{aligned}<br>$$</p>\n<h2 id=\"2-4-贝叶斯公式\"><a href=\"#2-4-贝叶斯公式\" class=\"headerlink\" title=\"2.4 贝叶斯公式\"></a>2.4 贝叶斯公式</h2><p>与全概率公式解决的问题相反，贝叶斯公式是建立在条件概率的基础上寻找事件发生的原因（即大事件A已经发生的条件下，分割中的小事件$B_i$的概率），设$B_1,B_2,\\cdots$是样本空间$\\Omega$的一个划分，则对任一事件A（P(A)&gt;0),有<br>$$<br>\\begin{aligned}<br>P(B_i|A) &amp;= \\frac{P(AB_i)}{P(A)}                                            &amp;\\text{条件概率}\\\\<br>         &amp;= \\frac{P(A|B_i)P(B_i)}{P(A)}                                     &amp;\\text{乘法公式}\\\\<br>         &amp;= \\frac{P(A|B_i)P(B_i)}{ \\sum^n_{j=1} P(AB_j) }                   &amp;\\text{全概率公式}\\\\<br>         &amp;= \\frac{P(A|B_i)P(B_i)}{ \\sum^n_{j=1} P(A|B_j)P(B_j) }<br>\\end{aligned}<br>$$</p>\n<p>上式即为贝叶斯公式，$B_i$常被视为导致试验结果A发生的”原因“，$P(B_i)(i=1,2,\\cdots,n)$表示各种原因发生的可能性大小，故称<strong>先验概率</strong>；$P(B_i|A)(i=1,2,\\cdots,n)$则反映当试验产生了结果A之后，再对各种原因概率的新认识，故称<strong>后验概率</strong>。</p>\n<p>实例：发报台分别以概率0.6和0.4发出信号“∪”和“—”。由于通信系统受到干扰，当发出信号“∪”时，收报台分别以概率0.8和0.2收到信号“∪”和“—”；又当发出信号“—”时，收报台分别以概率0.9和0.1收到信号“—”和“∪”。求当收报台收到信号“∪”时，发报台确系发出“∪”的概率。</p>\n<p>设: 发报台发送信号”u”的事件为$A$，发送信号”-“的事件为$\\bar{A}$，收报台收到信号”u”的事件为$B$。根据贝叶斯公式得：<br>$$<br>\\begin{aligned}<br>P(A|B)  &amp;= \\frac{P(B|A)P(A)}{P(B|A)P(A) + P(B|\\bar{A})P(\\bar{A})}\\\\<br>        &amp;= \\frac{0.8 * 0.6}{0.8 * 0.6 + 0.1 * 0.4}\\\\<br>        &amp;\\approx 0.923<br>\\end{aligned}<br>$$</p>\n<h2 id=\"2-5-相互独立事件\"><a href=\"#2-5-相互独立事件\" class=\"headerlink\" title=\"2.5 相互独立事件\"></a>2.5 相互独立事件</h2><p>相互独立事件: 就是事件A（或B）是否发生对事件B（A）发生的概率没有影响，这样的两个事件叫做相互独立事件。所以有<br>$$<br>P(A) = P(A|B)\\\\<br>P(B) = P(B|A)<br>$$</p>\n<p>根据条件概率公式可以推导出<br>$$<br>P(AB) = P(A|B)P(B) = P(B|A)P(A) = P(A)P(B)<br>$$</p>\n<p><strong>相互独立事件</strong>的性质将会在下面”朴素贝叶斯“算法中用到。</p>\n<h1 id=\"三、朴素贝叶斯分类\"><a href=\"#三、朴素贝叶斯分类\" class=\"headerlink\" title=\"三、朴素贝叶斯分类\"></a>三、朴素贝叶斯分类</h1><p>朴素贝叶斯分类是一种十分简单的分类算法，叫它朴素贝叶斯分类是因为这种方法的思想真的很朴素，朴素贝叶斯的思想基础是这样的：对于给出的待分类项，求解在此项出现的条件下各个类别出现的概率，哪个最大，就认为此待分类项属于哪个类别。通俗来说，就好比这么个道理，你在街上看到一个黑人，我问你你猜这哥们哪里来的，你十有八九猜非洲。为什么呢？因为黑人中非洲人的比率最高，当然人家也可能是美洲人或亚洲人，但在没有其它可用信息下，我们会选择条件概率最大的类别，这就是朴素贝叶斯的思想基础。</p>\n<h2 id=\"训练\"><a href=\"#训练\" class=\"headerlink\" title=\"训练\"></a>训练</h2><p>先给出一些定义：</p>\n<ol>\n<li>待分类数据的特征集为${X_1, X_2, \\cdots, X_n}$，其中对于每个特征$X_i$有特征值$x_i^{(1)},x_i^{(2)},\\cdots,x_i^{(|X_i|)}$</li>\n<li>有实际类别集合为$Y={y_1, y_2, \\cdots, y_m}$。那么当$Y=y_j$时， $X_i=x_i^{(c_i)} (c_i=1,2,\\cdots,|X_i|)$ 的概率为$P(X_i=x_i^{(c_i)}|Y=y_j)$</li>\n<li>假设所有特征是<strong>条件独立</strong>的，即满足<br>$$<br>P \\bigg( X_1=x_1^{(c_1)} \\cap X_2=x_2^{(c_2)} \\cap  \\cdots \\cap  X_n=x_n^{(c_n)} | Y=y_j \\bigg) = \\prod^n_{i=1} P(X_i=x_i^{(c_i)}|Y=y_j)<br>$$<br>其中 $c_i=1,2,\\cdots,|X_i|$。</li>\n</ol>\n<p>训练过程其实十分简单：</p>\n<ol>\n<li>计算<strong>先验概率</strong>: $P(Y=y_j)(j=1,2,\\cdots,m)$，这个值就是类别为$y_i$的样本数除以整个训练集的样本数。</li>\n<li>因为我们假设所有特征是<strong>条件独立</strong>的，则只需这样计算<strong>后验概率</strong>: $P(X_i=x_i^{(c_i)}|Y=y_j)(i=1,2,\\cdots,n;j=1,2,\\cdots,m)$ 的值</li>\n</ol>\n<p><strong>注意</strong>：在训练集中，某个特征$X_i$取值为$x_i^{(c_i)}$的出现次数为0时，会导致$P(X_1=x_1^{(c_1)} \\cap X_2=x_2^{(c_2)} \\cap  \\cdots \\cap  X_n=x_n^{(c_n)} | Y=y_j)=0$。但实际中，可能只是训练集里面没有给出这样的数据，并不代表这样的事件就一定不发生，所以概率为0这个情况太绝对了，不符合实际要求。我们的解决方案是把那些出现次数为0的次数都设为1，让它的出现概率变得十分微小但也不至于是0.</p>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p><strong>贝叶斯分类器</strong>的测试阶段十分简单，将传入的测试数据$X’$利用预先训练好的<strong>贝叶斯分类器</strong>计算<br>$$<br>\\begin{aligned}<br>y’<em>j &amp;= argmax \\bigg( P(Y=y_j)P(X_1=x’_1 \\cap X_2=x’_2 \\cap  \\cdots \\cap  X_n=x’_n | Y=y_j) \\bigg) &amp;(j=1,2,\\cdots,m)\\\\<br>   &amp;= argmax \\bigg( P(Y=y_j) \\prod^n\\</em>{i=1} P(X_i=x’_i | Y=y_j) \\bigg)<br>\\end{aligned}<br>$$<br>得到的$y’_j$就是<strong>贝叶斯分类器</strong>的预测结果。</p>\n<h2 id=\"实例：检测SNS社区中不真实账号\"><a href=\"#实例：检测SNS社区中不真实账号\" class=\"headerlink\" title=\"实例：检测SNS社区中不真实账号\"></a>实例：检测SNS社区中不真实账号</h2><p>这个问题是这样的，对于SNS社区来说，不真实账号（使用虚假身份或用户的小号）是一个普遍存在的问题，作为SNS社区的运营商，希望可以检测出这些不真实账号，从而在一些运营分析报告中避免这些账号的干扰，亦可以加强对SNS社区的了解与监管。</p>\n<p>如果通过纯人工检测，需要耗费大量的人力，效率也十分低下，如能引入自动检测机制，必将大大提升工作效率。这个问题说白了，就是要将社区中所有账号在真实账号和不真实账号两个类别上进行分类，下面我们一步一步实现这个过程。</p>\n<p>首先设 C=0 表示<strong>真实账号</strong>，C=1 表示<strong>不真实账号</strong>。</p>\n<h3 id=\"1-确定特征属性及划分\"><a href=\"#1-确定特征属性及划分\" class=\"headerlink\" title=\"1. 确定特征属性及划分\"></a>1. 确定特征属性及划分</h3><p>这一步要找出可以帮助我们区分真实账号与不真实账号的特征属性，在实际应用中，特征属性的数量是很多的，划分也会比较细致，但这里为了简单起见，我们用少量的特征属性以及较粗的划分，并对数据做了修改。</p>\n<p>我们选择三个特征属性：</p>\n<ul>\n<li>$a_1$ - 日志数量/注册天数</li>\n<li>$a_2$ - 好友数量/注册天数</li>\n<li>$a_3$ - 是否使用真实头像。</li>\n</ul>\n<p>在SNS社区中这三项都是可以直接从数据库里得到或计算出来的。</p>\n<p>下面对数值型特征进行离散化：</p>\n<ul>\n<li>$a_1$ - {$a_1 \\le 0.05$, $0.05 &lt; a_1 &lt; 0.2$, $a_1 \\ge 0.2$}</li>\n<li>$a_2$ - {$a_2 \\le 0.1$, $0.1 &lt; a_2 &lt; 0.8$, $a_2 \\ge 0.8$}</li>\n<li>$a_3$ - {$a_3=0$ (不是), $a_3=1$ (是)}</li>\n</ul>\n<h3 id=\"2-获取训练样本\"><a href=\"#2-获取训练样本\" class=\"headerlink\" title=\"2. 获取训练样本\"></a>2. 获取训练样本</h3><p>这里使用运维人员曾经人工检测过的1万个账号作为训练样本。</p>\n<h3 id=\"3-计算先验概率\"><a href=\"#3-计算先验概率\" class=\"headerlink\" title=\"3. 计算先验概率\"></a>3. 计算先验概率</h3><p>用训练样本中真实账号和不真实账号数量分别除以一万，得到：<br>$$<br>P(C=0)=8900/10000=0.89\\\\<br>P(C=1)=1100/100000=0.11<br>$$</p>\n<h3 id=\"4-计算后验概率\"><a href=\"#4-计算后验概率\" class=\"headerlink\" title=\"4. 计算后验概率\"></a>4. 计算后验概率</h3><p>我们用表格表示每个类别条件下各个特征属性划分的频率。</p>\n<table>\n<thead>\n<tr>\n<th>$P(a_1$ &#124; $C)$</th>\n<th>$a_1 \\le 0.05$</th>\n<th>$0.05 &lt; a_1 &lt; 0.2$</th>\n<th>$a_1 \\ge 0.2$</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>C=0</td>\n<td>0.3</td>\n<td>0.5</td>\n<td>0.2</td>\n</tr>\n<tr>\n<td>C=1</td>\n<td>0.8</td>\n<td>0.1</td>\n<td>0.1</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>$P(a_2$ &#124; $C)$</th>\n<th>$a_2 \\le 0.1$</th>\n<th>$0.1 &lt; a_2 &lt; 0.8$</th>\n<th>$a_2 \\ge 0.8$</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>C=0</td>\n<td>0.1</td>\n<td>0.7</td>\n<td>0.2</td>\n</tr>\n<tr>\n<td>C=1</td>\n<td>0.7</td>\n<td>0.2</td>\n<td>0.1</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>$P(a_3$ &#124; $C)$</th>\n<th>$a_3=0$</th>\n<th>$a_3=1$</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>C=0</td>\n<td>0.2</td>\n<td>0.8</td>\n</tr>\n<tr>\n<td>C=1</td>\n<td>0.9</td>\n<td>0.1</td>\n</tr>\n</tbody></table>\n<h3 id=\"5-使用分类器进行鉴别\"><a href=\"#5-使用分类器进行鉴别\" class=\"headerlink\" title=\"5. 使用分类器进行鉴别\"></a>5. 使用分类器进行鉴别</h3><p>下面我们使用上面训练得到的分类器鉴别一个账号，这个账号的特征属性为：$X’$ = {$a_1=0.1$, $a_2=0.2$, $a_3=0$}<br>$$<br>\\begin{aligned}<br>P(C=0)P(X’|C=0) &amp;= P(C=0) \\cdot P(0.05 &lt; a_1 &lt; 0.2|C=0) \\cdot P(0.1 &lt; a_2 &lt; 0.8|C=0) \\cdot P(a_3=0|C=0)\\\\<br>                &amp;= 0.89 * 0.5 * 0.7 * 0.2\\\\<br>                &amp;= 0.0623\\\\<br>\\\\<br>P(C=1)P(X’|C=1) &amp;= P(C=1) \\cdot P(0.05 &lt; a_1 &lt; 0.2|C=1) \\cdot P(0.1 &lt; a_2 &lt; 0.8|C=1) \\cdot P(a_3=0|C=1)\\\\<br>                &amp;= 0.11 * 0.1 * 0.2 * 0.9\\\\<br>                &amp;= 0.00198<br>\\end{aligned}<br>$$<br>算得C=0的概率更大一些，所以预测分类结果为“该账号是<strong>真实账号</strong>”。</p>\n<h1 id=\"四、贝叶斯网络简介\"><a href=\"#四、贝叶斯网络简介\" class=\"headerlink\" title=\"四、贝叶斯网络简介\"></a>四、贝叶斯网络简介</h1><p>朴素贝叶斯分类有一个限制条件，就是特征属性必须有条件独立或基本独立（实际上在现实应用中几乎不可能做到完全独立）。当这个条件成立时，朴素贝叶斯分类法的准确率是最高的，但不幸的是，现实中各个特征属性间往往并不条件独立，而是具有较强的相关性，这样就限制了朴素贝叶斯分类的能力。我们接着上一篇文章的例子，讨论贝叶斯分类中更高级、应用范围更广的一种算法——贝叶斯网络（又称贝叶斯信念网络或信念网络）。</p>\n<p>上一篇文章我们使用朴素贝叶斯分类实现了SNS社区中不真实账号的检测。在那个解决方案中，我做了如下假设：</p>\n<ol>\n<li>真实账号比非真实账号平均具有更大的日志密度、各大的好友密度以及更多的使用真实头像。</li>\n<li>日志密度、好友密度和是否使用真实头像在账号真实性给定的条件下是独立的。</li>\n</ol>\n<p>但是，上述第二条假设很可能并不成立。一般来说，好友密度除了与账号是否真实有关，还与是否有真实头像有关，因为真实的头像会吸引更多人加其为好友。因此，我们为了获取更准确的分类，可以将假设修改如下：</p>\n<ol>\n<li>真实账号比非真实账号平均具有更大的日志密度、各大的好友密度以及更多的使用真实头像。</li>\n<li>日志密度与好友密度、日志密度与是否使用真实头像在账号真实性给定的条件下是独立的。</li>\n<li>使用真实头像的用户比使用非真实头像的用户平均有更大的好友密度。</li>\n</ol>\n<p>上述假设更接近实际情况，但问题随之也来了，由于特征属性间存在依赖关系，使得朴素贝叶斯分类不适用了。既然这样，我去寻找另外的解决方案。下图表示特征属性之间的关联：</p>\n<p><img src=\"http://images.cnblogs.com/cnblogs_com/leoo2sk/WindowsLiveWriter/bc64e495f586_139A8/1_3.png\" alt=\"特征属性之间的关联\"></p>\n<p>上图是一个有向无环图，每个节点代表一个随机变量，而有向边表示两个随机变量之间的联系，表示始节点影响终结点。不过仅有这个图的话，只能定性给出随机变量间的关系，如果要定量，还需要一些数据，这些数据就是每个节点对其直接前驱节点的条件概率，而没有前驱节点的节点则使用先验概率表示。</p>\n<p>继续利用上述例子中的数据，我们在训练过程中已经算好了这些概率：</p>\n<table>\n<thead>\n<tr>\n<th>P(C=0)</th>\n<th>P(C=1)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0.89</td>\n<td>0.11</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>$P(a_3$ &#124; $C)$</th>\n<th>$a_3=0$</th>\n<th>$a_3=1$</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>C=0</td>\n<td>0.2</td>\n<td>0.8</td>\n</tr>\n<tr>\n<td>C=1</td>\n<td>0.9</td>\n<td>0.1</td>\n</tr>\n</tbody></table>\n<p>上述得知 $P(a_3 | C)$ 以及 $P(C)$ 我们就可以通过贝叶斯公式求得反向概率，如：<br>$$<br>\\begin{aligned}<br>P(C=1|a_3=0) &amp;= \\frac{P(a_3=0|C=1)P(C=1)}{P(a_3=0)}<br>             &amp;= \\frac{P(a_3=0|C=1)P(C=1)}{P(a_3=0|C=1)P(C=1) + P(a_3=0|C=0)P(C=0)}<br>             &amp;= \\frac{0.9 * 0.11}{0.9 * 0.11 + 0.2 * 0.89}<br>             &amp;= 0.3574<br>\\end{aligned}<br>$$</p>\n<p> 也就是说，在仅知道头像为假的情况下，有大约35.7%的概率此账户也为假。</p>\n<h2 id=\"贝叶斯网络的定义及性质\"><a href=\"#贝叶斯网络的定义及性质\" class=\"headerlink\" title=\"贝叶斯网络的定义及性质\"></a>贝叶斯网络的定义及性质</h2><p>一个贝叶斯网络定义包括一个有向无环图（DAG）和一个条件概率表集合。DAG中每一个节点表示一个随机变量，可以是可直接观测变量或隐藏变量，而有向边表示随机变量间的条件依赖；条件概率表中的每一个元素对应DAG中唯一的节点，存储此节点对于其所有直接前驱节点的联合条件概率。</p>\n<p>贝叶斯网络有一条极为重要的性质，就是我们断言每一个节点在其直接前驱节点的值制定后，这个节点条件独立于其所有非直接前驱前辈节点。</p>\n<p>一般情况下，多变量非独立联合条件概率分布有如下求取公式：<br>$$<br>P(x_1,x_2,\\cdots,x_n)=P(x_1)P(x_2|x_1)P(x_3|x_1x_2) \\cdots P(x_n|x_1x_2 \\cdots x_{n-1})<br>$$</p>\n<p>而在贝叶斯网络中，由于存在前述性质，任意随机变量组合的联合条件概率分布被化简成:<br>$$<br>P(x_1x_2 \\cdots x_n)=\\prod^n_{i=1} P(x_i|Parent(x_i))<br>$$</p>\n<p>其中Parent表示$x_i$的直接前驱节点的联合，概率值可以从相应条件概率表中查到。</p>\n<p>贝叶斯网络比朴素贝叶斯更复杂，而想构造和训练出一个好的贝叶斯网络更是异常艰难。但是贝叶斯网络是模拟人的认知思维推理模式，用一组条件概率函数以及有向无环图对不确定性的因果推理关系建模，因此其具有更高的实用价值。</p>\n<h2 id=\"贝叶斯网络的构造及学习\"><a href=\"#贝叶斯网络的构造及学习\" class=\"headerlink\" title=\"贝叶斯网络的构造及学习\"></a>贝叶斯网络的构造及学习</h2><p>构造与训练贝叶斯网络分为以下两步：</p>\n<ol>\n<li>确定随机变量间的拓扑关系，形成DAG。这一步通常需要领域专家完成，而想要建立一个好的拓扑结构，通常需要不断迭代和改进才可以。</li>\n<li>训练贝叶斯网络。这一步也就是要完成条件概率表的构造，如果每个随机变量的值都是可以直接观察的，像我们上面的例子，那么这一步的训练是直观的，方法类似于朴素贝叶斯分类。但是通常贝叶斯网络的中存在隐藏变量节点，那么训练方法就是比较复杂，例如使用梯度下降法。由于这些内容过于晦涩以及牵扯到较深入的数学知识，在此不再赘述，有兴趣的朋友可以查阅相关文献。</li>\n</ol>\n<p>这里给出国内一本贝叶斯网络的书：<a href=\"https://pan.baidu.com/s/1nuZXuzv\" target=\"_blank\" rel=\"noopener\">《动态贝叶斯网络推理学习理论及应用》</a></p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p>全概率公式、贝叶斯公式推导过程: <a href=\"http://www.cnblogs.com/ohshit/p/5629581.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/ohshit/p/5629581.html</a><br>朴素贝叶斯、贝叶斯网络及相关实例：<a href=\"http://www.cnblogs.com/hexinuaa/articles/2143483.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/hexinuaa/articles/2143483.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<script type=\"text/javascript\" async src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML\"> </script>\n\n<h1 id=\"一、分类问题概述\"><a href=\"#一、分类问题概述\" class=\"headerlink\" title=\"一、分类问题概述\"></a>一、分类问题概述</h1><p>对于分类问题，其实谁都不会陌生，说我们每个人每天都在执行分类操作一点都不夸张，只是我们没有意识到罢了。例如，当你看到一个陌生人，你的脑子下意识判断TA是男是女；你可能经常会走在路上对身旁的朋友说“这个人一看就很有钱、那边有个非主流”之类的话，其实这就是一种分类操作。</p>\n<p>从数学角度来说，分类问题可做如下定义：</p>\n<p>已知集合：$C={y_1,y_2,\\cdots,y_n}$ 和 $I={x_1,x_2,\\cdots,x_n}$，确定映射规则$y=f(x)$，使得任意$x_i \\in I$有且仅有$y_j \\in C$一个使得$y_j=f(x_i)$成立。（不考虑模糊数学里的模糊集情况）</p>\n<p>其中C叫做类别集合，其中每一个元素是一个类别，而I叫做项集合，其中每一个元素是一个待分类项，f叫做分类器。分类算法的任务就是构造分类器f。</p>\n<p>这里要着重强调，分类问题往往采用经验性方法构造映射规则，即一般情况下的分类问题缺少足够的信息来构造100%正确的映射规则，而是通过对经验数据的学习从而实现一定概率意义上正确的分类，因此所训练出的分类器并不是一定能将每个待分类项准确映射到其分类，分类器的质量与分类器构造方法、待分类数据的特性以及训练样本数量等诸多因素有关。</p>\n<p>例如，医生对病人进行诊断就是一个典型的分类过程，任何一个医生都无法直接看到病人的病情，只能观察病人表现出的症状和各种化验检测数据来推断病情，这时医生就好比一个分类器，而这个医生诊断的准确率，与他当初受到的教育方式（构造方法）、病人的症状是否突出（待分类数据的特性）以及医生的经验多少（训练样本数量）都有密切关系。</p>\n<h1 id=\"二、-预备知识\"><a href=\"#二、-预备知识\" class=\"headerlink\" title=\"二、 预备知识\"></a>二、 预备知识</h1><h2 id=\"2-1-条件概率公式\"><a href=\"#2-1-条件概率公式\" class=\"headerlink\" title=\"2.1 条件概率公式\"></a>2.1 条件概率公式</h2><p>设A,B两个事件，P(B)&gt;0，则在事件B发生条件下，事件A发生的条件概率为：<br>$$<br>P(A|B)=\\frac{P(AB)}{P(B)}<br>$$</p>\n<p>实例：盒子里面有黑色和白色两种颜色的模具，它们的比例是6:4(黑:白)。黑色模具全都是立方体，白色模具有一半是立方体一半是球体(5:5)。</p>\n<p>假设摸到白球的事件为A，摸到黑球的事件为$\\bar{A}$，摸到立方体模具的事件为B，摸到球体模具的事件为$\\bar{B}$。</p>\n<p>假设我伸手到盒子里摸到了一个立方体模具(事件B)，那么这个模具是白色(事件A)的概率就是$P(A|B)$。<br>反过来，我们假设我已经知道摸到的模具是白色(事件A)，那么这个模具是球体(事件$\\bar{B}$)的概率就是$P(\\bar{B}|A)$</p>\n<h2 id=\"2-2-乘法公式\"><a href=\"#2-2-乘法公式\" class=\"headerlink\" title=\"2.2 乘法公式\"></a>2.2 乘法公式</h2><p>由条件概率公式得乘法公式：<br>$$<br>P(AB) = P(A|B)P(B) = P(B|A)P(A)<br>$$</p>\n<p>推广：对于任何正数$n \\ge 2$，当$P(A_1 A_2 \\cdots A_{n-1}) &gt; 0$时，有<br>$$<br>P(A_1 A_2 \\cdots A_{n-1} A_n) = P(A_n | A_1 A_2 \\cdots A_{n-1}) P(A_1 A_2 \\cdots A_{n-1})<br>$$</p>\n<h2 id=\"2-3-全概率公式\"><a href=\"#2-3-全概率公式\" class=\"headerlink\" title=\"2.3 全概率公式\"></a>2.3 全概率公式</h2><p>如果事件组 $B_1,B_2,\\cdots, B_n$ 满足</p>\n<ol>\n<li>$B_i \\cap B_j = \\emptyset$, $i \\ne j$ 且 $P(B_i)&gt;0$ 且 $i,j=1,2,\\cdots,n$</li>\n<li>$B_1 \\cup B_2 \\cup \\cdots \\cup B_n = \\Omega$，则称事件组 $B_1,B_2, \\cdots ,B_n$ 是样本空间$\\Omega$的一个划分</li>\n</ol>\n<p>设 $B_1 B_2 \\cdots$ 是样本空间$\\Omega$的一个划分，A为任一事件，则：<br>$$<br>P(A) = \\sum^n_{i=1} P(B_i)P(A|B_i)<br>$$<br>上式即为全概率公式.</p>\n<p>全概率公式的意义在于，当直接计算$P(A)$较为困难,而$P(B_i),P(A|B_i) \\space\\space (i=1,2,\\cdots,n)$的计算较为简单时，可以利用全概率公式计算$P(A)$。思想就是，将事件A分解成几个小事件，通过求小事件的概率，然后相加从而求得事件A的概率，而将事件A进行分割的时候，不是直接对A进行分割，而是先找到样本空间$\\Omega$的一个个划分$B_1,B_2,\\cdots,B_n$,这样事件A就被事件$AB_1,AB_2,\\cdots,AB_n$分解成了n部分，即$A=AB_1+AB_2+…+AB_n$, 每一$B_i$发生都可能导致A发生相应的概率是P(A|Bi)，由加法公式得<br>$$<br>\\begin{aligned}<br>         P(A)&amp;=P(AB_1)+P(AB_2)+\\cdots+P(AB_n)\\\\<br>             &amp;=P(A|B_1)P(B_1)+P(A|B_2)P(B_2)+\\cdots+P(A|B_n)P(PB_n)<br>\\end{aligned}<br>$$</p>\n<p>实例：某车间用甲、乙、丙三台机床进行生产，各台机床次品率分别为5%，4%，2%，它们各自的产品分别占总量的25%，35%，40%，将它们的产品混在一起，求任取一个产品是次品的概率。</p>\n<p>设: 抽取一个产品是甲、乙、丙机床生产的事件分别为$A_1, A_2, A_3$，抽取到产品是次品的事件为$B$。根据全概率公式得:<br>$$<br>\\begin{aligned}<br>P(B) &amp;= P(A_1B) + P(A_2B) + P(A_3B)\\\\<br>     &amp;= P(B|A_1)P(A_1) + P(B|A_2)P(A_2) + P(B|A_3)P(A_3)\\\\<br>     &amp;= 0.05 * 0.25 + 0.04 * 0.35 + 0.02 * 0.40\\\\<br>     &amp;= 0.0345<br>\\end{aligned}<br>$$</p>\n<h2 id=\"2-4-贝叶斯公式\"><a href=\"#2-4-贝叶斯公式\" class=\"headerlink\" title=\"2.4 贝叶斯公式\"></a>2.4 贝叶斯公式</h2><p>与全概率公式解决的问题相反，贝叶斯公式是建立在条件概率的基础上寻找事件发生的原因（即大事件A已经发生的条件下，分割中的小事件$B_i$的概率），设$B_1,B_2,\\cdots$是样本空间$\\Omega$的一个划分，则对任一事件A（P(A)&gt;0),有<br>$$<br>\\begin{aligned}<br>P(B_i|A) &amp;= \\frac{P(AB_i)}{P(A)}                                            &amp;\\text{条件概率}\\\\<br>         &amp;= \\frac{P(A|B_i)P(B_i)}{P(A)}                                     &amp;\\text{乘法公式}\\\\<br>         &amp;= \\frac{P(A|B_i)P(B_i)}{ \\sum^n_{j=1} P(AB_j) }                   &amp;\\text{全概率公式}\\\\<br>         &amp;= \\frac{P(A|B_i)P(B_i)}{ \\sum^n_{j=1} P(A|B_j)P(B_j) }<br>\\end{aligned}<br>$$</p>\n<p>上式即为贝叶斯公式，$B_i$常被视为导致试验结果A发生的”原因“，$P(B_i)(i=1,2,\\cdots,n)$表示各种原因发生的可能性大小，故称<strong>先验概率</strong>；$P(B_i|A)(i=1,2,\\cdots,n)$则反映当试验产生了结果A之后，再对各种原因概率的新认识，故称<strong>后验概率</strong>。</p>\n<p>实例：发报台分别以概率0.6和0.4发出信号“∪”和“—”。由于通信系统受到干扰，当发出信号“∪”时，收报台分别以概率0.8和0.2收到信号“∪”和“—”；又当发出信号“—”时，收报台分别以概率0.9和0.1收到信号“—”和“∪”。求当收报台收到信号“∪”时，发报台确系发出“∪”的概率。</p>\n<p>设: 发报台发送信号”u”的事件为$A$，发送信号”-“的事件为$\\bar{A}$，收报台收到信号”u”的事件为$B$。根据贝叶斯公式得：<br>$$<br>\\begin{aligned}<br>P(A|B)  &amp;= \\frac{P(B|A)P(A)}{P(B|A)P(A) + P(B|\\bar{A})P(\\bar{A})}\\\\<br>        &amp;= \\frac{0.8 * 0.6}{0.8 * 0.6 + 0.1 * 0.4}\\\\<br>        &amp;\\approx 0.923<br>\\end{aligned}<br>$$</p>\n<h2 id=\"2-5-相互独立事件\"><a href=\"#2-5-相互独立事件\" class=\"headerlink\" title=\"2.5 相互独立事件\"></a>2.5 相互独立事件</h2><p>相互独立事件: 就是事件A（或B）是否发生对事件B（A）发生的概率没有影响，这样的两个事件叫做相互独立事件。所以有<br>$$<br>P(A) = P(A|B)\\\\<br>P(B) = P(B|A)<br>$$</p>\n<p>根据条件概率公式可以推导出<br>$$<br>P(AB) = P(A|B)P(B) = P(B|A)P(A) = P(A)P(B)<br>$$</p>\n<p><strong>相互独立事件</strong>的性质将会在下面”朴素贝叶斯“算法中用到。</p>\n<h1 id=\"三、朴素贝叶斯分类\"><a href=\"#三、朴素贝叶斯分类\" class=\"headerlink\" title=\"三、朴素贝叶斯分类\"></a>三、朴素贝叶斯分类</h1><p>朴素贝叶斯分类是一种十分简单的分类算法，叫它朴素贝叶斯分类是因为这种方法的思想真的很朴素，朴素贝叶斯的思想基础是这样的：对于给出的待分类项，求解在此项出现的条件下各个类别出现的概率，哪个最大，就认为此待分类项属于哪个类别。通俗来说，就好比这么个道理，你在街上看到一个黑人，我问你你猜这哥们哪里来的，你十有八九猜非洲。为什么呢？因为黑人中非洲人的比率最高，当然人家也可能是美洲人或亚洲人，但在没有其它可用信息下，我们会选择条件概率最大的类别，这就是朴素贝叶斯的思想基础。</p>\n<h2 id=\"训练\"><a href=\"#训练\" class=\"headerlink\" title=\"训练\"></a>训练</h2><p>先给出一些定义：</p>\n<ol>\n<li>待分类数据的特征集为${X_1, X_2, \\cdots, X_n}$，其中对于每个特征$X_i$有特征值$x_i^{(1)},x_i^{(2)},\\cdots,x_i^{(|X_i|)}$</li>\n<li>有实际类别集合为$Y={y_1, y_2, \\cdots, y_m}$。那么当$Y=y_j$时， $X_i=x_i^{(c_i)} (c_i=1,2,\\cdots,|X_i|)$ 的概率为$P(X_i=x_i^{(c_i)}|Y=y_j)$</li>\n<li>假设所有特征是<strong>条件独立</strong>的，即满足<br>$$<br>P \\bigg( X_1=x_1^{(c_1)} \\cap X_2=x_2^{(c_2)} \\cap  \\cdots \\cap  X_n=x_n^{(c_n)} | Y=y_j \\bigg) = \\prod^n_{i=1} P(X_i=x_i^{(c_i)}|Y=y_j)<br>$$<br>其中 $c_i=1,2,\\cdots,|X_i|$。</li>\n</ol>\n<p>训练过程其实十分简单：</p>\n<ol>\n<li>计算<strong>先验概率</strong>: $P(Y=y_j)(j=1,2,\\cdots,m)$，这个值就是类别为$y_i$的样本数除以整个训练集的样本数。</li>\n<li>因为我们假设所有特征是<strong>条件独立</strong>的，则只需这样计算<strong>后验概率</strong>: $P(X_i=x_i^{(c_i)}|Y=y_j)(i=1,2,\\cdots,n;j=1,2,\\cdots,m)$ 的值</li>\n</ol>\n<p><strong>注意</strong>：在训练集中，某个特征$X_i$取值为$x_i^{(c_i)}$的出现次数为0时，会导致$P(X_1=x_1^{(c_1)} \\cap X_2=x_2^{(c_2)} \\cap  \\cdots \\cap  X_n=x_n^{(c_n)} | Y=y_j)=0$。但实际中，可能只是训练集里面没有给出这样的数据，并不代表这样的事件就一定不发生，所以概率为0这个情况太绝对了，不符合实际要求。我们的解决方案是把那些出现次数为0的次数都设为1，让它的出现概率变得十分微小但也不至于是0.</p>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p><strong>贝叶斯分类器</strong>的测试阶段十分简单，将传入的测试数据$X’$利用预先训练好的<strong>贝叶斯分类器</strong>计算<br>$$<br>\\begin{aligned}<br>y’<em>j &amp;= argmax \\bigg( P(Y=y_j)P(X_1=x’_1 \\cap X_2=x’_2 \\cap  \\cdots \\cap  X_n=x’_n | Y=y_j) \\bigg) &amp;(j=1,2,\\cdots,m)\\\\<br>   &amp;= argmax \\bigg( P(Y=y_j) \\prod^n\\</em>{i=1} P(X_i=x’_i | Y=y_j) \\bigg)<br>\\end{aligned}<br>$$<br>得到的$y’_j$就是<strong>贝叶斯分类器</strong>的预测结果。</p>\n<h2 id=\"实例：检测SNS社区中不真实账号\"><a href=\"#实例：检测SNS社区中不真实账号\" class=\"headerlink\" title=\"实例：检测SNS社区中不真实账号\"></a>实例：检测SNS社区中不真实账号</h2><p>这个问题是这样的，对于SNS社区来说，不真实账号（使用虚假身份或用户的小号）是一个普遍存在的问题，作为SNS社区的运营商，希望可以检测出这些不真实账号，从而在一些运营分析报告中避免这些账号的干扰，亦可以加强对SNS社区的了解与监管。</p>\n<p>如果通过纯人工检测，需要耗费大量的人力，效率也十分低下，如能引入自动检测机制，必将大大提升工作效率。这个问题说白了，就是要将社区中所有账号在真实账号和不真实账号两个类别上进行分类，下面我们一步一步实现这个过程。</p>\n<p>首先设 C=0 表示<strong>真实账号</strong>，C=1 表示<strong>不真实账号</strong>。</p>\n<h3 id=\"1-确定特征属性及划分\"><a href=\"#1-确定特征属性及划分\" class=\"headerlink\" title=\"1. 确定特征属性及划分\"></a>1. 确定特征属性及划分</h3><p>这一步要找出可以帮助我们区分真实账号与不真实账号的特征属性，在实际应用中，特征属性的数量是很多的，划分也会比较细致，但这里为了简单起见，我们用少量的特征属性以及较粗的划分，并对数据做了修改。</p>\n<p>我们选择三个特征属性：</p>\n<ul>\n<li>$a_1$ - 日志数量/注册天数</li>\n<li>$a_2$ - 好友数量/注册天数</li>\n<li>$a_3$ - 是否使用真实头像。</li>\n</ul>\n<p>在SNS社区中这三项都是可以直接从数据库里得到或计算出来的。</p>\n<p>下面对数值型特征进行离散化：</p>\n<ul>\n<li>$a_1$ - {$a_1 \\le 0.05$, $0.05 &lt; a_1 &lt; 0.2$, $a_1 \\ge 0.2$}</li>\n<li>$a_2$ - {$a_2 \\le 0.1$, $0.1 &lt; a_2 &lt; 0.8$, $a_2 \\ge 0.8$}</li>\n<li>$a_3$ - {$a_3=0$ (不是), $a_3=1$ (是)}</li>\n</ul>\n<h3 id=\"2-获取训练样本\"><a href=\"#2-获取训练样本\" class=\"headerlink\" title=\"2. 获取训练样本\"></a>2. 获取训练样本</h3><p>这里使用运维人员曾经人工检测过的1万个账号作为训练样本。</p>\n<h3 id=\"3-计算先验概率\"><a href=\"#3-计算先验概率\" class=\"headerlink\" title=\"3. 计算先验概率\"></a>3. 计算先验概率</h3><p>用训练样本中真实账号和不真实账号数量分别除以一万，得到：<br>$$<br>P(C=0)=8900/10000=0.89\\\\<br>P(C=1)=1100/100000=0.11<br>$$</p>\n<h3 id=\"4-计算后验概率\"><a href=\"#4-计算后验概率\" class=\"headerlink\" title=\"4. 计算后验概率\"></a>4. 计算后验概率</h3><p>我们用表格表示每个类别条件下各个特征属性划分的频率。</p>\n<table>\n<thead>\n<tr>\n<th>$P(a_1$ &#124; $C)$</th>\n<th>$a_1 \\le 0.05$</th>\n<th>$0.05 &lt; a_1 &lt; 0.2$</th>\n<th>$a_1 \\ge 0.2$</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>C=0</td>\n<td>0.3</td>\n<td>0.5</td>\n<td>0.2</td>\n</tr>\n<tr>\n<td>C=1</td>\n<td>0.8</td>\n<td>0.1</td>\n<td>0.1</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>$P(a_2$ &#124; $C)$</th>\n<th>$a_2 \\le 0.1$</th>\n<th>$0.1 &lt; a_2 &lt; 0.8$</th>\n<th>$a_2 \\ge 0.8$</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>C=0</td>\n<td>0.1</td>\n<td>0.7</td>\n<td>0.2</td>\n</tr>\n<tr>\n<td>C=1</td>\n<td>0.7</td>\n<td>0.2</td>\n<td>0.1</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>$P(a_3$ &#124; $C)$</th>\n<th>$a_3=0$</th>\n<th>$a_3=1$</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>C=0</td>\n<td>0.2</td>\n<td>0.8</td>\n</tr>\n<tr>\n<td>C=1</td>\n<td>0.9</td>\n<td>0.1</td>\n</tr>\n</tbody></table>\n<h3 id=\"5-使用分类器进行鉴别\"><a href=\"#5-使用分类器进行鉴别\" class=\"headerlink\" title=\"5. 使用分类器进行鉴别\"></a>5. 使用分类器进行鉴别</h3><p>下面我们使用上面训练得到的分类器鉴别一个账号，这个账号的特征属性为：$X’$ = {$a_1=0.1$, $a_2=0.2$, $a_3=0$}<br>$$<br>\\begin{aligned}<br>P(C=0)P(X’|C=0) &amp;= P(C=0) \\cdot P(0.05 &lt; a_1 &lt; 0.2|C=0) \\cdot P(0.1 &lt; a_2 &lt; 0.8|C=0) \\cdot P(a_3=0|C=0)\\\\<br>                &amp;= 0.89 * 0.5 * 0.7 * 0.2\\\\<br>                &amp;= 0.0623\\\\<br>\\\\<br>P(C=1)P(X’|C=1) &amp;= P(C=1) \\cdot P(0.05 &lt; a_1 &lt; 0.2|C=1) \\cdot P(0.1 &lt; a_2 &lt; 0.8|C=1) \\cdot P(a_3=0|C=1)\\\\<br>                &amp;= 0.11 * 0.1 * 0.2 * 0.9\\\\<br>                &amp;= 0.00198<br>\\end{aligned}<br>$$<br>算得C=0的概率更大一些，所以预测分类结果为“该账号是<strong>真实账号</strong>”。</p>\n<h1 id=\"四、贝叶斯网络简介\"><a href=\"#四、贝叶斯网络简介\" class=\"headerlink\" title=\"四、贝叶斯网络简介\"></a>四、贝叶斯网络简介</h1><p>朴素贝叶斯分类有一个限制条件，就是特征属性必须有条件独立或基本独立（实际上在现实应用中几乎不可能做到完全独立）。当这个条件成立时，朴素贝叶斯分类法的准确率是最高的，但不幸的是，现实中各个特征属性间往往并不条件独立，而是具有较强的相关性，这样就限制了朴素贝叶斯分类的能力。我们接着上一篇文章的例子，讨论贝叶斯分类中更高级、应用范围更广的一种算法——贝叶斯网络（又称贝叶斯信念网络或信念网络）。</p>\n<p>上一篇文章我们使用朴素贝叶斯分类实现了SNS社区中不真实账号的检测。在那个解决方案中，我做了如下假设：</p>\n<ol>\n<li>真实账号比非真实账号平均具有更大的日志密度、各大的好友密度以及更多的使用真实头像。</li>\n<li>日志密度、好友密度和是否使用真实头像在账号真实性给定的条件下是独立的。</li>\n</ol>\n<p>但是，上述第二条假设很可能并不成立。一般来说，好友密度除了与账号是否真实有关，还与是否有真实头像有关，因为真实的头像会吸引更多人加其为好友。因此，我们为了获取更准确的分类，可以将假设修改如下：</p>\n<ol>\n<li>真实账号比非真实账号平均具有更大的日志密度、各大的好友密度以及更多的使用真实头像。</li>\n<li>日志密度与好友密度、日志密度与是否使用真实头像在账号真实性给定的条件下是独立的。</li>\n<li>使用真实头像的用户比使用非真实头像的用户平均有更大的好友密度。</li>\n</ol>\n<p>上述假设更接近实际情况，但问题随之也来了，由于特征属性间存在依赖关系，使得朴素贝叶斯分类不适用了。既然这样，我去寻找另外的解决方案。下图表示特征属性之间的关联：</p>\n<p><img src=\"http://images.cnblogs.com/cnblogs_com/leoo2sk/WindowsLiveWriter/bc64e495f586_139A8/1_3.png\" alt=\"特征属性之间的关联\"></p>\n<p>上图是一个有向无环图，每个节点代表一个随机变量，而有向边表示两个随机变量之间的联系，表示始节点影响终结点。不过仅有这个图的话，只能定性给出随机变量间的关系，如果要定量，还需要一些数据，这些数据就是每个节点对其直接前驱节点的条件概率，而没有前驱节点的节点则使用先验概率表示。</p>\n<p>继续利用上述例子中的数据，我们在训练过程中已经算好了这些概率：</p>\n<table>\n<thead>\n<tr>\n<th>P(C=0)</th>\n<th>P(C=1)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0.89</td>\n<td>0.11</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>$P(a_3$ &#124; $C)$</th>\n<th>$a_3=0$</th>\n<th>$a_3=1$</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>C=0</td>\n<td>0.2</td>\n<td>0.8</td>\n</tr>\n<tr>\n<td>C=1</td>\n<td>0.9</td>\n<td>0.1</td>\n</tr>\n</tbody></table>\n<p>上述得知 $P(a_3 | C)$ 以及 $P(C)$ 我们就可以通过贝叶斯公式求得反向概率，如：<br>$$<br>\\begin{aligned}<br>P(C=1|a_3=0) &amp;= \\frac{P(a_3=0|C=1)P(C=1)}{P(a_3=0)}<br>             &amp;= \\frac{P(a_3=0|C=1)P(C=1)}{P(a_3=0|C=1)P(C=1) + P(a_3=0|C=0)P(C=0)}<br>             &amp;= \\frac{0.9 * 0.11}{0.9 * 0.11 + 0.2 * 0.89}<br>             &amp;= 0.3574<br>\\end{aligned}<br>$$</p>\n<p> 也就是说，在仅知道头像为假的情况下，有大约35.7%的概率此账户也为假。</p>\n<h2 id=\"贝叶斯网络的定义及性质\"><a href=\"#贝叶斯网络的定义及性质\" class=\"headerlink\" title=\"贝叶斯网络的定义及性质\"></a>贝叶斯网络的定义及性质</h2><p>一个贝叶斯网络定义包括一个有向无环图（DAG）和一个条件概率表集合。DAG中每一个节点表示一个随机变量，可以是可直接观测变量或隐藏变量，而有向边表示随机变量间的条件依赖；条件概率表中的每一个元素对应DAG中唯一的节点，存储此节点对于其所有直接前驱节点的联合条件概率。</p>\n<p>贝叶斯网络有一条极为重要的性质，就是我们断言每一个节点在其直接前驱节点的值制定后，这个节点条件独立于其所有非直接前驱前辈节点。</p>\n<p>一般情况下，多变量非独立联合条件概率分布有如下求取公式：<br>$$<br>P(x_1,x_2,\\cdots,x_n)=P(x_1)P(x_2|x_1)P(x_3|x_1x_2) \\cdots P(x_n|x_1x_2 \\cdots x_{n-1})<br>$$</p>\n<p>而在贝叶斯网络中，由于存在前述性质，任意随机变量组合的联合条件概率分布被化简成:<br>$$<br>P(x_1x_2 \\cdots x_n)=\\prod^n_{i=1} P(x_i|Parent(x_i))<br>$$</p>\n<p>其中Parent表示$x_i$的直接前驱节点的联合，概率值可以从相应条件概率表中查到。</p>\n<p>贝叶斯网络比朴素贝叶斯更复杂，而想构造和训练出一个好的贝叶斯网络更是异常艰难。但是贝叶斯网络是模拟人的认知思维推理模式，用一组条件概率函数以及有向无环图对不确定性的因果推理关系建模，因此其具有更高的实用价值。</p>\n<h2 id=\"贝叶斯网络的构造及学习\"><a href=\"#贝叶斯网络的构造及学习\" class=\"headerlink\" title=\"贝叶斯网络的构造及学习\"></a>贝叶斯网络的构造及学习</h2><p>构造与训练贝叶斯网络分为以下两步：</p>\n<ol>\n<li>确定随机变量间的拓扑关系，形成DAG。这一步通常需要领域专家完成，而想要建立一个好的拓扑结构，通常需要不断迭代和改进才可以。</li>\n<li>训练贝叶斯网络。这一步也就是要完成条件概率表的构造，如果每个随机变量的值都是可以直接观察的，像我们上面的例子，那么这一步的训练是直观的，方法类似于朴素贝叶斯分类。但是通常贝叶斯网络的中存在隐藏变量节点，那么训练方法就是比较复杂，例如使用梯度下降法。由于这些内容过于晦涩以及牵扯到较深入的数学知识，在此不再赘述，有兴趣的朋友可以查阅相关文献。</li>\n</ol>\n<p>这里给出国内一本贝叶斯网络的书：<a href=\"https://pan.baidu.com/s/1nuZXuzv\" target=\"_blank\" rel=\"noopener\">《动态贝叶斯网络推理学习理论及应用》</a></p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p>全概率公式、贝叶斯公式推导过程: <a href=\"http://www.cnblogs.com/ohshit/p/5629581.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/ohshit/p/5629581.html</a><br>朴素贝叶斯、贝叶斯网络及相关实例：<a href=\"http://www.cnblogs.com/hexinuaa/articles/2143483.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/hexinuaa/articles/2143483.html</a></p>\n"},{"title":"Ceph集群部署","_content":"\n本文主要介绍Ceph存储集群的部署方式，以及三种存储类型服务的构建及简单使用，不对内部原理做深入介绍，过后会编写另外的文章聊这个话题。本文属于个人学习笔记，如有错误欢迎指正，部署期间踩到的坑写在了Q&A。\n\n<!-- more -->\n\n# 组件介绍\n一个Ceph存储群集至少需要一个监控器(ceph-mon)，管理器(ceph-mgr)和对象存储守护程序(ceph-osd)。运行Ceph文件系统客户端时，还需要元数据服务器(ceph-mds)。\n* 管理器(ceph-mon): 维护集群状态的映射，包括监视器映射，管理器映射，OSD映射，MDS映射和CRUSH映射。这些映射是Ceph守护程序相互协调所需的关键群集状态。监视器还负责管理守护程序和客户端之间的身份验证。通常至少需要三个监视器才能实现冗余和高可用性。\n* 管理器(ceph-mgr): 负责跟踪运行时指标和Ceph集群的当前状态，包括存储利用率，当前性能指标和系统负载。Ceph Manager守护程序基于python模块进行管理并且负责公开Ceph集群信息（包括基于Web的Ceph Dashboard和 REST API）。通常，至少需要两个管理器才能实现高可用性。\n* 对象存储守护程序(ceph-osd): 处理数据复制，恢复，重新平衡，并通过检查其他Ceph OSD守护程序的心跳来向Ceph监视器和管理器提供一些监视信息。通常至少需要3个Ceph OSD才能实现冗余和高可用性。\n* 元数据服务器(ceph-mds): 代表Ceph文件系统存储元数据（即Ceph块设备和Ceph对象存储不使用MDS）。Ceph的元数据服务器允许POSIX文件系统的用户来执行基本的命令（如 ls，find等等）。\n\nCeph将数据作为对象存储在逻辑存储池中。Ceph 使用 CRUSH算法计算一个对象应该包含在哪个Placement group，并进一步计算这个Placement group应存储在哪个Ceph OSD守护程序。CRUSH算法使Ceph存储集群能够动态扩展，重新平衡和恢复。下面是Ceph文件对象存储流程图：\n\n![Ceph文件对象存储流程图](../../../../images/ceph.png)\n\n# 预安装\n## 添加密钥\n### APT\n```sh\nwget -q -O- 'https://download.ceph.com/keys/release.asc' | sudo apt-key add -\n```\n### RPM\n```sh\nsudo rpm --import 'https://download.ceph.com/keys/release.asc'\n```\n\n## 添加Ceph源\n### Ubuntu或Debian\n```sh\nsudo apt-add-repository 'deb https://download.ceph.com/debian-{ceph-release}/ $(lsb_release -sc) main'\nsudo apt update\n```\n### RHEL或CentOS\n```sh\n# 加入Ceph yum源文件\n$ cat  /etc/yum.repos.d/ceph.repo\n[ceph]\nname=Ceph packages for $basearch\nbaseurl=https://download.ceph.com/rpm-{ceph-release}/{distro}/$basearch\nenabled=1\npriority=2\ngpgcheck=1\ngpgkey=https://download.ceph.com/keys/release.asc\n\n[ceph-noarch]\nname=Ceph noarch packages\nbaseurl=https://download.ceph.com/rpm-{ceph-release}/{distro}/noarch\nenabled=1\npriority=2\ngpgcheck=1\ngpgkey=https://download.ceph.com/keys/release.asc\n\n[ceph-source]\nname=Ceph source packages\nbaseurl=https://download.ceph.com/rpm-{ceph-release}/{distro}/SRPMS\nenabled=0\npriority=2\ngpgcheck=1\ngpgkey=https://download.ceph.com/keys/release.asc\n\n$ yum clean all\n$ yum makecache\n```\n\n## 时间同步\n需要确保Ceph集群中所有节点的时间同步，使用 ntp 工具做时间同步。  \nCentOS / RHEL:\n```sh\nsudo yum install ntp ntpdate ntp-doc\n```\nDebian / Ubuntu:\n```sh\nsudo apt install ntpsec\n```\n或:\n```sh\nsudo apt install chrony\n```\n## 安装SSH服务\nCeph集群部署是在总控机器上通过SSH连接其它集群节点进行安装，所以需要保证所有Ceph集群节点都开启了SSH服务。\n\nCentOS / RHEL:\n```sh\nsudo yum install openssh-server\n```\nDebian / Ubuntu:\n```sh\nsudo apt install openssh-server\n```\n\n## 创建Ceph部署用户\n为了安全起见不建议使用root用户进行部署，创建一个Ceph部署专用的用户更为合理，而且需要保证部署机可通过“SSH免密登录”的方式使用Ceph部署用户登录到集群中的各个节点。\n\n创建用户:\n```sh\nssh user@ceph-server\nsudo useradd -d /home/{username} -m {username}\nsudo passwd {username}\n```\n需要保证Ceph部署用户是一个 sudoer:\n```sh\necho \"{username} ALL = (root) NOPASSWD:ALL\" | sudo tee /etc/sudoers.d/{username}\nsudo chmod 0440 /etc/sudoers.d/{username}\n```\n\n## 免密登录\n在主节点上执行下列指令实现免密登录：\n```sh\n$ ssh-copy-id ceph@{host}\n```\n\n\n## 安装ceph-deploy\n### Ubuntu或Debian\n```sh\n$ apt-get install ceph-deploy\n```\n### RHEL或CentOS\n```sh\n$ yum install ceph-deploy\n```\n\n# 部署Ceph集群\n 官方提供了三种部署Ceph集群的方法，分别是：ceph-deploy, cephadm, 手动安装。这里只介绍最大众化的安装方式： ceph-deploy。\n \n 演示案例采用3节点集群部署，主机名与IP映射如下：\n * node1: 192.168.56.101\n * node2: 192.168.56.102\n * node3: 192.168.56.103\n\n以 node1 作为部署主节点，如没有特殊说明下面给出的指令都运行在node1节点上。\n\n## 部署 ceph-mon\n1. 创建 Ceph 配置文件:\n```sh\n# 计划三个节点都部署ceph-mon服务，格式: ceph-deploy new {initial-monitor-node(s)}\n$ ceph-deploy new node1 node2 node3\n# 创建成功后会在当前目录生成这三个文件，其中ceph.conf是集群配置文件，ceph.mon.keyring是ceph-mon服务的密钥\n$ ls\nceph.conf ceph-deploy-ceph.log  ceph.mon.keyring\n```\n\n一个Ceph集群中至少拥有一个ceph-mon，为了实现高可用，Ceph集群可以部署多个ceph-mon服务，当集群中某一个ceph-mon服务挂掉后也不会影响整个集群使用。Ceph使用Paxos算法，该算法需要大多数ceph-mon（即，大于N / 2，其中N是ceph-mon的数量）才能形成仲裁。监视器的奇数往往会更好，尽管这不是必需的。\n\n这里只是配置初始的ceph-mon节点主机，可以在后续集群正常使用过程中添加新的ceph-mon。\n\n```sh\n# 后续添加ceph-mon的指令格式: ceph-deploy mon add {ceph-nodes}\n$ ceph-deploy mon add node4 node5\n```\n\n一旦添加了新的Ceph监视器，Ceph将开始同步监视器并形成仲裁。您可以通过执行以下操作检查仲裁状态：\n```sh\n$ ceph quorum_status --format json-pretty\n```\n\n2. 如果你的集群节点存在多个网卡，需要为ceph.conf文件添加Ceph集群通信网段的配置。演示网络是192.168.56.0/24网段，所以添加配置如下：\n```sh\n# public network = {ip-address}/{bits}\npublic network = 192.168.56.0/24\n```\n\n3. 如果采用了IPv6，还需要在ceph.conf中添加如下配置:\n```sh\nms bind ipv6 = true\n```\n\n4. 为每个节点安装 Ceph 依赖库。\n```sh\n$ ceph-deploy install --no-adjust-repos node1 node2 node3\n```\n\n这个指令会通过SSH远程到 node1,node2,node3 三个节点分别执行 `yum install` 或 `apt install` 安装，因为前面预处理章节已经配置了ceph的yum源或apt源，`--no-adjust-repos` 参数表明不修改节点的yum源或apt源，直接执行 `yum install` 或 `apt install` 指令下载需要的依赖库，不添加此参数的话可能会造成下载的库版本与我们预期的不一致问题。\n\n5. 初始化ceph-mon并创建组件密钥。\n```sh\n$ ceph-deploy mon create-initial\n```\n一旦指令执行成功，在当前目录下将会新增一些keyring文件：\n* ceph.client.admin.keyring\n* ceph.bootstrap-mgr.keyring\n* ceph.bootstrap-osd.keyring\n* ceph.bootstrap-mds.keyring\n* ceph.bootstrap-rgw.keyring\n* ceph.bootstrap-rbd.keyring\n* ceph.bootstrap-rbd-mirror.keyring\n\n6. 使用`ceph-deploy`复制配置文件以及admin用户的密钥到Ceph集群的其它节点，这样做其它节点也可以通过命令行对Ceph进行操作。\n```sh\n# 可以指定多个节点拥有ceph集群的管理权限，格式：ceph-deploy admin {ceph-node(s)}\n$ ceph-deploy admin node1\n# 确保当前用户拥有ceph.client.admin.keyring文件的读权限\n$ sudo chown {user}:{group} /etc/ceph/ceph.client.admin.keyring\n```\n指令执行完毕后，在指定节点的 /etc/ceph 目录下会新增 ceph.client.admin.keyring 密钥文件，ceph集群管理命令需要通过这个密钥认证才能执行。\n\nnode1上执行ceph命令，确认admin密钥正确:\n```sh\n[ceph@node1 ~]$ ceph -s\n  cluster:\n    id:     d809fd13-1fd6-4591-bd2b-5d4eabbadaba\n    health: HEALTH_WARN\n            no active mgr\n            OSD count 0 < osd_pool_default_size 3\n \n  services:\n    mon: 3 daemons, quorum node1,node2,node3 (age 11m)\n    mgr: no daemons active (since 63s)\n    osd: 0 osds: 0 up, 0 in\n \n  data:\n    pools:   0 pools, 0 pgs\n    objects: 0 objects, 0 B\n    usage:   0 B used, 0 B / 0 B avail\n    pgs: \n```\n\n在没有赋予管理权限的节点上尝试执行Ceph管理指令将会报错：\n```sh\n# 在 node2或node3 上执行\n[ceph@node2 ~]$ ceph -s\n[errno 2] error connecting to the cluster\n```\n\n## 部署 ceph-mgr\n在 luminous 或更新的版本需要这一步。\n```sh\n$ ceph-deploy mgr create node1\n# 看到Ceph集群状态中的 no active mgr 警告信息已经消失\n$ ceph -s\n  cluster:\n    id:     d809fd13-1fd6-4591-bd2b-5d4eabbadaba\n    health: HEALTH_WARN\n            OSD count 0 < osd_pool_default_size 3\n \n  services:\n    mon: 3 daemons, quorum node1,node2,node3 (age 14m)\n    mgr: node1(active, since 1.52953s)\n    osd: 0 osds: 0 up, 0 in\n \n  data:\n    pools:   0 pools, 0 pgs\n    objects: 0 objects, 0 B\n    usage:   0 B used, 0 B / 0 B avail\n    pgs:\n```\n\n## 添加OSD\nOSD是Ceph集群的基础存储单元，需要指定一个裸盘、主分区或逻辑分区作为一个OSD服务。\n\n笔者当前演示的环境是用3台虚拟机并各创建一个虚拟裸盘实现，3个节点均挂载这个虚拟磁盘在/dev/sdb上，大小为30G。\n```sh\n$ lsblk\nNAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT\nsda               8:0    0   10G  0 disk \n├─sda1            8:1    0    1G  0 part /boot\n└─sda2            8:2    0    9G  0 part \n  ├─centos-root 253:0    0    8G  0 lvm  /\n  └─centos-swap 253:1    0    1G  0 lvm  [SWAP]\nsdb               8:16   0   30G  0 disk \nsr0              11:0    1 1024M  0 rom\n```\n\n使用`ceph-deploy`添加OSD指令如下：\n```sh\n# 格式: ceph-deploy osd create --data {device} {ceph-node}\n# 如果你使用的是逻辑分区，参数格式为 --data vg_group/lv_name\n$ ceph-deploy osd create --data /dev/sdb node1\n$ ceph-deploy osd create --data /dev/sdb node2\n$ ceph-deploy osd create --data /dev/sdb node3\n```\n\n这里可能因Ceph版本不同细节有些许区别，若不幸遇到报错需要根据日志自己解决。\n```sh\n# 部署完毕后再次查看集群状态可以看到3个OSD已经启动\n$ ceph -s\n  cluster:\n    id:     d809fd13-1fd6-4591-bd2b-5d4eabbadaba\n    health: HEALTH_OK\n \n  services:\n    mon: 3 daemons, quorum node1,node2,node3 (age 34m)\n    mgr: node1(active, since 19m)\n    osd: 3 osds: 3 up (since 5s), 3 in (since 5s)\n \n  data:\n    pools:   0 pools, 0 pgs\n    objects: 0 objects, 0 B\n    usage:   3.0 GiB used, 84 GiB / 87 GiB avail\n    pgs:\n# 查看OSD树状结构\n$ ceph osd tree\nID CLASS WEIGHT  TYPE NAME      STATUS REWEIGHT PRI-AFF \n-1       0.08487 root default                           \n-3       0.02829     host node1                         \n 0   hdd 0.02829         osd.0      up  1.00000 1.00000 \n-5       0.02829     host node2                         \n 1   hdd 0.02829         osd.1      up  1.00000 1.00000 \n-7       0.02829     host node3                         \n 2   hdd 0.02829         osd.2      up  1.00000 1.00000\n```\n\n## 删除OSD\n```sh\n# 从crush中移除节点\n$ ceph osd crush remove osd.$ID\n# 将节点服务停止\n$ ceph osd down osd.$ID\n# 删除节点\n$ ceph osd rm osd.$ID\n# 删除节点认证\n$ ceph auth del osd.$ID\n```\n\n## 添加MDS\nceph-mds是CephFS必要的服务，如果可以采用部署[Orchestrator](https://docs.ceph.com/docs/master/mgr/orchestrator_cli/)自动为您的文件系统创建并配置MDS（请参阅 [Orchestrator部署表](https://docs.ceph.com/docs/master/mgr/orchestrator_cli/#current-implementation-status)）。否则，参照下列方法手动部署mds。\n\n想要启动CephFS前必须启动ceph-mds服务，执行下列脚本可部署mds服务（需要先配置环境变量）：\n```sh\n# 创建mds存储目录。\n$ mkdir -p /var/lib/ceph/mds/$CLUSTER_NAME-$MDS_ID\n# 部署ceph-mds服务，命令格式: ceph-deploy mds create {ceph-node}\n$ ceph-deploy mds create node1\n# 检测mds是否启动成功（\"1 up:standby\" 表示有一个mds节点启动成功）\n$ ceph mds stat\n 1 up:standby\n```\n\n至此Ceph集群基础组件部署完毕，可以根据需要往下部署不同存储类型的服务。\n\n# 三种Ceph存储类型的部署\nCephFS致力于为各种应用程序提供最新，多用途，高可用性和高性能的文件存储。提供了三种存储类型：\n* CephFS\n* Ceph Object Storage\n* CephRBD\n\n避免篇幅过长，本文只介绍最简单的部署及使用方式，过后会有其它文章详述各种存储类型的运行机制。\n\n## CephFS\n### 服务端部署\nCephFS 是 Ceph File System 的简称，它是在Ceph的分布式对象存储RADOS之上构建的POSIX兼容文件系统。\n文件元数据与文件数据存储在单独的RADOS池中，并通过可调整大小的元数据服务器或MDS集群提供服务，该集群是可拓展的以支持高吞吐量的元数据工作负载。\n\n文件系统的客户端可以直接访问RADOS以读取和写入文件数据块，因此，工作负载可能会随着基础RADOS对象存储的数量线性扩展，也就是说，没有网关或代理为客户端中介数据I / O。\n\n通过MDS集群协调对数据的访问，每个MDS都会将对元数据的变化汇总到日志以对RADOS进行一系列有效写入。MDS不会在本地存储任何元数据状态。此模型允许在POSIX文件系统的上下文中客户端之间进行连贯且快速的协作。\n\n![CephFS架构图](https://docs.ceph.com/docs/master/_images/cephfs-architecture.svg)\n\n创建cephfs可以直接使用如下指令:\n```sh\n# 创建名为 testfs 的文件系统资源\n$ ceph fs volume create testfs\n# 查看已有文件系统资源\n$ ceph fs ls\nname: testfs, metadata pool: cephfs.testfs.meta, data pools: [cephfs.testfs.data ]\n# ceph-mds 管理了这个FS\n$ ceph mds stat\ntestfs:1 {0=node1=up:active}\n# 查看集群状态\n$ ceph -s\n  cluster:\n    id:     908baedd-c2d1-4977-8aa8-dea83b31d271\n    health: HEALTH_OK\n \n  services:\n    mon: 1 daemons, quorum node1 (age 42m)\n    mgr: node1(active, since 50m)\n    mds: testfs:1 {0=node1=up:active}\n    osd: 3 osds: 3 up (since 25m), 3 in (since 51m)\n \n  data:\n    pools:   2 pools, 96 pgs\n    objects: 24 objects, 3.3 KiB\n    usage:   3.0 GiB used, 27 GiB / 30 GiB avail\n    pgs:     96 active+clean\n```\n该指令将自动创建一个元数据存储池（`cephfs.<FSNAME>.meta`）与一个内容存储池（`cephfs.<FSNAME>.data`）。\n\n若不幸出现了警告内容为`too few PGs per OSD (n < min 30)`，请参考Q&A章节获知解决方案。\n\n### 客户端挂载\nCephFS挂载有两种方法：使用Linux内核驱动或是使用ceph-fuse工具。实际上比较常用的是ceph-fuse工具方法，所以本文只介绍这种挂载方式。\n\n1. 需要先安装 ceph-fuse\n```sh\n$ yum install -y ceph-fuse\n```\n\n2. 在客户机生成服务端路径相关配置文件。\n```sh\n# 在客户机上执行\n$ mkdir -p -m 755 /etc/ceph\n$ ssh {user}@{mon-host} \"sudo ceph config generate-minimal-conf\" | sudo tee /etc/ceph/ceph.conf\n# 确保文件可以被其它用户访问到\n$ chmod 644 /etc/ceph/ceph.conf\n# 文件中记录了ceph-mon的地址以及集群ID\n$ cat /etc/ceph/ceph.conf\n[global]\nfsid = 908baedd-c2d1-4977-8aa8-dea83b31d271\nmon_host = [v2:192.168.56.101:3300/0,v1:192.168.56.101:6789/0]\n```\n\n3. 因为服务端采用了CephX认证方式，需要为客户端机器生成一份对应的密钥文件。\n```sh\n# 创建一个foo用户授权名为 testfs 的CephFS资源，并且拥有根路径下( / )的读写权限( rw )\n$ ssh {user}@{mon-host} \"sudo ceph fs authorize testfs client.foo / rw\" | sudo tee /etc/ceph/ceph.client.foo.keyring\n$ chmod 600 /etc/ceph/ceph.client.foo.keyring\n```\n\n4. 挂载CephFS到指定客户机目录\n```sh\n$ mkdir /mnt/mycephfs\n$ sudo ceph-fuse --id foo /mnt/mycephfs\nceph-fuse[4131]: starting ceph client\n2020-02-02 05:21:21.476 7f5f9b493e00 -1 init, newargv = 0x561161876670 newargc=7\nceph-fuse[4131]: starting fuse\n# 确认目录挂载成功\n$ df -h | grep ceph-fuse\nceph-fuse                 26G     0   26G    0% /mnt/mycephfs\n```\n\n5. 撤销挂载卷\n```sh\n$ umount /mnt/mycephfs\n```\n\n执行完上述4步后就算是挂载完毕了，但是客户机重启后挂载卷将会消失需要重新执行`ceph-fuse`指令挂载回来，可以修改`/etc/fstab`文件做到开机自动挂载，需要在`/etc/fstab`文件中添加如下配置：\n```sh\n#DEVICE PATH       TYPE      OPTIONS\nnone    /mnt/mycephfs  fuse.ceph ceph.id={user-ID}[,ceph.conf={path/to/conf.conf}],_netdev,defaults  0 0\n```\n例子:\n```sh\nnone    /mnt/mycephfs  fuse.ceph ceph.id=foo,_netdev,defaults  0 0\n# 面向多个Ceph集群时，需要手动指定特定集群的配置文件（默认使用 /etc/ceph/ceph.conf）\nnone    /mnt/mycephfs  fuse.ceph ceph.id=foo,ceph.conf=/etc/ceph/foo.conf,_netdev,defaults  0 0 \n```\n\n## Ceph Object Storage\nCeph对象网关是一个对象存储接口，建立在该对象之上， librados为应用程序提供了通往Ceph存储集群的RESTful网关。\n\nCeph对象存储支持两个接口：\n* 与S3兼容：为对象存储功能提供与Amazon S3 RESTful API的大部分子集兼容的接口。\n* 兼容Swift：为对象存储功能提供与OpenStack Swift API的大部分子集兼容的接口。\n\nS3和Swift API共享一个公共的名称空间，因此您可以使用一个API编写数据，而使用另一个API检索数据。\n\n![Ceph Object Storage 架构图](https://docs.ceph.com/docs/master/_images/ditaa-50d12451eb76c5c72c4574b08f0320b39a42e5f1.png)\n\n1. 安装Rados Gateway的依赖库。\n```sh\n# ceph-deploy install --rgw <gateway-node1> [<gateway-node2> ...]\n$ ceph-deploy install --rgw node1\n```\n\n2. 创建Rados网关实例。\n```sh\n# ceph-deploy rgw create <gateway-node1>\n$ ceph-deploy rgw create node1\n```\n默认Rados网关占用7480端口，可以使用浏览器访问`http://node1:7480/`得到如下响应，说明网关部署已完毕：\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ListAllMyBucketsResult xmlns=\"http://s3.amazonaws.com/doc/2006-03-01/\">\n       <Owner>\n               <ID>anonymous</ID>\n               <DisplayName></DisplayName>\n       </Owner>\n       <Buckets>\n       </Buckets>\n</ListAllMyBucketsResult>\n```\n\n3. [可选] 修改Rados网关端口。修改`ceph.conf`文件添加如下内容:\n```sh\n[client.rgw.node1]  # node1对应上面第2步部署的节点\nrgw_frontends = \"civetweb port=80\"  # 修改为80端口\n```\n然后使用ceph-deploy更新相关节点的`ceph.conf`文件:\n```sh\n# ceph-deploy --overwrite-conf config push <gateway-node> [<other-nodes>]\n$ ceph-deploy --overwrite-conf config push node1\n# 重启rados网关服务才能使配置生效\n$ sudo systemctl restart ceph-radosgw.service\n```\n\n4. [可选] 使Rados网关支持SSL协议。需要先生成证书（略），然后修改`ceph.conf`文件添加如下配置：\n```sh\n[client.rgw.node1]\nrgw_frontends = civetweb port=443s ssl_certificate=/etc/ceph/private/keyandcert.pem # ssl_certificate指定证书路径\n```\n也可以同时开放HTTP协议端口与HTTPS协议端口，配置修改如下：\n```sh\n[client.rgw.node1]\nrgw_frontends = civetweb port=80+443s ssl_certificate=/etc/ceph/private/keyandcert.pem \n```\n\n5. 添加用户。Ceph Object Storage 的 Rados 网关支持 S3 与 Swift 两种 API，但它们的用户权限管理有所不同，所以需要根据需要生成不同类型的用户。\n* 添加S3用户: `sudo radosgw-admin user create --uid=\"testuser\" --display-name=\"First User\"`\n* 添加Swift用户: `sudo radosgw-admin subuser create --uid=testuser --subuser=testuser:swift --access=full`\n\n到此Rados网关基础部署算是完成了，测试网关上传下载功能请参考: https://docs.ceph.com/docs/master/install/install-ceph-gateway/#access-verification。\n\n## CephRBD\n块是字节序列（例如，一个512字节的数据块）。基于块的存储接口是使用旋转介质（例如硬盘，CD，软盘甚至传统的9轨磁带）存储数据的最常用方法。块设备接口无处不在使虚拟块设备成为与海量数据存储系统（如Ceph）进行交互的理想选择。\n\nCeph块设备经过精简配置，可调整大小，并在Ceph集群中的多个OSD上存储条带化数据。Ceph块设备利用了 RADOS功能，例如快照，复制和一致性。Ceph的 RADOS块设备（RBD）使用内核模块或librbd库与OSD进行交互。\n\n![Ceph块设备架构图](https://docs.ceph.com/docs/master/_images/ditaa-dc9f80d771b55f2daa5cbbfdb2dd0d3e6dfc17c0.png)\n\n1. 创建一个用于RBD的存储池。\n```sh\n$ ceph osd pool create rbdpool\n```\n\n2. 使用RBD工具初始化这个存储池。\n```sh\n$ rbd pool init rbdpool\n```\n\n3. 创建可以访问这个RBD的用户。\n```sh\n# ceph auth get-or-create client.{ID} mon 'profile rbd' osd 'profile {profile name} [pool={pool-name}][, profile ...]' mgr 'profile rbd [pool={pool-name}]'\n$ ceph auth get-or-create client.testrbd mon 'profile rbd' osd 'profile rbd pool=rbdpool' mgr 'profile rbd'\n```\n\n4. 创建块设备镜像。在您开始将数据保存到它们之前，它们实际上并不使用任何物理存储。但是，它们确实具有您使用`--size`选项设置的最大容量。\n```sh\n# 创建名为testrbd的镜像，大小为1GB。指令格式：rbd create --size {megabytes} {pool-name}/{image-name}\n$ rbd create --size 1024 rbdpool/testrbd\n# 查看rbdpool存储池中有哪些RBD镜像\n$ rbd ls rbdpool\ntestrbd\n# 检索RBD镜像信息: rbd info {pool-name}/{image-name}\n$ rbd info rbdpool/testrbd\nrbd image 'testrbd':\n\tsize 1 GiB in 256 objects\n\torder 22 (4 MiB objects)\n\tsnapshot_count: 0\n\tid: 56bc9dc78ddfe\n\tblock_name_prefix: rbd_data.56bc9dc78ddfe\n\tformat: 2\n\tfeatures: layering, exclusive-lock, object-map, fast-diff, deep-flatten\n\top_features: \n\tflags: \n\tcreate_timestamp: Mon Feb  3 18:56:49 2020\n\taccess_timestamp: Mon Feb  3 18:56:49 2020\n\tmodify_timestamp: Mon Feb  3 18:56:49 2020\n# 调整块设备映像的大小为2GB\n$  rbd resize --size 2048 rbdpool/testrbd\n# 删除块设备的镜像\n# rbd rm {pool-name}/{image-name}\n# 例如: rbd rm foo\n```\n\n5. 使用librbd进行存储。为了演示方便，这里使用python编写一个简单例子。ceph的python库是在安装ceph时一并安装好的，不需要再执行`pip install`进行安装。\n\n```python\nimport rbd\nimport rados\n\ncluster = rados.Rados(conffile='/etc/ceph/ceph.conf')\ntry:\n    cluster.connect()\n    print(\"Cluster connect success\")\n    ioctx = cluster.open_ioctx('rbdpool')\n    try:\n        image = rbd.Image(ioctx, 'testrbd')\n        try:\n            # 块设备写入数据\n            print(\"Writing content...\")\n            data = 'foo' * 200\n            image.write(data, 0)\n            image.flush()\n            print(\"Write finished!\")\n\n            # 块设备读取数据\n            size = image.size()\n            print(\"Reading content...\")\n            i = 0\n            bufsize = 1024\n            buffer = bytes()\n            while i < size:\n                buffer = buffer + image.read(i, min(i + bufsize, size - 1))\n                i += size\n            print(\"%s\" % str(buffer))\n        finally:\n            image.close()\n    finally:\n        ioctx.close()\nfinally:\n    cluster.shutdown()\n```\n\n# Q&A\n## 删除pool报错 pool deletion is disabled\n修改mon节点的配置文件：\n```sh\n$ vi /etc/ceph/ceph.conf \n```\n添加如下配置内容:\n```\n[mon]\nmon allow pool delete = true\n```\n重启ceph-mon服务:\n```sh\n$ systemctl restart ceph-mon.target\n```\n执行删除pool命令:\n```sh\n$ ceph osd pool delete ecpool ecpool --yes-i-really-really-mean-it\npool 'ecpool' removed\n```\n\n## 100.000% pgs not active undersized+peered\n按照官方文档的说法是：\n```\nundersized\nThe placement group has fewer copies than the configured pool replication level.\n```\n意思是这个PG的实际副本数少于配置的副本数。所以这个警告原因是有某个pool的size值大于Ceph OSD集群的节点数了，这样使得Ceph找不到更多的节点数来备份这个PG，PG就会变成undersized状态。\n\n前面的 100.000% 是因为我当时的集群只有一个pool而且就这个pool的size值配错了，所以是100%的PG数都变成undersized状态。这个百分比可能不是100%，实际情况下需要查询各个pool配置情况来找出这个错误配置的pool。\n\n## no active mgr\n集群没有开启ceph-mgr组件，请参照\"添加ceph-mgr\"章节。\n\n## too few PGs per OSD ( n < 30 )\n出现这个警告信息的原因是所有池的PG总数除于OSD数得到的值小于30导致的，可以通过`ceph osd pool set $POOL_NAME pg_num $PG_NUM`命令修改各个池的PG数，使得总PG数满足如下公式即可：\n\nTotal PGs = ((Total_number_of_OSD * 30) / max_replication_count) / pool_count \n\n结算的结果往上取靠近2的N次方的值。","source":"_posts/ceph-1.md","raw":"---\ntitle: \"Ceph集群部署\"\ncategory: Ceph\n---\n\n本文主要介绍Ceph存储集群的部署方式，以及三种存储类型服务的构建及简单使用，不对内部原理做深入介绍，过后会编写另外的文章聊这个话题。本文属于个人学习笔记，如有错误欢迎指正，部署期间踩到的坑写在了Q&A。\n\n<!-- more -->\n\n# 组件介绍\n一个Ceph存储群集至少需要一个监控器(ceph-mon)，管理器(ceph-mgr)和对象存储守护程序(ceph-osd)。运行Ceph文件系统客户端时，还需要元数据服务器(ceph-mds)。\n* 管理器(ceph-mon): 维护集群状态的映射，包括监视器映射，管理器映射，OSD映射，MDS映射和CRUSH映射。这些映射是Ceph守护程序相互协调所需的关键群集状态。监视器还负责管理守护程序和客户端之间的身份验证。通常至少需要三个监视器才能实现冗余和高可用性。\n* 管理器(ceph-mgr): 负责跟踪运行时指标和Ceph集群的当前状态，包括存储利用率，当前性能指标和系统负载。Ceph Manager守护程序基于python模块进行管理并且负责公开Ceph集群信息（包括基于Web的Ceph Dashboard和 REST API）。通常，至少需要两个管理器才能实现高可用性。\n* 对象存储守护程序(ceph-osd): 处理数据复制，恢复，重新平衡，并通过检查其他Ceph OSD守护程序的心跳来向Ceph监视器和管理器提供一些监视信息。通常至少需要3个Ceph OSD才能实现冗余和高可用性。\n* 元数据服务器(ceph-mds): 代表Ceph文件系统存储元数据（即Ceph块设备和Ceph对象存储不使用MDS）。Ceph的元数据服务器允许POSIX文件系统的用户来执行基本的命令（如 ls，find等等）。\n\nCeph将数据作为对象存储在逻辑存储池中。Ceph 使用 CRUSH算法计算一个对象应该包含在哪个Placement group，并进一步计算这个Placement group应存储在哪个Ceph OSD守护程序。CRUSH算法使Ceph存储集群能够动态扩展，重新平衡和恢复。下面是Ceph文件对象存储流程图：\n\n![Ceph文件对象存储流程图](../../../../images/ceph.png)\n\n# 预安装\n## 添加密钥\n### APT\n```sh\nwget -q -O- 'https://download.ceph.com/keys/release.asc' | sudo apt-key add -\n```\n### RPM\n```sh\nsudo rpm --import 'https://download.ceph.com/keys/release.asc'\n```\n\n## 添加Ceph源\n### Ubuntu或Debian\n```sh\nsudo apt-add-repository 'deb https://download.ceph.com/debian-{ceph-release}/ $(lsb_release -sc) main'\nsudo apt update\n```\n### RHEL或CentOS\n```sh\n# 加入Ceph yum源文件\n$ cat  /etc/yum.repos.d/ceph.repo\n[ceph]\nname=Ceph packages for $basearch\nbaseurl=https://download.ceph.com/rpm-{ceph-release}/{distro}/$basearch\nenabled=1\npriority=2\ngpgcheck=1\ngpgkey=https://download.ceph.com/keys/release.asc\n\n[ceph-noarch]\nname=Ceph noarch packages\nbaseurl=https://download.ceph.com/rpm-{ceph-release}/{distro}/noarch\nenabled=1\npriority=2\ngpgcheck=1\ngpgkey=https://download.ceph.com/keys/release.asc\n\n[ceph-source]\nname=Ceph source packages\nbaseurl=https://download.ceph.com/rpm-{ceph-release}/{distro}/SRPMS\nenabled=0\npriority=2\ngpgcheck=1\ngpgkey=https://download.ceph.com/keys/release.asc\n\n$ yum clean all\n$ yum makecache\n```\n\n## 时间同步\n需要确保Ceph集群中所有节点的时间同步，使用 ntp 工具做时间同步。  \nCentOS / RHEL:\n```sh\nsudo yum install ntp ntpdate ntp-doc\n```\nDebian / Ubuntu:\n```sh\nsudo apt install ntpsec\n```\n或:\n```sh\nsudo apt install chrony\n```\n## 安装SSH服务\nCeph集群部署是在总控机器上通过SSH连接其它集群节点进行安装，所以需要保证所有Ceph集群节点都开启了SSH服务。\n\nCentOS / RHEL:\n```sh\nsudo yum install openssh-server\n```\nDebian / Ubuntu:\n```sh\nsudo apt install openssh-server\n```\n\n## 创建Ceph部署用户\n为了安全起见不建议使用root用户进行部署，创建一个Ceph部署专用的用户更为合理，而且需要保证部署机可通过“SSH免密登录”的方式使用Ceph部署用户登录到集群中的各个节点。\n\n创建用户:\n```sh\nssh user@ceph-server\nsudo useradd -d /home/{username} -m {username}\nsudo passwd {username}\n```\n需要保证Ceph部署用户是一个 sudoer:\n```sh\necho \"{username} ALL = (root) NOPASSWD:ALL\" | sudo tee /etc/sudoers.d/{username}\nsudo chmod 0440 /etc/sudoers.d/{username}\n```\n\n## 免密登录\n在主节点上执行下列指令实现免密登录：\n```sh\n$ ssh-copy-id ceph@{host}\n```\n\n\n## 安装ceph-deploy\n### Ubuntu或Debian\n```sh\n$ apt-get install ceph-deploy\n```\n### RHEL或CentOS\n```sh\n$ yum install ceph-deploy\n```\n\n# 部署Ceph集群\n 官方提供了三种部署Ceph集群的方法，分别是：ceph-deploy, cephadm, 手动安装。这里只介绍最大众化的安装方式： ceph-deploy。\n \n 演示案例采用3节点集群部署，主机名与IP映射如下：\n * node1: 192.168.56.101\n * node2: 192.168.56.102\n * node3: 192.168.56.103\n\n以 node1 作为部署主节点，如没有特殊说明下面给出的指令都运行在node1节点上。\n\n## 部署 ceph-mon\n1. 创建 Ceph 配置文件:\n```sh\n# 计划三个节点都部署ceph-mon服务，格式: ceph-deploy new {initial-monitor-node(s)}\n$ ceph-deploy new node1 node2 node3\n# 创建成功后会在当前目录生成这三个文件，其中ceph.conf是集群配置文件，ceph.mon.keyring是ceph-mon服务的密钥\n$ ls\nceph.conf ceph-deploy-ceph.log  ceph.mon.keyring\n```\n\n一个Ceph集群中至少拥有一个ceph-mon，为了实现高可用，Ceph集群可以部署多个ceph-mon服务，当集群中某一个ceph-mon服务挂掉后也不会影响整个集群使用。Ceph使用Paxos算法，该算法需要大多数ceph-mon（即，大于N / 2，其中N是ceph-mon的数量）才能形成仲裁。监视器的奇数往往会更好，尽管这不是必需的。\n\n这里只是配置初始的ceph-mon节点主机，可以在后续集群正常使用过程中添加新的ceph-mon。\n\n```sh\n# 后续添加ceph-mon的指令格式: ceph-deploy mon add {ceph-nodes}\n$ ceph-deploy mon add node4 node5\n```\n\n一旦添加了新的Ceph监视器，Ceph将开始同步监视器并形成仲裁。您可以通过执行以下操作检查仲裁状态：\n```sh\n$ ceph quorum_status --format json-pretty\n```\n\n2. 如果你的集群节点存在多个网卡，需要为ceph.conf文件添加Ceph集群通信网段的配置。演示网络是192.168.56.0/24网段，所以添加配置如下：\n```sh\n# public network = {ip-address}/{bits}\npublic network = 192.168.56.0/24\n```\n\n3. 如果采用了IPv6，还需要在ceph.conf中添加如下配置:\n```sh\nms bind ipv6 = true\n```\n\n4. 为每个节点安装 Ceph 依赖库。\n```sh\n$ ceph-deploy install --no-adjust-repos node1 node2 node3\n```\n\n这个指令会通过SSH远程到 node1,node2,node3 三个节点分别执行 `yum install` 或 `apt install` 安装，因为前面预处理章节已经配置了ceph的yum源或apt源，`--no-adjust-repos` 参数表明不修改节点的yum源或apt源，直接执行 `yum install` 或 `apt install` 指令下载需要的依赖库，不添加此参数的话可能会造成下载的库版本与我们预期的不一致问题。\n\n5. 初始化ceph-mon并创建组件密钥。\n```sh\n$ ceph-deploy mon create-initial\n```\n一旦指令执行成功，在当前目录下将会新增一些keyring文件：\n* ceph.client.admin.keyring\n* ceph.bootstrap-mgr.keyring\n* ceph.bootstrap-osd.keyring\n* ceph.bootstrap-mds.keyring\n* ceph.bootstrap-rgw.keyring\n* ceph.bootstrap-rbd.keyring\n* ceph.bootstrap-rbd-mirror.keyring\n\n6. 使用`ceph-deploy`复制配置文件以及admin用户的密钥到Ceph集群的其它节点，这样做其它节点也可以通过命令行对Ceph进行操作。\n```sh\n# 可以指定多个节点拥有ceph集群的管理权限，格式：ceph-deploy admin {ceph-node(s)}\n$ ceph-deploy admin node1\n# 确保当前用户拥有ceph.client.admin.keyring文件的读权限\n$ sudo chown {user}:{group} /etc/ceph/ceph.client.admin.keyring\n```\n指令执行完毕后，在指定节点的 /etc/ceph 目录下会新增 ceph.client.admin.keyring 密钥文件，ceph集群管理命令需要通过这个密钥认证才能执行。\n\nnode1上执行ceph命令，确认admin密钥正确:\n```sh\n[ceph@node1 ~]$ ceph -s\n  cluster:\n    id:     d809fd13-1fd6-4591-bd2b-5d4eabbadaba\n    health: HEALTH_WARN\n            no active mgr\n            OSD count 0 < osd_pool_default_size 3\n \n  services:\n    mon: 3 daemons, quorum node1,node2,node3 (age 11m)\n    mgr: no daemons active (since 63s)\n    osd: 0 osds: 0 up, 0 in\n \n  data:\n    pools:   0 pools, 0 pgs\n    objects: 0 objects, 0 B\n    usage:   0 B used, 0 B / 0 B avail\n    pgs: \n```\n\n在没有赋予管理权限的节点上尝试执行Ceph管理指令将会报错：\n```sh\n# 在 node2或node3 上执行\n[ceph@node2 ~]$ ceph -s\n[errno 2] error connecting to the cluster\n```\n\n## 部署 ceph-mgr\n在 luminous 或更新的版本需要这一步。\n```sh\n$ ceph-deploy mgr create node1\n# 看到Ceph集群状态中的 no active mgr 警告信息已经消失\n$ ceph -s\n  cluster:\n    id:     d809fd13-1fd6-4591-bd2b-5d4eabbadaba\n    health: HEALTH_WARN\n            OSD count 0 < osd_pool_default_size 3\n \n  services:\n    mon: 3 daemons, quorum node1,node2,node3 (age 14m)\n    mgr: node1(active, since 1.52953s)\n    osd: 0 osds: 0 up, 0 in\n \n  data:\n    pools:   0 pools, 0 pgs\n    objects: 0 objects, 0 B\n    usage:   0 B used, 0 B / 0 B avail\n    pgs:\n```\n\n## 添加OSD\nOSD是Ceph集群的基础存储单元，需要指定一个裸盘、主分区或逻辑分区作为一个OSD服务。\n\n笔者当前演示的环境是用3台虚拟机并各创建一个虚拟裸盘实现，3个节点均挂载这个虚拟磁盘在/dev/sdb上，大小为30G。\n```sh\n$ lsblk\nNAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT\nsda               8:0    0   10G  0 disk \n├─sda1            8:1    0    1G  0 part /boot\n└─sda2            8:2    0    9G  0 part \n  ├─centos-root 253:0    0    8G  0 lvm  /\n  └─centos-swap 253:1    0    1G  0 lvm  [SWAP]\nsdb               8:16   0   30G  0 disk \nsr0              11:0    1 1024M  0 rom\n```\n\n使用`ceph-deploy`添加OSD指令如下：\n```sh\n# 格式: ceph-deploy osd create --data {device} {ceph-node}\n# 如果你使用的是逻辑分区，参数格式为 --data vg_group/lv_name\n$ ceph-deploy osd create --data /dev/sdb node1\n$ ceph-deploy osd create --data /dev/sdb node2\n$ ceph-deploy osd create --data /dev/sdb node3\n```\n\n这里可能因Ceph版本不同细节有些许区别，若不幸遇到报错需要根据日志自己解决。\n```sh\n# 部署完毕后再次查看集群状态可以看到3个OSD已经启动\n$ ceph -s\n  cluster:\n    id:     d809fd13-1fd6-4591-bd2b-5d4eabbadaba\n    health: HEALTH_OK\n \n  services:\n    mon: 3 daemons, quorum node1,node2,node3 (age 34m)\n    mgr: node1(active, since 19m)\n    osd: 3 osds: 3 up (since 5s), 3 in (since 5s)\n \n  data:\n    pools:   0 pools, 0 pgs\n    objects: 0 objects, 0 B\n    usage:   3.0 GiB used, 84 GiB / 87 GiB avail\n    pgs:\n# 查看OSD树状结构\n$ ceph osd tree\nID CLASS WEIGHT  TYPE NAME      STATUS REWEIGHT PRI-AFF \n-1       0.08487 root default                           \n-3       0.02829     host node1                         \n 0   hdd 0.02829         osd.0      up  1.00000 1.00000 \n-5       0.02829     host node2                         \n 1   hdd 0.02829         osd.1      up  1.00000 1.00000 \n-7       0.02829     host node3                         \n 2   hdd 0.02829         osd.2      up  1.00000 1.00000\n```\n\n## 删除OSD\n```sh\n# 从crush中移除节点\n$ ceph osd crush remove osd.$ID\n# 将节点服务停止\n$ ceph osd down osd.$ID\n# 删除节点\n$ ceph osd rm osd.$ID\n# 删除节点认证\n$ ceph auth del osd.$ID\n```\n\n## 添加MDS\nceph-mds是CephFS必要的服务，如果可以采用部署[Orchestrator](https://docs.ceph.com/docs/master/mgr/orchestrator_cli/)自动为您的文件系统创建并配置MDS（请参阅 [Orchestrator部署表](https://docs.ceph.com/docs/master/mgr/orchestrator_cli/#current-implementation-status)）。否则，参照下列方法手动部署mds。\n\n想要启动CephFS前必须启动ceph-mds服务，执行下列脚本可部署mds服务（需要先配置环境变量）：\n```sh\n# 创建mds存储目录。\n$ mkdir -p /var/lib/ceph/mds/$CLUSTER_NAME-$MDS_ID\n# 部署ceph-mds服务，命令格式: ceph-deploy mds create {ceph-node}\n$ ceph-deploy mds create node1\n# 检测mds是否启动成功（\"1 up:standby\" 表示有一个mds节点启动成功）\n$ ceph mds stat\n 1 up:standby\n```\n\n至此Ceph集群基础组件部署完毕，可以根据需要往下部署不同存储类型的服务。\n\n# 三种Ceph存储类型的部署\nCephFS致力于为各种应用程序提供最新，多用途，高可用性和高性能的文件存储。提供了三种存储类型：\n* CephFS\n* Ceph Object Storage\n* CephRBD\n\n避免篇幅过长，本文只介绍最简单的部署及使用方式，过后会有其它文章详述各种存储类型的运行机制。\n\n## CephFS\n### 服务端部署\nCephFS 是 Ceph File System 的简称，它是在Ceph的分布式对象存储RADOS之上构建的POSIX兼容文件系统。\n文件元数据与文件数据存储在单独的RADOS池中，并通过可调整大小的元数据服务器或MDS集群提供服务，该集群是可拓展的以支持高吞吐量的元数据工作负载。\n\n文件系统的客户端可以直接访问RADOS以读取和写入文件数据块，因此，工作负载可能会随着基础RADOS对象存储的数量线性扩展，也就是说，没有网关或代理为客户端中介数据I / O。\n\n通过MDS集群协调对数据的访问，每个MDS都会将对元数据的变化汇总到日志以对RADOS进行一系列有效写入。MDS不会在本地存储任何元数据状态。此模型允许在POSIX文件系统的上下文中客户端之间进行连贯且快速的协作。\n\n![CephFS架构图](https://docs.ceph.com/docs/master/_images/cephfs-architecture.svg)\n\n创建cephfs可以直接使用如下指令:\n```sh\n# 创建名为 testfs 的文件系统资源\n$ ceph fs volume create testfs\n# 查看已有文件系统资源\n$ ceph fs ls\nname: testfs, metadata pool: cephfs.testfs.meta, data pools: [cephfs.testfs.data ]\n# ceph-mds 管理了这个FS\n$ ceph mds stat\ntestfs:1 {0=node1=up:active}\n# 查看集群状态\n$ ceph -s\n  cluster:\n    id:     908baedd-c2d1-4977-8aa8-dea83b31d271\n    health: HEALTH_OK\n \n  services:\n    mon: 1 daemons, quorum node1 (age 42m)\n    mgr: node1(active, since 50m)\n    mds: testfs:1 {0=node1=up:active}\n    osd: 3 osds: 3 up (since 25m), 3 in (since 51m)\n \n  data:\n    pools:   2 pools, 96 pgs\n    objects: 24 objects, 3.3 KiB\n    usage:   3.0 GiB used, 27 GiB / 30 GiB avail\n    pgs:     96 active+clean\n```\n该指令将自动创建一个元数据存储池（`cephfs.<FSNAME>.meta`）与一个内容存储池（`cephfs.<FSNAME>.data`）。\n\n若不幸出现了警告内容为`too few PGs per OSD (n < min 30)`，请参考Q&A章节获知解决方案。\n\n### 客户端挂载\nCephFS挂载有两种方法：使用Linux内核驱动或是使用ceph-fuse工具。实际上比较常用的是ceph-fuse工具方法，所以本文只介绍这种挂载方式。\n\n1. 需要先安装 ceph-fuse\n```sh\n$ yum install -y ceph-fuse\n```\n\n2. 在客户机生成服务端路径相关配置文件。\n```sh\n# 在客户机上执行\n$ mkdir -p -m 755 /etc/ceph\n$ ssh {user}@{mon-host} \"sudo ceph config generate-minimal-conf\" | sudo tee /etc/ceph/ceph.conf\n# 确保文件可以被其它用户访问到\n$ chmod 644 /etc/ceph/ceph.conf\n# 文件中记录了ceph-mon的地址以及集群ID\n$ cat /etc/ceph/ceph.conf\n[global]\nfsid = 908baedd-c2d1-4977-8aa8-dea83b31d271\nmon_host = [v2:192.168.56.101:3300/0,v1:192.168.56.101:6789/0]\n```\n\n3. 因为服务端采用了CephX认证方式，需要为客户端机器生成一份对应的密钥文件。\n```sh\n# 创建一个foo用户授权名为 testfs 的CephFS资源，并且拥有根路径下( / )的读写权限( rw )\n$ ssh {user}@{mon-host} \"sudo ceph fs authorize testfs client.foo / rw\" | sudo tee /etc/ceph/ceph.client.foo.keyring\n$ chmod 600 /etc/ceph/ceph.client.foo.keyring\n```\n\n4. 挂载CephFS到指定客户机目录\n```sh\n$ mkdir /mnt/mycephfs\n$ sudo ceph-fuse --id foo /mnt/mycephfs\nceph-fuse[4131]: starting ceph client\n2020-02-02 05:21:21.476 7f5f9b493e00 -1 init, newargv = 0x561161876670 newargc=7\nceph-fuse[4131]: starting fuse\n# 确认目录挂载成功\n$ df -h | grep ceph-fuse\nceph-fuse                 26G     0   26G    0% /mnt/mycephfs\n```\n\n5. 撤销挂载卷\n```sh\n$ umount /mnt/mycephfs\n```\n\n执行完上述4步后就算是挂载完毕了，但是客户机重启后挂载卷将会消失需要重新执行`ceph-fuse`指令挂载回来，可以修改`/etc/fstab`文件做到开机自动挂载，需要在`/etc/fstab`文件中添加如下配置：\n```sh\n#DEVICE PATH       TYPE      OPTIONS\nnone    /mnt/mycephfs  fuse.ceph ceph.id={user-ID}[,ceph.conf={path/to/conf.conf}],_netdev,defaults  0 0\n```\n例子:\n```sh\nnone    /mnt/mycephfs  fuse.ceph ceph.id=foo,_netdev,defaults  0 0\n# 面向多个Ceph集群时，需要手动指定特定集群的配置文件（默认使用 /etc/ceph/ceph.conf）\nnone    /mnt/mycephfs  fuse.ceph ceph.id=foo,ceph.conf=/etc/ceph/foo.conf,_netdev,defaults  0 0 \n```\n\n## Ceph Object Storage\nCeph对象网关是一个对象存储接口，建立在该对象之上， librados为应用程序提供了通往Ceph存储集群的RESTful网关。\n\nCeph对象存储支持两个接口：\n* 与S3兼容：为对象存储功能提供与Amazon S3 RESTful API的大部分子集兼容的接口。\n* 兼容Swift：为对象存储功能提供与OpenStack Swift API的大部分子集兼容的接口。\n\nS3和Swift API共享一个公共的名称空间，因此您可以使用一个API编写数据，而使用另一个API检索数据。\n\n![Ceph Object Storage 架构图](https://docs.ceph.com/docs/master/_images/ditaa-50d12451eb76c5c72c4574b08f0320b39a42e5f1.png)\n\n1. 安装Rados Gateway的依赖库。\n```sh\n# ceph-deploy install --rgw <gateway-node1> [<gateway-node2> ...]\n$ ceph-deploy install --rgw node1\n```\n\n2. 创建Rados网关实例。\n```sh\n# ceph-deploy rgw create <gateway-node1>\n$ ceph-deploy rgw create node1\n```\n默认Rados网关占用7480端口，可以使用浏览器访问`http://node1:7480/`得到如下响应，说明网关部署已完毕：\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ListAllMyBucketsResult xmlns=\"http://s3.amazonaws.com/doc/2006-03-01/\">\n       <Owner>\n               <ID>anonymous</ID>\n               <DisplayName></DisplayName>\n       </Owner>\n       <Buckets>\n       </Buckets>\n</ListAllMyBucketsResult>\n```\n\n3. [可选] 修改Rados网关端口。修改`ceph.conf`文件添加如下内容:\n```sh\n[client.rgw.node1]  # node1对应上面第2步部署的节点\nrgw_frontends = \"civetweb port=80\"  # 修改为80端口\n```\n然后使用ceph-deploy更新相关节点的`ceph.conf`文件:\n```sh\n# ceph-deploy --overwrite-conf config push <gateway-node> [<other-nodes>]\n$ ceph-deploy --overwrite-conf config push node1\n# 重启rados网关服务才能使配置生效\n$ sudo systemctl restart ceph-radosgw.service\n```\n\n4. [可选] 使Rados网关支持SSL协议。需要先生成证书（略），然后修改`ceph.conf`文件添加如下配置：\n```sh\n[client.rgw.node1]\nrgw_frontends = civetweb port=443s ssl_certificate=/etc/ceph/private/keyandcert.pem # ssl_certificate指定证书路径\n```\n也可以同时开放HTTP协议端口与HTTPS协议端口，配置修改如下：\n```sh\n[client.rgw.node1]\nrgw_frontends = civetweb port=80+443s ssl_certificate=/etc/ceph/private/keyandcert.pem \n```\n\n5. 添加用户。Ceph Object Storage 的 Rados 网关支持 S3 与 Swift 两种 API，但它们的用户权限管理有所不同，所以需要根据需要生成不同类型的用户。\n* 添加S3用户: `sudo radosgw-admin user create --uid=\"testuser\" --display-name=\"First User\"`\n* 添加Swift用户: `sudo radosgw-admin subuser create --uid=testuser --subuser=testuser:swift --access=full`\n\n到此Rados网关基础部署算是完成了，测试网关上传下载功能请参考: https://docs.ceph.com/docs/master/install/install-ceph-gateway/#access-verification。\n\n## CephRBD\n块是字节序列（例如，一个512字节的数据块）。基于块的存储接口是使用旋转介质（例如硬盘，CD，软盘甚至传统的9轨磁带）存储数据的最常用方法。块设备接口无处不在使虚拟块设备成为与海量数据存储系统（如Ceph）进行交互的理想选择。\n\nCeph块设备经过精简配置，可调整大小，并在Ceph集群中的多个OSD上存储条带化数据。Ceph块设备利用了 RADOS功能，例如快照，复制和一致性。Ceph的 RADOS块设备（RBD）使用内核模块或librbd库与OSD进行交互。\n\n![Ceph块设备架构图](https://docs.ceph.com/docs/master/_images/ditaa-dc9f80d771b55f2daa5cbbfdb2dd0d3e6dfc17c0.png)\n\n1. 创建一个用于RBD的存储池。\n```sh\n$ ceph osd pool create rbdpool\n```\n\n2. 使用RBD工具初始化这个存储池。\n```sh\n$ rbd pool init rbdpool\n```\n\n3. 创建可以访问这个RBD的用户。\n```sh\n# ceph auth get-or-create client.{ID} mon 'profile rbd' osd 'profile {profile name} [pool={pool-name}][, profile ...]' mgr 'profile rbd [pool={pool-name}]'\n$ ceph auth get-or-create client.testrbd mon 'profile rbd' osd 'profile rbd pool=rbdpool' mgr 'profile rbd'\n```\n\n4. 创建块设备镜像。在您开始将数据保存到它们之前，它们实际上并不使用任何物理存储。但是，它们确实具有您使用`--size`选项设置的最大容量。\n```sh\n# 创建名为testrbd的镜像，大小为1GB。指令格式：rbd create --size {megabytes} {pool-name}/{image-name}\n$ rbd create --size 1024 rbdpool/testrbd\n# 查看rbdpool存储池中有哪些RBD镜像\n$ rbd ls rbdpool\ntestrbd\n# 检索RBD镜像信息: rbd info {pool-name}/{image-name}\n$ rbd info rbdpool/testrbd\nrbd image 'testrbd':\n\tsize 1 GiB in 256 objects\n\torder 22 (4 MiB objects)\n\tsnapshot_count: 0\n\tid: 56bc9dc78ddfe\n\tblock_name_prefix: rbd_data.56bc9dc78ddfe\n\tformat: 2\n\tfeatures: layering, exclusive-lock, object-map, fast-diff, deep-flatten\n\top_features: \n\tflags: \n\tcreate_timestamp: Mon Feb  3 18:56:49 2020\n\taccess_timestamp: Mon Feb  3 18:56:49 2020\n\tmodify_timestamp: Mon Feb  3 18:56:49 2020\n# 调整块设备映像的大小为2GB\n$  rbd resize --size 2048 rbdpool/testrbd\n# 删除块设备的镜像\n# rbd rm {pool-name}/{image-name}\n# 例如: rbd rm foo\n```\n\n5. 使用librbd进行存储。为了演示方便，这里使用python编写一个简单例子。ceph的python库是在安装ceph时一并安装好的，不需要再执行`pip install`进行安装。\n\n```python\nimport rbd\nimport rados\n\ncluster = rados.Rados(conffile='/etc/ceph/ceph.conf')\ntry:\n    cluster.connect()\n    print(\"Cluster connect success\")\n    ioctx = cluster.open_ioctx('rbdpool')\n    try:\n        image = rbd.Image(ioctx, 'testrbd')\n        try:\n            # 块设备写入数据\n            print(\"Writing content...\")\n            data = 'foo' * 200\n            image.write(data, 0)\n            image.flush()\n            print(\"Write finished!\")\n\n            # 块设备读取数据\n            size = image.size()\n            print(\"Reading content...\")\n            i = 0\n            bufsize = 1024\n            buffer = bytes()\n            while i < size:\n                buffer = buffer + image.read(i, min(i + bufsize, size - 1))\n                i += size\n            print(\"%s\" % str(buffer))\n        finally:\n            image.close()\n    finally:\n        ioctx.close()\nfinally:\n    cluster.shutdown()\n```\n\n# Q&A\n## 删除pool报错 pool deletion is disabled\n修改mon节点的配置文件：\n```sh\n$ vi /etc/ceph/ceph.conf \n```\n添加如下配置内容:\n```\n[mon]\nmon allow pool delete = true\n```\n重启ceph-mon服务:\n```sh\n$ systemctl restart ceph-mon.target\n```\n执行删除pool命令:\n```sh\n$ ceph osd pool delete ecpool ecpool --yes-i-really-really-mean-it\npool 'ecpool' removed\n```\n\n## 100.000% pgs not active undersized+peered\n按照官方文档的说法是：\n```\nundersized\nThe placement group has fewer copies than the configured pool replication level.\n```\n意思是这个PG的实际副本数少于配置的副本数。所以这个警告原因是有某个pool的size值大于Ceph OSD集群的节点数了，这样使得Ceph找不到更多的节点数来备份这个PG，PG就会变成undersized状态。\n\n前面的 100.000% 是因为我当时的集群只有一个pool而且就这个pool的size值配错了，所以是100%的PG数都变成undersized状态。这个百分比可能不是100%，实际情况下需要查询各个pool配置情况来找出这个错误配置的pool。\n\n## no active mgr\n集群没有开启ceph-mgr组件，请参照\"添加ceph-mgr\"章节。\n\n## too few PGs per OSD ( n < 30 )\n出现这个警告信息的原因是所有池的PG总数除于OSD数得到的值小于30导致的，可以通过`ceph osd pool set $POOL_NAME pg_num $PG_NUM`命令修改各个池的PG数，使得总PG数满足如下公式即可：\n\nTotal PGs = ((Total_number_of_OSD * 30) / max_replication_count) / pool_count \n\n结算的结果往上取靠近2的N次方的值。","slug":"ceph-1","published":1,"date":"2020-02-04T02:36:09.436Z","updated":"2020-02-04T02:36:09.436Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck679uifq0000a0md3wne0s2t","content":"<p>本文主要介绍Ceph存储集群的部署方式，以及三种存储类型服务的构建及简单使用，不对内部原理做深入介绍，过后会编写另外的文章聊这个话题。本文属于个人学习笔记，如有错误欢迎指正，部署期间踩到的坑写在了Q&amp;A。</p>\n<a id=\"more\"></a>\n\n<h1 id=\"组件介绍\"><a href=\"#组件介绍\" class=\"headerlink\" title=\"组件介绍\"></a>组件介绍</h1><p>一个Ceph存储群集至少需要一个监控器(ceph-mon)，管理器(ceph-mgr)和对象存储守护程序(ceph-osd)。运行Ceph文件系统客户端时，还需要元数据服务器(ceph-mds)。</p>\n<ul>\n<li>管理器(ceph-mon): 维护集群状态的映射，包括监视器映射，管理器映射，OSD映射，MDS映射和CRUSH映射。这些映射是Ceph守护程序相互协调所需的关键群集状态。监视器还负责管理守护程序和客户端之间的身份验证。通常至少需要三个监视器才能实现冗余和高可用性。</li>\n<li>管理器(ceph-mgr): 负责跟踪运行时指标和Ceph集群的当前状态，包括存储利用率，当前性能指标和系统负载。Ceph Manager守护程序基于python模块进行管理并且负责公开Ceph集群信息（包括基于Web的Ceph Dashboard和 REST API）。通常，至少需要两个管理器才能实现高可用性。</li>\n<li>对象存储守护程序(ceph-osd): 处理数据复制，恢复，重新平衡，并通过检查其他Ceph OSD守护程序的心跳来向Ceph监视器和管理器提供一些监视信息。通常至少需要3个Ceph OSD才能实现冗余和高可用性。</li>\n<li>元数据服务器(ceph-mds): 代表Ceph文件系统存储元数据（即Ceph块设备和Ceph对象存储不使用MDS）。Ceph的元数据服务器允许POSIX文件系统的用户来执行基本的命令（如 ls，find等等）。</li>\n</ul>\n<p>Ceph将数据作为对象存储在逻辑存储池中。Ceph 使用 CRUSH算法计算一个对象应该包含在哪个Placement group，并进一步计算这个Placement group应存储在哪个Ceph OSD守护程序。CRUSH算法使Ceph存储集群能够动态扩展，重新平衡和恢复。下面是Ceph文件对象存储流程图：</p>\n<p><img src=\"../../../../images/ceph.png\" alt=\"Ceph文件对象存储流程图\"></p>\n<h1 id=\"预安装\"><a href=\"#预安装\" class=\"headerlink\" title=\"预安装\"></a>预安装</h1><h2 id=\"添加密钥\"><a href=\"#添加密钥\" class=\"headerlink\" title=\"添加密钥\"></a>添加密钥</h2><h3 id=\"APT\"><a href=\"#APT\" class=\"headerlink\" title=\"APT\"></a>APT</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -q -O- <span class=\"string\">'https://download.ceph.com/keys/release.asc'</span> | sudo apt-key add -</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"RPM\"><a href=\"#RPM\" class=\"headerlink\" title=\"RPM\"></a>RPM</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo rpm --import <span class=\"string\">'https://download.ceph.com/keys/release.asc'</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"添加Ceph源\"><a href=\"#添加Ceph源\" class=\"headerlink\" title=\"添加Ceph源\"></a>添加Ceph源</h2><h3 id=\"Ubuntu或Debian\"><a href=\"#Ubuntu或Debian\" class=\"headerlink\" title=\"Ubuntu或Debian\"></a>Ubuntu或Debian</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-add-repository <span class=\"string\">'deb https://download.ceph.com/debian-&#123;ceph-release&#125;/ $(lsb_release -sc) main'</span></span><br><span class=\"line\">sudo apt update</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"RHEL或CentOS\"><a href=\"#RHEL或CentOS\" class=\"headerlink\" title=\"RHEL或CentOS\"></a>RHEL或CentOS</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 加入Ceph yum源文件</span></span><br><span class=\"line\">$ cat  /etc/yum.repos.d/ceph.repo</span><br><span class=\"line\">[ceph]</span><br><span class=\"line\">name=Ceph packages <span class=\"keyword\">for</span> <span class=\"variable\">$basearch</span></span><br><span class=\"line\">baseurl=https://download.ceph.com/rpm-&#123;ceph-release&#125;/&#123;distro&#125;/<span class=\"variable\">$basearch</span></span><br><span class=\"line\">enabled=1</span><br><span class=\"line\">priority=2</span><br><span class=\"line\">gpgcheck=1</span><br><span class=\"line\">gpgkey=https://download.ceph.com/keys/release.asc</span><br><span class=\"line\"></span><br><span class=\"line\">[ceph-noarch]</span><br><span class=\"line\">name=Ceph noarch packages</span><br><span class=\"line\">baseurl=https://download.ceph.com/rpm-&#123;ceph-release&#125;/&#123;distro&#125;/noarch</span><br><span class=\"line\">enabled=1</span><br><span class=\"line\">priority=2</span><br><span class=\"line\">gpgcheck=1</span><br><span class=\"line\">gpgkey=https://download.ceph.com/keys/release.asc</span><br><span class=\"line\"></span><br><span class=\"line\">[ceph-source]</span><br><span class=\"line\">name=Ceph <span class=\"built_in\">source</span> packages</span><br><span class=\"line\">baseurl=https://download.ceph.com/rpm-&#123;ceph-release&#125;/&#123;distro&#125;/SRPMS</span><br><span class=\"line\">enabled=0</span><br><span class=\"line\">priority=2</span><br><span class=\"line\">gpgcheck=1</span><br><span class=\"line\">gpgkey=https://download.ceph.com/keys/release.asc</span><br><span class=\"line\"></span><br><span class=\"line\">$ yum clean all</span><br><span class=\"line\">$ yum makecache</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"时间同步\"><a href=\"#时间同步\" class=\"headerlink\" title=\"时间同步\"></a>时间同步</h2><p>需要确保Ceph集群中所有节点的时间同步，使用 ntp 工具做时间同步。<br>CentOS / RHEL:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install ntp ntpdate ntp-doc</span><br></pre></td></tr></table></figure>\n\n<p>Debian / Ubuntu:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install ntpsec</span><br></pre></td></tr></table></figure>\n\n<p>或:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install chrony</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"安装SSH服务\"><a href=\"#安装SSH服务\" class=\"headerlink\" title=\"安装SSH服务\"></a>安装SSH服务</h2><p>Ceph集群部署是在总控机器上通过SSH连接其它集群节点进行安装，所以需要保证所有Ceph集群节点都开启了SSH服务。</p>\n<p>CentOS / RHEL:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install openssh-server</span><br></pre></td></tr></table></figure>\n\n<p>Debian / Ubuntu:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install openssh-server</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建Ceph部署用户\"><a href=\"#创建Ceph部署用户\" class=\"headerlink\" title=\"创建Ceph部署用户\"></a>创建Ceph部署用户</h2><p>为了安全起见不建议使用root用户进行部署，创建一个Ceph部署专用的用户更为合理，而且需要保证部署机可通过“SSH免密登录”的方式使用Ceph部署用户登录到集群中的各个节点。</p>\n<p>创建用户:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh user@ceph-server</span><br><span class=\"line\">sudo useradd -d /home/&#123;username&#125; -m &#123;username&#125;</span><br><span class=\"line\">sudo passwd &#123;username&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要保证Ceph部署用户是一个 sudoer:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"&#123;username&#125; ALL = (root) NOPASSWD:ALL\"</span> | sudo tee /etc/sudoers.d/&#123;username&#125;</span><br><span class=\"line\">sudo chmod 0440 /etc/sudoers.d/&#123;username&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"免密登录\"><a href=\"#免密登录\" class=\"headerlink\" title=\"免密登录\"></a>免密登录</h2><p>在主节点上执行下列指令实现免密登录：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-copy-id ceph@&#123;host&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"安装ceph-deploy\"><a href=\"#安装ceph-deploy\" class=\"headerlink\" title=\"安装ceph-deploy\"></a>安装ceph-deploy</h2><h3 id=\"Ubuntu或Debian-1\"><a href=\"#Ubuntu或Debian-1\" class=\"headerlink\" title=\"Ubuntu或Debian\"></a>Ubuntu或Debian</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ apt-get install ceph-deploy</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"RHEL或CentOS-1\"><a href=\"#RHEL或CentOS-1\" class=\"headerlink\" title=\"RHEL或CentOS\"></a>RHEL或CentOS</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yum install ceph-deploy</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"部署Ceph集群\"><a href=\"#部署Ceph集群\" class=\"headerlink\" title=\"部署Ceph集群\"></a>部署Ceph集群</h1><p> 官方提供了三种部署Ceph集群的方法，分别是：ceph-deploy, cephadm, 手动安装。这里只介绍最大众化的安装方式： ceph-deploy。</p>\n<p> 演示案例采用3节点集群部署，主机名与IP映射如下：</p>\n<ul>\n<li>node1: 192.168.56.101</li>\n<li>node2: 192.168.56.102</li>\n<li>node3: 192.168.56.103</li>\n</ul>\n<p>以 node1 作为部署主节点，如没有特殊说明下面给出的指令都运行在node1节点上。</p>\n<h2 id=\"部署-ceph-mon\"><a href=\"#部署-ceph-mon\" class=\"headerlink\" title=\"部署 ceph-mon\"></a>部署 ceph-mon</h2><ol>\n<li>创建 Ceph 配置文件:<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 计划三个节点都部署ceph-mon服务，格式: ceph-deploy new &#123;initial-monitor-node(s)&#125;</span></span><br><span class=\"line\">$ ceph-deploy new node1 node2 node3</span><br><span class=\"line\"><span class=\"comment\"># 创建成功后会在当前目录生成这三个文件，其中ceph.conf是集群配置文件，ceph.mon.keyring是ceph-mon服务的密钥</span></span><br><span class=\"line\">$ ls</span><br><span class=\"line\">ceph.conf ceph-deploy-ceph.log  ceph.mon.keyring</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>一个Ceph集群中至少拥有一个ceph-mon，为了实现高可用，Ceph集群可以部署多个ceph-mon服务，当集群中某一个ceph-mon服务挂掉后也不会影响整个集群使用。Ceph使用Paxos算法，该算法需要大多数ceph-mon（即，大于N / 2，其中N是ceph-mon的数量）才能形成仲裁。监视器的奇数往往会更好，尽管这不是必需的。</p>\n<p>这里只是配置初始的ceph-mon节点主机，可以在后续集群正常使用过程中添加新的ceph-mon。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 后续添加ceph-mon的指令格式: ceph-deploy mon add &#123;ceph-nodes&#125;</span></span><br><span class=\"line\">$ ceph-deploy mon add node4 node5</span><br></pre></td></tr></table></figure>\n\n<p>一旦添加了新的Ceph监视器，Ceph将开始同步监视器并形成仲裁。您可以通过执行以下操作检查仲裁状态：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ceph quorum_status --format json-pretty</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><p>如果你的集群节点存在多个网卡，需要为ceph.conf文件添加Ceph集群通信网段的配置。演示网络是192.168.56.0/24网段，所以添加配置如下：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># public network = &#123;ip-address&#125;/&#123;bits&#125;</span></span><br><span class=\"line\">public network = 192.168.56.0/24</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果采用了IPv6，还需要在ceph.conf中添加如下配置:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ms <span class=\"built_in\">bind</span> ipv6 = <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>为每个节点安装 Ceph 依赖库。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ceph-deploy install --no-adjust-repos node1 node2 node3</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>这个指令会通过SSH远程到 node1,node2,node3 三个节点分别执行 <code>yum install</code> 或 <code>apt install</code> 安装，因为前面预处理章节已经配置了ceph的yum源或apt源，<code>--no-adjust-repos</code> 参数表明不修改节点的yum源或apt源，直接执行 <code>yum install</code> 或 <code>apt install</code> 指令下载需要的依赖库，不添加此参数的话可能会造成下载的库版本与我们预期的不一致问题。</p>\n<ol start=\"5\">\n<li>初始化ceph-mon并创建组件密钥。<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ceph-deploy mon create-initial</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>一旦指令执行成功，在当前目录下将会新增一些keyring文件：</p>\n<ul>\n<li>ceph.client.admin.keyring</li>\n<li>ceph.bootstrap-mgr.keyring</li>\n<li>ceph.bootstrap-osd.keyring</li>\n<li>ceph.bootstrap-mds.keyring</li>\n<li>ceph.bootstrap-rgw.keyring</li>\n<li>ceph.bootstrap-rbd.keyring</li>\n<li>ceph.bootstrap-rbd-mirror.keyring</li>\n</ul>\n<ol start=\"6\">\n<li>使用<code>ceph-deploy</code>复制配置文件以及admin用户的密钥到Ceph集群的其它节点，这样做其它节点也可以通过命令行对Ceph进行操作。<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 可以指定多个节点拥有ceph集群的管理权限，格式：ceph-deploy admin &#123;ceph-node(s)&#125;</span></span><br><span class=\"line\">$ ceph-deploy admin node1</span><br><span class=\"line\"><span class=\"comment\"># 确保当前用户拥有ceph.client.admin.keyring文件的读权限</span></span><br><span class=\"line\">$ sudo chown &#123;user&#125;:&#123;group&#125; /etc/ceph/ceph.client.admin.keyring</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>指令执行完毕后，在指定节点的 /etc/ceph 目录下会新增 ceph.client.admin.keyring 密钥文件，ceph集群管理命令需要通过这个密钥认证才能执行。</p>\n<p>node1上执行ceph命令，确认admin密钥正确:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ceph@node1 ~]$ ceph -s</span><br><span class=\"line\">  cluster:</span><br><span class=\"line\">    id:     d809fd13-1fd6-4591-bd2b-5d4eabbadaba</span><br><span class=\"line\">    health: HEALTH_WARN</span><br><span class=\"line\">            no active mgr</span><br><span class=\"line\">            OSD count 0 &lt; osd_pool_default_size 3</span><br><span class=\"line\"> </span><br><span class=\"line\">  services:</span><br><span class=\"line\">    mon: 3 daemons, quorum node1,node2,node3 (age 11m)</span><br><span class=\"line\">    mgr: no daemons active (since 63s)</span><br><span class=\"line\">    osd: 0 osds: 0 up, 0 <span class=\"keyword\">in</span></span><br><span class=\"line\"> </span><br><span class=\"line\">  data:</span><br><span class=\"line\">    pools:   0 pools, 0 pgs</span><br><span class=\"line\">    objects: 0 objects, 0 B</span><br><span class=\"line\">    usage:   0 B used, 0 B / 0 B avail</span><br><span class=\"line\">    pgs:</span><br></pre></td></tr></table></figure>\n\n<p>在没有赋予管理权限的节点上尝试执行Ceph管理指令将会报错：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在 node2或node3 上执行</span></span><br><span class=\"line\">[ceph@node2 ~]$ ceph -s</span><br><span class=\"line\">[errno 2] error connecting to the cluster</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"部署-ceph-mgr\"><a href=\"#部署-ceph-mgr\" class=\"headerlink\" title=\"部署 ceph-mgr\"></a>部署 ceph-mgr</h2><p>在 luminous 或更新的版本需要这一步。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ceph-deploy mgr create node1</span><br><span class=\"line\"><span class=\"comment\"># 看到Ceph集群状态中的 no active mgr 警告信息已经消失</span></span><br><span class=\"line\">$ ceph -s</span><br><span class=\"line\">  cluster:</span><br><span class=\"line\">    id:     d809fd13-1fd6-4591-bd2b-5d4eabbadaba</span><br><span class=\"line\">    health: HEALTH_WARN</span><br><span class=\"line\">            OSD count 0 &lt; osd_pool_default_size 3</span><br><span class=\"line\"> </span><br><span class=\"line\">  services:</span><br><span class=\"line\">    mon: 3 daemons, quorum node1,node2,node3 (age 14m)</span><br><span class=\"line\">    mgr: node1(active, since 1.52953s)</span><br><span class=\"line\">    osd: 0 osds: 0 up, 0 <span class=\"keyword\">in</span></span><br><span class=\"line\"> </span><br><span class=\"line\">  data:</span><br><span class=\"line\">    pools:   0 pools, 0 pgs</span><br><span class=\"line\">    objects: 0 objects, 0 B</span><br><span class=\"line\">    usage:   0 B used, 0 B / 0 B avail</span><br><span class=\"line\">    pgs:</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"添加OSD\"><a href=\"#添加OSD\" class=\"headerlink\" title=\"添加OSD\"></a>添加OSD</h2><p>OSD是Ceph集群的基础存储单元，需要指定一个裸盘、主分区或逻辑分区作为一个OSD服务。</p>\n<p>笔者当前演示的环境是用3台虚拟机并各创建一个虚拟裸盘实现，3个节点均挂载这个虚拟磁盘在/dev/sdb上，大小为30G。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ lsblk</span><br><span class=\"line\">NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class=\"line\">sda               8:0    0   10G  0 disk </span><br><span class=\"line\">├─sda1            8:1    0    1G  0 part /boot</span><br><span class=\"line\">└─sda2            8:2    0    9G  0 part </span><br><span class=\"line\">  ├─centos-root 253:0    0    8G  0 lvm  /</span><br><span class=\"line\">  └─centos-swap 253:1    0    1G  0 lvm  [SWAP]</span><br><span class=\"line\">sdb               8:16   0   30G  0 disk </span><br><span class=\"line\">sr0              11:0    1 1024M  0 rom</span><br></pre></td></tr></table></figure>\n\n<p>使用<code>ceph-deploy</code>添加OSD指令如下：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 格式: ceph-deploy osd create --data &#123;device&#125; &#123;ceph-node&#125;</span></span><br><span class=\"line\"><span class=\"comment\"># 如果你使用的是逻辑分区，参数格式为 --data vg_group/lv_name</span></span><br><span class=\"line\">$ ceph-deploy osd create --data /dev/sdb node1</span><br><span class=\"line\">$ ceph-deploy osd create --data /dev/sdb node2</span><br><span class=\"line\">$ ceph-deploy osd create --data /dev/sdb node3</span><br></pre></td></tr></table></figure>\n\n<p>这里可能因Ceph版本不同细节有些许区别，若不幸遇到报错需要根据日志自己解决。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 部署完毕后再次查看集群状态可以看到3个OSD已经启动</span></span><br><span class=\"line\">$ ceph -s</span><br><span class=\"line\">  cluster:</span><br><span class=\"line\">    id:     d809fd13-1fd6-4591-bd2b-5d4eabbadaba</span><br><span class=\"line\">    health: HEALTH_OK</span><br><span class=\"line\"> </span><br><span class=\"line\">  services:</span><br><span class=\"line\">    mon: 3 daemons, quorum node1,node2,node3 (age 34m)</span><br><span class=\"line\">    mgr: node1(active, since 19m)</span><br><span class=\"line\">    osd: 3 osds: 3 up (since 5s), 3 <span class=\"keyword\">in</span> (since 5s)</span><br><span class=\"line\"> </span><br><span class=\"line\">  data:</span><br><span class=\"line\">    pools:   0 pools, 0 pgs</span><br><span class=\"line\">    objects: 0 objects, 0 B</span><br><span class=\"line\">    usage:   3.0 GiB used, 84 GiB / 87 GiB avail</span><br><span class=\"line\">    pgs:</span><br><span class=\"line\"><span class=\"comment\"># 查看OSD树状结构</span></span><br><span class=\"line\">$ ceph osd tree</span><br><span class=\"line\">ID CLASS WEIGHT  TYPE NAME      STATUS REWEIGHT PRI-AFF </span><br><span class=\"line\">-1       0.08487 root default                           </span><br><span class=\"line\">-3       0.02829     host node1                         </span><br><span class=\"line\"> 0   hdd 0.02829         osd.0      up  1.00000 1.00000 </span><br><span class=\"line\">-5       0.02829     host node2                         </span><br><span class=\"line\"> 1   hdd 0.02829         osd.1      up  1.00000 1.00000 </span><br><span class=\"line\">-7       0.02829     host node3                         </span><br><span class=\"line\"> 2   hdd 0.02829         osd.2      up  1.00000 1.00000</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"删除OSD\"><a href=\"#删除OSD\" class=\"headerlink\" title=\"删除OSD\"></a>删除OSD</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 从crush中移除节点</span></span><br><span class=\"line\">$ ceph osd crush remove osd.<span class=\"variable\">$ID</span></span><br><span class=\"line\"><span class=\"comment\"># 将节点服务停止</span></span><br><span class=\"line\">$ ceph osd down osd.<span class=\"variable\">$ID</span></span><br><span class=\"line\"><span class=\"comment\"># 删除节点</span></span><br><span class=\"line\">$ ceph osd rm osd.<span class=\"variable\">$ID</span></span><br><span class=\"line\"><span class=\"comment\"># 删除节点认证</span></span><br><span class=\"line\">$ ceph auth del osd.<span class=\"variable\">$ID</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"添加MDS\"><a href=\"#添加MDS\" class=\"headerlink\" title=\"添加MDS\"></a>添加MDS</h2><p>ceph-mds是CephFS必要的服务，如果可以采用部署<a href=\"https://docs.ceph.com/docs/master/mgr/orchestrator_cli/\" target=\"_blank\" rel=\"noopener\">Orchestrator</a>自动为您的文件系统创建并配置MDS（请参阅 <a href=\"https://docs.ceph.com/docs/master/mgr/orchestrator_cli/#current-implementation-status\" target=\"_blank\" rel=\"noopener\">Orchestrator部署表</a>）。否则，参照下列方法手动部署mds。</p>\n<p>想要启动CephFS前必须启动ceph-mds服务，执行下列脚本可部署mds服务（需要先配置环境变量）：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建mds存储目录。</span></span><br><span class=\"line\">$ mkdir -p /var/lib/ceph/mds/<span class=\"variable\">$CLUSTER_NAME</span>-<span class=\"variable\">$MDS_ID</span></span><br><span class=\"line\"><span class=\"comment\"># 部署ceph-mds服务，命令格式: ceph-deploy mds create &#123;ceph-node&#125;</span></span><br><span class=\"line\">$ ceph-deploy mds create node1</span><br><span class=\"line\"><span class=\"comment\"># 检测mds是否启动成功（\"1 up:standby\" 表示有一个mds节点启动成功）</span></span><br><span class=\"line\">$ ceph mds <span class=\"built_in\">stat</span></span><br><span class=\"line\"> 1 up:standby</span><br></pre></td></tr></table></figure>\n\n<p>至此Ceph集群基础组件部署完毕，可以根据需要往下部署不同存储类型的服务。</p>\n<h1 id=\"三种Ceph存储类型的部署\"><a href=\"#三种Ceph存储类型的部署\" class=\"headerlink\" title=\"三种Ceph存储类型的部署\"></a>三种Ceph存储类型的部署</h1><p>CephFS致力于为各种应用程序提供最新，多用途，高可用性和高性能的文件存储。提供了三种存储类型：</p>\n<ul>\n<li>CephFS</li>\n<li>Ceph Object Storage</li>\n<li>CephRBD</li>\n</ul>\n<p>避免篇幅过长，本文只介绍最简单的部署及使用方式，过后会有其它文章详述各种存储类型的运行机制。</p>\n<h2 id=\"CephFS\"><a href=\"#CephFS\" class=\"headerlink\" title=\"CephFS\"></a>CephFS</h2><h3 id=\"服务端部署\"><a href=\"#服务端部署\" class=\"headerlink\" title=\"服务端部署\"></a>服务端部署</h3><p>CephFS 是 Ceph File System 的简称，它是在Ceph的分布式对象存储RADOS之上构建的POSIX兼容文件系统。<br>文件元数据与文件数据存储在单独的RADOS池中，并通过可调整大小的元数据服务器或MDS集群提供服务，该集群是可拓展的以支持高吞吐量的元数据工作负载。</p>\n<p>文件系统的客户端可以直接访问RADOS以读取和写入文件数据块，因此，工作负载可能会随着基础RADOS对象存储的数量线性扩展，也就是说，没有网关或代理为客户端中介数据I / O。</p>\n<p>通过MDS集群协调对数据的访问，每个MDS都会将对元数据的变化汇总到日志以对RADOS进行一系列有效写入。MDS不会在本地存储任何元数据状态。此模型允许在POSIX文件系统的上下文中客户端之间进行连贯且快速的协作。</p>\n<p><img src=\"https://docs.ceph.com/docs/master/_images/cephfs-architecture.svg\" alt=\"CephFS架构图\"></p>\n<p>创建cephfs可以直接使用如下指令:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建名为 testfs 的文件系统资源</span></span><br><span class=\"line\">$ ceph fs volume create testfs</span><br><span class=\"line\"><span class=\"comment\"># 查看已有文件系统资源</span></span><br><span class=\"line\">$ ceph fs ls</span><br><span class=\"line\">name: testfs, metadata pool: cephfs.testfs.meta, data pools: [cephfs.testfs.data ]</span><br><span class=\"line\"><span class=\"comment\"># ceph-mds 管理了这个FS</span></span><br><span class=\"line\">$ ceph mds <span class=\"built_in\">stat</span></span><br><span class=\"line\">testfs:1 &#123;0=node1=up:active&#125;</span><br><span class=\"line\"><span class=\"comment\"># 查看集群状态</span></span><br><span class=\"line\">$ ceph -s</span><br><span class=\"line\">  cluster:</span><br><span class=\"line\">    id:     908baedd-c2d1-4977-8aa8-dea83b31d271</span><br><span class=\"line\">    health: HEALTH_OK</span><br><span class=\"line\"> </span><br><span class=\"line\">  services:</span><br><span class=\"line\">    mon: 1 daemons, quorum node1 (age 42m)</span><br><span class=\"line\">    mgr: node1(active, since 50m)</span><br><span class=\"line\">    mds: testfs:1 &#123;0=node1=up:active&#125;</span><br><span class=\"line\">    osd: 3 osds: 3 up (since 25m), 3 <span class=\"keyword\">in</span> (since 51m)</span><br><span class=\"line\"> </span><br><span class=\"line\">  data:</span><br><span class=\"line\">    pools:   2 pools, 96 pgs</span><br><span class=\"line\">    objects: 24 objects, 3.3 KiB</span><br><span class=\"line\">    usage:   3.0 GiB used, 27 GiB / 30 GiB avail</span><br><span class=\"line\">    pgs:     96 active+clean</span><br></pre></td></tr></table></figure>\n\n<p>该指令将自动创建一个元数据存储池（<code>cephfs.&lt;FSNAME&gt;.meta</code>）与一个内容存储池（<code>cephfs.&lt;FSNAME&gt;.data</code>）。</p>\n<p>若不幸出现了警告内容为<code>too few PGs per OSD (n &lt; min 30)</code>，请参考Q&amp;A章节获知解决方案。</p>\n<h3 id=\"客户端挂载\"><a href=\"#客户端挂载\" class=\"headerlink\" title=\"客户端挂载\"></a>客户端挂载</h3><p>CephFS挂载有两种方法：使用Linux内核驱动或是使用ceph-fuse工具。实际上比较常用的是ceph-fuse工具方法，所以本文只介绍这种挂载方式。</p>\n<ol>\n<li><p>需要先安装 ceph-fuse</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yum install -y ceph-fuse</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在客户机生成服务端路径相关配置文件。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在客户机上执行</span></span><br><span class=\"line\">$ mkdir -p -m 755 /etc/ceph</span><br><span class=\"line\">$ ssh &#123;user&#125;@&#123;mon-host&#125; <span class=\"string\">\"sudo ceph config generate-minimal-conf\"</span> | sudo tee /etc/ceph/ceph.conf</span><br><span class=\"line\"><span class=\"comment\"># 确保文件可以被其它用户访问到</span></span><br><span class=\"line\">$ chmod 644 /etc/ceph/ceph.conf</span><br><span class=\"line\"><span class=\"comment\"># 文件中记录了ceph-mon的地址以及集群ID</span></span><br><span class=\"line\">$ cat /etc/ceph/ceph.conf</span><br><span class=\"line\">[global]</span><br><span class=\"line\">fsid = 908baedd-c2d1-4977-8aa8-dea83b31d271</span><br><span class=\"line\">mon_host = [v2:192.168.56.101:3300/0,v1:192.168.56.101:6789/0]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>因为服务端采用了CephX认证方式，需要为客户端机器生成一份对应的密钥文件。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建一个foo用户授权名为 testfs 的CephFS资源，并且拥有根路径下( / )的读写权限( rw )</span></span><br><span class=\"line\">$ ssh &#123;user&#125;@&#123;mon-host&#125; <span class=\"string\">\"sudo ceph fs authorize testfs client.foo / rw\"</span> | sudo tee /etc/ceph/ceph.client.foo.keyring</span><br><span class=\"line\">$ chmod 600 /etc/ceph/ceph.client.foo.keyring</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>挂载CephFS到指定客户机目录</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mkdir /mnt/mycephfs</span><br><span class=\"line\">$ sudo ceph-fuse --id foo /mnt/mycephfs</span><br><span class=\"line\">ceph-fuse[4131]: starting ceph client</span><br><span class=\"line\">2020-02-02 05:21:21.476 7f5f9b493e00 -1 init, newargv = 0x561161876670 newargc=7</span><br><span class=\"line\">ceph-fuse[4131]: starting fuse</span><br><span class=\"line\"><span class=\"comment\"># 确认目录挂载成功</span></span><br><span class=\"line\">$ df -h | grep ceph-fuse</span><br><span class=\"line\">ceph-fuse                 26G     0   26G    0% /mnt/mycephfs</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>撤销挂载卷</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ umount /mnt/mycephfs</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>执行完上述4步后就算是挂载完毕了，但是客户机重启后挂载卷将会消失需要重新执行<code>ceph-fuse</code>指令挂载回来，可以修改<code>/etc/fstab</code>文件做到开机自动挂载，需要在<code>/etc/fstab</code>文件中添加如下配置：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#DEVICE PATH       TYPE      OPTIONS</span></span><br><span class=\"line\">none    /mnt/mycephfs  fuse.ceph ceph.id=&#123;user-ID&#125;[,ceph.conf=&#123;path/to/conf.conf&#125;],_netdev,defaults  0 0</span><br></pre></td></tr></table></figure>\n\n<p>例子:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">none    /mnt/mycephfs  fuse.ceph ceph.id=foo,_netdev,defaults  0 0</span><br><span class=\"line\"><span class=\"comment\"># 面向多个Ceph集群时，需要手动指定特定集群的配置文件（默认使用 /etc/ceph/ceph.conf）</span></span><br><span class=\"line\">none    /mnt/mycephfs  fuse.ceph ceph.id=foo,ceph.conf=/etc/ceph/foo.conf,_netdev,defaults  0 0</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Ceph-Object-Storage\"><a href=\"#Ceph-Object-Storage\" class=\"headerlink\" title=\"Ceph Object Storage\"></a>Ceph Object Storage</h2><p>Ceph对象网关是一个对象存储接口，建立在该对象之上， librados为应用程序提供了通往Ceph存储集群的RESTful网关。</p>\n<p>Ceph对象存储支持两个接口：</p>\n<ul>\n<li>与S3兼容：为对象存储功能提供与Amazon S3 RESTful API的大部分子集兼容的接口。</li>\n<li>兼容Swift：为对象存储功能提供与OpenStack Swift API的大部分子集兼容的接口。</li>\n</ul>\n<p>S3和Swift API共享一个公共的名称空间，因此您可以使用一个API编写数据，而使用另一个API检索数据。</p>\n<p><img src=\"https://docs.ceph.com/docs/master/_images/ditaa-50d12451eb76c5c72c4574b08f0320b39a42e5f1.png\" alt=\"Ceph Object Storage 架构图\"></p>\n<ol>\n<li><p>安装Rados Gateway的依赖库。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ceph-deploy install --rgw &lt;gateway-node1&gt; [&lt;gateway-node2&gt; ...]</span></span><br><span class=\"line\">$ ceph-deploy install --rgw node1</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建Rados网关实例。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ceph-deploy rgw create &lt;gateway-node1&gt;</span></span><br><span class=\"line\">$ ceph-deploy rgw create node1</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>默认Rados网关占用7480端口，可以使用浏览器访问<code>http://node1:7480/</code>得到如下响应，说明网关部署已完毕：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ListAllMyBucketsResult</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://s3.amazonaws.com/doc/2006-03-01/\"</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">Owner</span>&gt;</span></span><br><span class=\"line\">               <span class=\"tag\">&lt;<span class=\"name\">ID</span>&gt;</span>anonymous<span class=\"tag\">&lt;/<span class=\"name\">ID</span>&gt;</span></span><br><span class=\"line\">               <span class=\"tag\">&lt;<span class=\"name\">DisplayName</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">DisplayName</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;/<span class=\"name\">Owner</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">Buckets</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;/<span class=\"name\">Buckets</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ListAllMyBucketsResult</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>[可选] 修改Rados网关端口。修改<code>ceph.conf</code>文件添加如下内容:<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[client.rgw.node1]  <span class=\"comment\"># node1对应上面第2步部署的节点</span></span><br><span class=\"line\">rgw_frontends = <span class=\"string\">\"civetweb port=80\"</span>  <span class=\"comment\"># 修改为80端口</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>然后使用ceph-deploy更新相关节点的<code>ceph.conf</code>文件:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ceph-deploy --overwrite-conf config push &lt;gateway-node&gt; [&lt;other-nodes&gt;]</span></span><br><span class=\"line\">$ ceph-deploy --overwrite-conf config push node1</span><br><span class=\"line\"><span class=\"comment\"># 重启rados网关服务才能使配置生效</span></span><br><span class=\"line\">$ sudo systemctl restart ceph-radosgw.service</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>[可选] 使Rados网关支持SSL协议。需要先生成证书（略），然后修改<code>ceph.conf</code>文件添加如下配置：<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[client.rgw.node1]</span><br><span class=\"line\">rgw_frontends = civetweb port=443s ssl_certificate=/etc/ceph/private/keyandcert.pem <span class=\"comment\"># ssl_certificate指定证书路径</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>也可以同时开放HTTP协议端口与HTTPS协议端口，配置修改如下：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[client.rgw.node1]</span><br><span class=\"line\">rgw_frontends = civetweb port=80+443s ssl_certificate=/etc/ceph/private/keyandcert.pem</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>添加用户。Ceph Object Storage 的 Rados 网关支持 S3 与 Swift 两种 API，但它们的用户权限管理有所不同，所以需要根据需要生成不同类型的用户。</li>\n</ol>\n<ul>\n<li>添加S3用户: <code>sudo radosgw-admin user create --uid=&quot;testuser&quot; --display-name=&quot;First User&quot;</code></li>\n<li>添加Swift用户: <code>sudo radosgw-admin subuser create --uid=testuser --subuser=testuser:swift --access=full</code></li>\n</ul>\n<p>到此Rados网关基础部署算是完成了，测试网关上传下载功能请参考: <a href=\"https://docs.ceph.com/docs/master/install/install-ceph-gateway/#access-verification。\" target=\"_blank\" rel=\"noopener\">https://docs.ceph.com/docs/master/install/install-ceph-gateway/#access-verification。</a></p>\n<h2 id=\"CephRBD\"><a href=\"#CephRBD\" class=\"headerlink\" title=\"CephRBD\"></a>CephRBD</h2><p>块是字节序列（例如，一个512字节的数据块）。基于块的存储接口是使用旋转介质（例如硬盘，CD，软盘甚至传统的9轨磁带）存储数据的最常用方法。块设备接口无处不在使虚拟块设备成为与海量数据存储系统（如Ceph）进行交互的理想选择。</p>\n<p>Ceph块设备经过精简配置，可调整大小，并在Ceph集群中的多个OSD上存储条带化数据。Ceph块设备利用了 RADOS功能，例如快照，复制和一致性。Ceph的 RADOS块设备（RBD）使用内核模块或librbd库与OSD进行交互。</p>\n<p><img src=\"https://docs.ceph.com/docs/master/_images/ditaa-dc9f80d771b55f2daa5cbbfdb2dd0d3e6dfc17c0.png\" alt=\"Ceph块设备架构图\"></p>\n<ol>\n<li><p>创建一个用于RBD的存储池。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ceph osd pool create rbdpool</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用RBD工具初始化这个存储池。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rbd pool init rbdpool</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建可以访问这个RBD的用户。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ceph auth get-or-create client.&#123;ID&#125; mon 'profile rbd' osd 'profile &#123;profile name&#125; [pool=&#123;pool-name&#125;][, profile ...]' mgr 'profile rbd [pool=&#123;pool-name&#125;]'</span></span><br><span class=\"line\">$ ceph auth get-or-create client.testrbd mon <span class=\"string\">'profile rbd'</span> osd <span class=\"string\">'profile rbd pool=rbdpool'</span> mgr <span class=\"string\">'profile rbd'</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建块设备镜像。在您开始将数据保存到它们之前，它们实际上并不使用任何物理存储。但是，它们确实具有您使用<code>--size</code>选项设置的最大容量。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建名为testrbd的镜像，大小为1GB。指令格式：rbd create --size &#123;megabytes&#125; &#123;pool-name&#125;/&#123;image-name&#125;</span></span><br><span class=\"line\">$ rbd create --size 1024 rbdpool/testrbd</span><br><span class=\"line\"><span class=\"comment\"># 查看rbdpool存储池中有哪些RBD镜像</span></span><br><span class=\"line\">$ rbd ls rbdpool</span><br><span class=\"line\">testrbd</span><br><span class=\"line\"><span class=\"comment\"># 检索RBD镜像信息: rbd info &#123;pool-name&#125;/&#123;image-name&#125;</span></span><br><span class=\"line\">$ rbd info rbdpool/testrbd</span><br><span class=\"line\">rbd image <span class=\"string\">'testrbd'</span>:</span><br><span class=\"line\">\tsize 1 GiB <span class=\"keyword\">in</span> 256 objects</span><br><span class=\"line\">\torder 22 (4 MiB objects)</span><br><span class=\"line\">\tsnapshot_count: 0</span><br><span class=\"line\">\tid: 56bc9dc78ddfe</span><br><span class=\"line\">\tblock_name_prefix: rbd_data.56bc9dc78ddfe</span><br><span class=\"line\">\tformat: 2</span><br><span class=\"line\">\tfeatures: layering, exclusive-lock, object-map, fast-diff, deep-flatten</span><br><span class=\"line\">\top_features: </span><br><span class=\"line\">\tflags: </span><br><span class=\"line\">\tcreate_timestamp: Mon Feb  3 18:56:49 2020</span><br><span class=\"line\">\taccess_timestamp: Mon Feb  3 18:56:49 2020</span><br><span class=\"line\">\tmodify_timestamp: Mon Feb  3 18:56:49 2020</span><br><span class=\"line\"><span class=\"comment\"># 调整块设备映像的大小为2GB</span></span><br><span class=\"line\">$  rbd resize --size 2048 rbdpool/testrbd</span><br><span class=\"line\"><span class=\"comment\"># 删除块设备的镜像</span></span><br><span class=\"line\"><span class=\"comment\"># rbd rm &#123;pool-name&#125;/&#123;image-name&#125;</span></span><br><span class=\"line\"><span class=\"comment\"># 例如: rbd rm foo</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用librbd进行存储。为了演示方便，这里使用python编写一个简单例子。ceph的python库是在安装ceph时一并安装好的，不需要再执行<code>pip install</code>进行安装。</p>\n</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> rbd</span><br><span class=\"line\"><span class=\"keyword\">import</span> rados</span><br><span class=\"line\"></span><br><span class=\"line\">cluster = rados.Rados(conffile=<span class=\"string\">'/etc/ceph/ceph.conf'</span>)</span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    cluster.connect()</span><br><span class=\"line\">    print(<span class=\"string\">\"Cluster connect success\"</span>)</span><br><span class=\"line\">    ioctx = cluster.open_ioctx(<span class=\"string\">'rbdpool'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        image = rbd.Image(ioctx, <span class=\"string\">'testrbd'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            <span class=\"comment\"># 块设备写入数据</span></span><br><span class=\"line\">            print(<span class=\"string\">\"Writing content...\"</span>)</span><br><span class=\"line\">            data = <span class=\"string\">'foo'</span> * <span class=\"number\">200</span></span><br><span class=\"line\">            image.write(data, <span class=\"number\">0</span>)</span><br><span class=\"line\">            image.flush()</span><br><span class=\"line\">            print(<span class=\"string\">\"Write finished!\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\"># 块设备读取数据</span></span><br><span class=\"line\">            size = image.size()</span><br><span class=\"line\">            print(<span class=\"string\">\"Reading content...\"</span>)</span><br><span class=\"line\">            i = <span class=\"number\">0</span></span><br><span class=\"line\">            bufsize = <span class=\"number\">1024</span></span><br><span class=\"line\">            buffer = bytes()</span><br><span class=\"line\">            <span class=\"keyword\">while</span> i &lt; size:</span><br><span class=\"line\">                buffer = buffer + image.read(i, min(i + bufsize, size - <span class=\"number\">1</span>))</span><br><span class=\"line\">                i += size</span><br><span class=\"line\">            print(<span class=\"string\">\"%s\"</span> % str(buffer))</span><br><span class=\"line\">        <span class=\"keyword\">finally</span>:</span><br><span class=\"line\">            image.close()</span><br><span class=\"line\">    <span class=\"keyword\">finally</span>:</span><br><span class=\"line\">        ioctx.close()</span><br><span class=\"line\"><span class=\"keyword\">finally</span>:</span><br><span class=\"line\">    cluster.shutdown()</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q&amp;A\"></a>Q&amp;A</h1><h2 id=\"删除pool报错-pool-deletion-is-disabled\"><a href=\"#删除pool报错-pool-deletion-is-disabled\" class=\"headerlink\" title=\"删除pool报错 pool deletion is disabled\"></a>删除pool报错 pool deletion is disabled</h2><p>修改mon节点的配置文件：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vi /etc/ceph/ceph.conf</span><br></pre></td></tr></table></figure>\n\n<p>添加如下配置内容:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mon]</span><br><span class=\"line\">mon allow pool delete = true</span><br></pre></td></tr></table></figure>\n\n<p>重启ceph-mon服务:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ systemctl restart ceph-mon.target</span><br></pre></td></tr></table></figure>\n\n<p>执行删除pool命令:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ceph osd pool delete ecpool ecpool --yes-i-really-really-mean-it</span><br><span class=\"line\">pool <span class=\"string\">'ecpool'</span> removed</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"100-000-pgs-not-active-undersized-peered\"><a href=\"#100-000-pgs-not-active-undersized-peered\" class=\"headerlink\" title=\"100.000% pgs not active undersized+peered\"></a>100.000% pgs not active undersized+peered</h2><p>按照官方文档的说法是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">undersized</span><br><span class=\"line\">The placement group has fewer copies than the configured pool replication level.</span><br></pre></td></tr></table></figure>\n\n<p>意思是这个PG的实际副本数少于配置的副本数。所以这个警告原因是有某个pool的size值大于Ceph OSD集群的节点数了，这样使得Ceph找不到更多的节点数来备份这个PG，PG就会变成undersized状态。</p>\n<p>前面的 100.000% 是因为我当时的集群只有一个pool而且就这个pool的size值配错了，所以是100%的PG数都变成undersized状态。这个百分比可能不是100%，实际情况下需要查询各个pool配置情况来找出这个错误配置的pool。</p>\n<h2 id=\"no-active-mgr\"><a href=\"#no-active-mgr\" class=\"headerlink\" title=\"no active mgr\"></a>no active mgr</h2><p>集群没有开启ceph-mgr组件，请参照”添加ceph-mgr”章节。</p>\n<h2 id=\"too-few-PGs-per-OSD-n-lt-30\"><a href=\"#too-few-PGs-per-OSD-n-lt-30\" class=\"headerlink\" title=\"too few PGs per OSD ( n &lt; 30 )\"></a>too few PGs per OSD ( n &lt; 30 )</h2><p>出现这个警告信息的原因是所有池的PG总数除于OSD数得到的值小于30导致的，可以通过<code>ceph osd pool set $POOL_NAME pg_num $PG_NUM</code>命令修改各个池的PG数，使得总PG数满足如下公式即可：</p>\n<p>Total PGs = ((Total_number_of_OSD * 30) / max_replication_count) / pool_count </p>\n<p>结算的结果往上取靠近2的N次方的值。</p>\n","site":{"data":{}},"excerpt":"<p>本文主要介绍Ceph存储集群的部署方式，以及三种存储类型服务的构建及简单使用，不对内部原理做深入介绍，过后会编写另外的文章聊这个话题。本文属于个人学习笔记，如有错误欢迎指正，部署期间踩到的坑写在了Q&amp;A。</p>","more":"<h1 id=\"组件介绍\"><a href=\"#组件介绍\" class=\"headerlink\" title=\"组件介绍\"></a>组件介绍</h1><p>一个Ceph存储群集至少需要一个监控器(ceph-mon)，管理器(ceph-mgr)和对象存储守护程序(ceph-osd)。运行Ceph文件系统客户端时，还需要元数据服务器(ceph-mds)。</p>\n<ul>\n<li>管理器(ceph-mon): 维护集群状态的映射，包括监视器映射，管理器映射，OSD映射，MDS映射和CRUSH映射。这些映射是Ceph守护程序相互协调所需的关键群集状态。监视器还负责管理守护程序和客户端之间的身份验证。通常至少需要三个监视器才能实现冗余和高可用性。</li>\n<li>管理器(ceph-mgr): 负责跟踪运行时指标和Ceph集群的当前状态，包括存储利用率，当前性能指标和系统负载。Ceph Manager守护程序基于python模块进行管理并且负责公开Ceph集群信息（包括基于Web的Ceph Dashboard和 REST API）。通常，至少需要两个管理器才能实现高可用性。</li>\n<li>对象存储守护程序(ceph-osd): 处理数据复制，恢复，重新平衡，并通过检查其他Ceph OSD守护程序的心跳来向Ceph监视器和管理器提供一些监视信息。通常至少需要3个Ceph OSD才能实现冗余和高可用性。</li>\n<li>元数据服务器(ceph-mds): 代表Ceph文件系统存储元数据（即Ceph块设备和Ceph对象存储不使用MDS）。Ceph的元数据服务器允许POSIX文件系统的用户来执行基本的命令（如 ls，find等等）。</li>\n</ul>\n<p>Ceph将数据作为对象存储在逻辑存储池中。Ceph 使用 CRUSH算法计算一个对象应该包含在哪个Placement group，并进一步计算这个Placement group应存储在哪个Ceph OSD守护程序。CRUSH算法使Ceph存储集群能够动态扩展，重新平衡和恢复。下面是Ceph文件对象存储流程图：</p>\n<p><img src=\"../../../../images/ceph.png\" alt=\"Ceph文件对象存储流程图\"></p>\n<h1 id=\"预安装\"><a href=\"#预安装\" class=\"headerlink\" title=\"预安装\"></a>预安装</h1><h2 id=\"添加密钥\"><a href=\"#添加密钥\" class=\"headerlink\" title=\"添加密钥\"></a>添加密钥</h2><h3 id=\"APT\"><a href=\"#APT\" class=\"headerlink\" title=\"APT\"></a>APT</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -q -O- <span class=\"string\">'https://download.ceph.com/keys/release.asc'</span> | sudo apt-key add -</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"RPM\"><a href=\"#RPM\" class=\"headerlink\" title=\"RPM\"></a>RPM</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo rpm --import <span class=\"string\">'https://download.ceph.com/keys/release.asc'</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"添加Ceph源\"><a href=\"#添加Ceph源\" class=\"headerlink\" title=\"添加Ceph源\"></a>添加Ceph源</h2><h3 id=\"Ubuntu或Debian\"><a href=\"#Ubuntu或Debian\" class=\"headerlink\" title=\"Ubuntu或Debian\"></a>Ubuntu或Debian</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-add-repository <span class=\"string\">'deb https://download.ceph.com/debian-&#123;ceph-release&#125;/ $(lsb_release -sc) main'</span></span><br><span class=\"line\">sudo apt update</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"RHEL或CentOS\"><a href=\"#RHEL或CentOS\" class=\"headerlink\" title=\"RHEL或CentOS\"></a>RHEL或CentOS</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 加入Ceph yum源文件</span></span><br><span class=\"line\">$ cat  /etc/yum.repos.d/ceph.repo</span><br><span class=\"line\">[ceph]</span><br><span class=\"line\">name=Ceph packages <span class=\"keyword\">for</span> <span class=\"variable\">$basearch</span></span><br><span class=\"line\">baseurl=https://download.ceph.com/rpm-&#123;ceph-release&#125;/&#123;distro&#125;/<span class=\"variable\">$basearch</span></span><br><span class=\"line\">enabled=1</span><br><span class=\"line\">priority=2</span><br><span class=\"line\">gpgcheck=1</span><br><span class=\"line\">gpgkey=https://download.ceph.com/keys/release.asc</span><br><span class=\"line\"></span><br><span class=\"line\">[ceph-noarch]</span><br><span class=\"line\">name=Ceph noarch packages</span><br><span class=\"line\">baseurl=https://download.ceph.com/rpm-&#123;ceph-release&#125;/&#123;distro&#125;/noarch</span><br><span class=\"line\">enabled=1</span><br><span class=\"line\">priority=2</span><br><span class=\"line\">gpgcheck=1</span><br><span class=\"line\">gpgkey=https://download.ceph.com/keys/release.asc</span><br><span class=\"line\"></span><br><span class=\"line\">[ceph-source]</span><br><span class=\"line\">name=Ceph <span class=\"built_in\">source</span> packages</span><br><span class=\"line\">baseurl=https://download.ceph.com/rpm-&#123;ceph-release&#125;/&#123;distro&#125;/SRPMS</span><br><span class=\"line\">enabled=0</span><br><span class=\"line\">priority=2</span><br><span class=\"line\">gpgcheck=1</span><br><span class=\"line\">gpgkey=https://download.ceph.com/keys/release.asc</span><br><span class=\"line\"></span><br><span class=\"line\">$ yum clean all</span><br><span class=\"line\">$ yum makecache</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"时间同步\"><a href=\"#时间同步\" class=\"headerlink\" title=\"时间同步\"></a>时间同步</h2><p>需要确保Ceph集群中所有节点的时间同步，使用 ntp 工具做时间同步。<br>CentOS / RHEL:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install ntp ntpdate ntp-doc</span><br></pre></td></tr></table></figure>\n\n<p>Debian / Ubuntu:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install ntpsec</span><br></pre></td></tr></table></figure>\n\n<p>或:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install chrony</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"安装SSH服务\"><a href=\"#安装SSH服务\" class=\"headerlink\" title=\"安装SSH服务\"></a>安装SSH服务</h2><p>Ceph集群部署是在总控机器上通过SSH连接其它集群节点进行安装，所以需要保证所有Ceph集群节点都开启了SSH服务。</p>\n<p>CentOS / RHEL:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install openssh-server</span><br></pre></td></tr></table></figure>\n\n<p>Debian / Ubuntu:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install openssh-server</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建Ceph部署用户\"><a href=\"#创建Ceph部署用户\" class=\"headerlink\" title=\"创建Ceph部署用户\"></a>创建Ceph部署用户</h2><p>为了安全起见不建议使用root用户进行部署，创建一个Ceph部署专用的用户更为合理，而且需要保证部署机可通过“SSH免密登录”的方式使用Ceph部署用户登录到集群中的各个节点。</p>\n<p>创建用户:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh user@ceph-server</span><br><span class=\"line\">sudo useradd -d /home/&#123;username&#125; -m &#123;username&#125;</span><br><span class=\"line\">sudo passwd &#123;username&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要保证Ceph部署用户是一个 sudoer:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"&#123;username&#125; ALL = (root) NOPASSWD:ALL\"</span> | sudo tee /etc/sudoers.d/&#123;username&#125;</span><br><span class=\"line\">sudo chmod 0440 /etc/sudoers.d/&#123;username&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"免密登录\"><a href=\"#免密登录\" class=\"headerlink\" title=\"免密登录\"></a>免密登录</h2><p>在主节点上执行下列指令实现免密登录：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-copy-id ceph@&#123;host&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"安装ceph-deploy\"><a href=\"#安装ceph-deploy\" class=\"headerlink\" title=\"安装ceph-deploy\"></a>安装ceph-deploy</h2><h3 id=\"Ubuntu或Debian-1\"><a href=\"#Ubuntu或Debian-1\" class=\"headerlink\" title=\"Ubuntu或Debian\"></a>Ubuntu或Debian</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ apt-get install ceph-deploy</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"RHEL或CentOS-1\"><a href=\"#RHEL或CentOS-1\" class=\"headerlink\" title=\"RHEL或CentOS\"></a>RHEL或CentOS</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yum install ceph-deploy</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"部署Ceph集群\"><a href=\"#部署Ceph集群\" class=\"headerlink\" title=\"部署Ceph集群\"></a>部署Ceph集群</h1><p> 官方提供了三种部署Ceph集群的方法，分别是：ceph-deploy, cephadm, 手动安装。这里只介绍最大众化的安装方式： ceph-deploy。</p>\n<p> 演示案例采用3节点集群部署，主机名与IP映射如下：</p>\n<ul>\n<li>node1: 192.168.56.101</li>\n<li>node2: 192.168.56.102</li>\n<li>node3: 192.168.56.103</li>\n</ul>\n<p>以 node1 作为部署主节点，如没有特殊说明下面给出的指令都运行在node1节点上。</p>\n<h2 id=\"部署-ceph-mon\"><a href=\"#部署-ceph-mon\" class=\"headerlink\" title=\"部署 ceph-mon\"></a>部署 ceph-mon</h2><ol>\n<li>创建 Ceph 配置文件:<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 计划三个节点都部署ceph-mon服务，格式: ceph-deploy new &#123;initial-monitor-node(s)&#125;</span></span><br><span class=\"line\">$ ceph-deploy new node1 node2 node3</span><br><span class=\"line\"><span class=\"comment\"># 创建成功后会在当前目录生成这三个文件，其中ceph.conf是集群配置文件，ceph.mon.keyring是ceph-mon服务的密钥</span></span><br><span class=\"line\">$ ls</span><br><span class=\"line\">ceph.conf ceph-deploy-ceph.log  ceph.mon.keyring</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>一个Ceph集群中至少拥有一个ceph-mon，为了实现高可用，Ceph集群可以部署多个ceph-mon服务，当集群中某一个ceph-mon服务挂掉后也不会影响整个集群使用。Ceph使用Paxos算法，该算法需要大多数ceph-mon（即，大于N / 2，其中N是ceph-mon的数量）才能形成仲裁。监视器的奇数往往会更好，尽管这不是必需的。</p>\n<p>这里只是配置初始的ceph-mon节点主机，可以在后续集群正常使用过程中添加新的ceph-mon。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 后续添加ceph-mon的指令格式: ceph-deploy mon add &#123;ceph-nodes&#125;</span></span><br><span class=\"line\">$ ceph-deploy mon add node4 node5</span><br></pre></td></tr></table></figure>\n\n<p>一旦添加了新的Ceph监视器，Ceph将开始同步监视器并形成仲裁。您可以通过执行以下操作检查仲裁状态：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ceph quorum_status --format json-pretty</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><p>如果你的集群节点存在多个网卡，需要为ceph.conf文件添加Ceph集群通信网段的配置。演示网络是192.168.56.0/24网段，所以添加配置如下：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># public network = &#123;ip-address&#125;/&#123;bits&#125;</span></span><br><span class=\"line\">public network = 192.168.56.0/24</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果采用了IPv6，还需要在ceph.conf中添加如下配置:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ms <span class=\"built_in\">bind</span> ipv6 = <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>为每个节点安装 Ceph 依赖库。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ceph-deploy install --no-adjust-repos node1 node2 node3</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>这个指令会通过SSH远程到 node1,node2,node3 三个节点分别执行 <code>yum install</code> 或 <code>apt install</code> 安装，因为前面预处理章节已经配置了ceph的yum源或apt源，<code>--no-adjust-repos</code> 参数表明不修改节点的yum源或apt源，直接执行 <code>yum install</code> 或 <code>apt install</code> 指令下载需要的依赖库，不添加此参数的话可能会造成下载的库版本与我们预期的不一致问题。</p>\n<ol start=\"5\">\n<li>初始化ceph-mon并创建组件密钥。<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ceph-deploy mon create-initial</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>一旦指令执行成功，在当前目录下将会新增一些keyring文件：</p>\n<ul>\n<li>ceph.client.admin.keyring</li>\n<li>ceph.bootstrap-mgr.keyring</li>\n<li>ceph.bootstrap-osd.keyring</li>\n<li>ceph.bootstrap-mds.keyring</li>\n<li>ceph.bootstrap-rgw.keyring</li>\n<li>ceph.bootstrap-rbd.keyring</li>\n<li>ceph.bootstrap-rbd-mirror.keyring</li>\n</ul>\n<ol start=\"6\">\n<li>使用<code>ceph-deploy</code>复制配置文件以及admin用户的密钥到Ceph集群的其它节点，这样做其它节点也可以通过命令行对Ceph进行操作。<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 可以指定多个节点拥有ceph集群的管理权限，格式：ceph-deploy admin &#123;ceph-node(s)&#125;</span></span><br><span class=\"line\">$ ceph-deploy admin node1</span><br><span class=\"line\"><span class=\"comment\"># 确保当前用户拥有ceph.client.admin.keyring文件的读权限</span></span><br><span class=\"line\">$ sudo chown &#123;user&#125;:&#123;group&#125; /etc/ceph/ceph.client.admin.keyring</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>指令执行完毕后，在指定节点的 /etc/ceph 目录下会新增 ceph.client.admin.keyring 密钥文件，ceph集群管理命令需要通过这个密钥认证才能执行。</p>\n<p>node1上执行ceph命令，确认admin密钥正确:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ceph@node1 ~]$ ceph -s</span><br><span class=\"line\">  cluster:</span><br><span class=\"line\">    id:     d809fd13-1fd6-4591-bd2b-5d4eabbadaba</span><br><span class=\"line\">    health: HEALTH_WARN</span><br><span class=\"line\">            no active mgr</span><br><span class=\"line\">            OSD count 0 &lt; osd_pool_default_size 3</span><br><span class=\"line\"> </span><br><span class=\"line\">  services:</span><br><span class=\"line\">    mon: 3 daemons, quorum node1,node2,node3 (age 11m)</span><br><span class=\"line\">    mgr: no daemons active (since 63s)</span><br><span class=\"line\">    osd: 0 osds: 0 up, 0 <span class=\"keyword\">in</span></span><br><span class=\"line\"> </span><br><span class=\"line\">  data:</span><br><span class=\"line\">    pools:   0 pools, 0 pgs</span><br><span class=\"line\">    objects: 0 objects, 0 B</span><br><span class=\"line\">    usage:   0 B used, 0 B / 0 B avail</span><br><span class=\"line\">    pgs:</span><br></pre></td></tr></table></figure>\n\n<p>在没有赋予管理权限的节点上尝试执行Ceph管理指令将会报错：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在 node2或node3 上执行</span></span><br><span class=\"line\">[ceph@node2 ~]$ ceph -s</span><br><span class=\"line\">[errno 2] error connecting to the cluster</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"部署-ceph-mgr\"><a href=\"#部署-ceph-mgr\" class=\"headerlink\" title=\"部署 ceph-mgr\"></a>部署 ceph-mgr</h2><p>在 luminous 或更新的版本需要这一步。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ceph-deploy mgr create node1</span><br><span class=\"line\"><span class=\"comment\"># 看到Ceph集群状态中的 no active mgr 警告信息已经消失</span></span><br><span class=\"line\">$ ceph -s</span><br><span class=\"line\">  cluster:</span><br><span class=\"line\">    id:     d809fd13-1fd6-4591-bd2b-5d4eabbadaba</span><br><span class=\"line\">    health: HEALTH_WARN</span><br><span class=\"line\">            OSD count 0 &lt; osd_pool_default_size 3</span><br><span class=\"line\"> </span><br><span class=\"line\">  services:</span><br><span class=\"line\">    mon: 3 daemons, quorum node1,node2,node3 (age 14m)</span><br><span class=\"line\">    mgr: node1(active, since 1.52953s)</span><br><span class=\"line\">    osd: 0 osds: 0 up, 0 <span class=\"keyword\">in</span></span><br><span class=\"line\"> </span><br><span class=\"line\">  data:</span><br><span class=\"line\">    pools:   0 pools, 0 pgs</span><br><span class=\"line\">    objects: 0 objects, 0 B</span><br><span class=\"line\">    usage:   0 B used, 0 B / 0 B avail</span><br><span class=\"line\">    pgs:</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"添加OSD\"><a href=\"#添加OSD\" class=\"headerlink\" title=\"添加OSD\"></a>添加OSD</h2><p>OSD是Ceph集群的基础存储单元，需要指定一个裸盘、主分区或逻辑分区作为一个OSD服务。</p>\n<p>笔者当前演示的环境是用3台虚拟机并各创建一个虚拟裸盘实现，3个节点均挂载这个虚拟磁盘在/dev/sdb上，大小为30G。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ lsblk</span><br><span class=\"line\">NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class=\"line\">sda               8:0    0   10G  0 disk </span><br><span class=\"line\">├─sda1            8:1    0    1G  0 part /boot</span><br><span class=\"line\">└─sda2            8:2    0    9G  0 part </span><br><span class=\"line\">  ├─centos-root 253:0    0    8G  0 lvm  /</span><br><span class=\"line\">  └─centos-swap 253:1    0    1G  0 lvm  [SWAP]</span><br><span class=\"line\">sdb               8:16   0   30G  0 disk </span><br><span class=\"line\">sr0              11:0    1 1024M  0 rom</span><br></pre></td></tr></table></figure>\n\n<p>使用<code>ceph-deploy</code>添加OSD指令如下：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 格式: ceph-deploy osd create --data &#123;device&#125; &#123;ceph-node&#125;</span></span><br><span class=\"line\"><span class=\"comment\"># 如果你使用的是逻辑分区，参数格式为 --data vg_group/lv_name</span></span><br><span class=\"line\">$ ceph-deploy osd create --data /dev/sdb node1</span><br><span class=\"line\">$ ceph-deploy osd create --data /dev/sdb node2</span><br><span class=\"line\">$ ceph-deploy osd create --data /dev/sdb node3</span><br></pre></td></tr></table></figure>\n\n<p>这里可能因Ceph版本不同细节有些许区别，若不幸遇到报错需要根据日志自己解决。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 部署完毕后再次查看集群状态可以看到3个OSD已经启动</span></span><br><span class=\"line\">$ ceph -s</span><br><span class=\"line\">  cluster:</span><br><span class=\"line\">    id:     d809fd13-1fd6-4591-bd2b-5d4eabbadaba</span><br><span class=\"line\">    health: HEALTH_OK</span><br><span class=\"line\"> </span><br><span class=\"line\">  services:</span><br><span class=\"line\">    mon: 3 daemons, quorum node1,node2,node3 (age 34m)</span><br><span class=\"line\">    mgr: node1(active, since 19m)</span><br><span class=\"line\">    osd: 3 osds: 3 up (since 5s), 3 <span class=\"keyword\">in</span> (since 5s)</span><br><span class=\"line\"> </span><br><span class=\"line\">  data:</span><br><span class=\"line\">    pools:   0 pools, 0 pgs</span><br><span class=\"line\">    objects: 0 objects, 0 B</span><br><span class=\"line\">    usage:   3.0 GiB used, 84 GiB / 87 GiB avail</span><br><span class=\"line\">    pgs:</span><br><span class=\"line\"><span class=\"comment\"># 查看OSD树状结构</span></span><br><span class=\"line\">$ ceph osd tree</span><br><span class=\"line\">ID CLASS WEIGHT  TYPE NAME      STATUS REWEIGHT PRI-AFF </span><br><span class=\"line\">-1       0.08487 root default                           </span><br><span class=\"line\">-3       0.02829     host node1                         </span><br><span class=\"line\"> 0   hdd 0.02829         osd.0      up  1.00000 1.00000 </span><br><span class=\"line\">-5       0.02829     host node2                         </span><br><span class=\"line\"> 1   hdd 0.02829         osd.1      up  1.00000 1.00000 </span><br><span class=\"line\">-7       0.02829     host node3                         </span><br><span class=\"line\"> 2   hdd 0.02829         osd.2      up  1.00000 1.00000</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"删除OSD\"><a href=\"#删除OSD\" class=\"headerlink\" title=\"删除OSD\"></a>删除OSD</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 从crush中移除节点</span></span><br><span class=\"line\">$ ceph osd crush remove osd.<span class=\"variable\">$ID</span></span><br><span class=\"line\"><span class=\"comment\"># 将节点服务停止</span></span><br><span class=\"line\">$ ceph osd down osd.<span class=\"variable\">$ID</span></span><br><span class=\"line\"><span class=\"comment\"># 删除节点</span></span><br><span class=\"line\">$ ceph osd rm osd.<span class=\"variable\">$ID</span></span><br><span class=\"line\"><span class=\"comment\"># 删除节点认证</span></span><br><span class=\"line\">$ ceph auth del osd.<span class=\"variable\">$ID</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"添加MDS\"><a href=\"#添加MDS\" class=\"headerlink\" title=\"添加MDS\"></a>添加MDS</h2><p>ceph-mds是CephFS必要的服务，如果可以采用部署<a href=\"https://docs.ceph.com/docs/master/mgr/orchestrator_cli/\" target=\"_blank\" rel=\"noopener\">Orchestrator</a>自动为您的文件系统创建并配置MDS（请参阅 <a href=\"https://docs.ceph.com/docs/master/mgr/orchestrator_cli/#current-implementation-status\" target=\"_blank\" rel=\"noopener\">Orchestrator部署表</a>）。否则，参照下列方法手动部署mds。</p>\n<p>想要启动CephFS前必须启动ceph-mds服务，执行下列脚本可部署mds服务（需要先配置环境变量）：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建mds存储目录。</span></span><br><span class=\"line\">$ mkdir -p /var/lib/ceph/mds/<span class=\"variable\">$CLUSTER_NAME</span>-<span class=\"variable\">$MDS_ID</span></span><br><span class=\"line\"><span class=\"comment\"># 部署ceph-mds服务，命令格式: ceph-deploy mds create &#123;ceph-node&#125;</span></span><br><span class=\"line\">$ ceph-deploy mds create node1</span><br><span class=\"line\"><span class=\"comment\"># 检测mds是否启动成功（\"1 up:standby\" 表示有一个mds节点启动成功）</span></span><br><span class=\"line\">$ ceph mds <span class=\"built_in\">stat</span></span><br><span class=\"line\"> 1 up:standby</span><br></pre></td></tr></table></figure>\n\n<p>至此Ceph集群基础组件部署完毕，可以根据需要往下部署不同存储类型的服务。</p>\n<h1 id=\"三种Ceph存储类型的部署\"><a href=\"#三种Ceph存储类型的部署\" class=\"headerlink\" title=\"三种Ceph存储类型的部署\"></a>三种Ceph存储类型的部署</h1><p>CephFS致力于为各种应用程序提供最新，多用途，高可用性和高性能的文件存储。提供了三种存储类型：</p>\n<ul>\n<li>CephFS</li>\n<li>Ceph Object Storage</li>\n<li>CephRBD</li>\n</ul>\n<p>避免篇幅过长，本文只介绍最简单的部署及使用方式，过后会有其它文章详述各种存储类型的运行机制。</p>\n<h2 id=\"CephFS\"><a href=\"#CephFS\" class=\"headerlink\" title=\"CephFS\"></a>CephFS</h2><h3 id=\"服务端部署\"><a href=\"#服务端部署\" class=\"headerlink\" title=\"服务端部署\"></a>服务端部署</h3><p>CephFS 是 Ceph File System 的简称，它是在Ceph的分布式对象存储RADOS之上构建的POSIX兼容文件系统。<br>文件元数据与文件数据存储在单独的RADOS池中，并通过可调整大小的元数据服务器或MDS集群提供服务，该集群是可拓展的以支持高吞吐量的元数据工作负载。</p>\n<p>文件系统的客户端可以直接访问RADOS以读取和写入文件数据块，因此，工作负载可能会随着基础RADOS对象存储的数量线性扩展，也就是说，没有网关或代理为客户端中介数据I / O。</p>\n<p>通过MDS集群协调对数据的访问，每个MDS都会将对元数据的变化汇总到日志以对RADOS进行一系列有效写入。MDS不会在本地存储任何元数据状态。此模型允许在POSIX文件系统的上下文中客户端之间进行连贯且快速的协作。</p>\n<p><img src=\"https://docs.ceph.com/docs/master/_images/cephfs-architecture.svg\" alt=\"CephFS架构图\"></p>\n<p>创建cephfs可以直接使用如下指令:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建名为 testfs 的文件系统资源</span></span><br><span class=\"line\">$ ceph fs volume create testfs</span><br><span class=\"line\"><span class=\"comment\"># 查看已有文件系统资源</span></span><br><span class=\"line\">$ ceph fs ls</span><br><span class=\"line\">name: testfs, metadata pool: cephfs.testfs.meta, data pools: [cephfs.testfs.data ]</span><br><span class=\"line\"><span class=\"comment\"># ceph-mds 管理了这个FS</span></span><br><span class=\"line\">$ ceph mds <span class=\"built_in\">stat</span></span><br><span class=\"line\">testfs:1 &#123;0=node1=up:active&#125;</span><br><span class=\"line\"><span class=\"comment\"># 查看集群状态</span></span><br><span class=\"line\">$ ceph -s</span><br><span class=\"line\">  cluster:</span><br><span class=\"line\">    id:     908baedd-c2d1-4977-8aa8-dea83b31d271</span><br><span class=\"line\">    health: HEALTH_OK</span><br><span class=\"line\"> </span><br><span class=\"line\">  services:</span><br><span class=\"line\">    mon: 1 daemons, quorum node1 (age 42m)</span><br><span class=\"line\">    mgr: node1(active, since 50m)</span><br><span class=\"line\">    mds: testfs:1 &#123;0=node1=up:active&#125;</span><br><span class=\"line\">    osd: 3 osds: 3 up (since 25m), 3 <span class=\"keyword\">in</span> (since 51m)</span><br><span class=\"line\"> </span><br><span class=\"line\">  data:</span><br><span class=\"line\">    pools:   2 pools, 96 pgs</span><br><span class=\"line\">    objects: 24 objects, 3.3 KiB</span><br><span class=\"line\">    usage:   3.0 GiB used, 27 GiB / 30 GiB avail</span><br><span class=\"line\">    pgs:     96 active+clean</span><br></pre></td></tr></table></figure>\n\n<p>该指令将自动创建一个元数据存储池（<code>cephfs.&lt;FSNAME&gt;.meta</code>）与一个内容存储池（<code>cephfs.&lt;FSNAME&gt;.data</code>）。</p>\n<p>若不幸出现了警告内容为<code>too few PGs per OSD (n &lt; min 30)</code>，请参考Q&amp;A章节获知解决方案。</p>\n<h3 id=\"客户端挂载\"><a href=\"#客户端挂载\" class=\"headerlink\" title=\"客户端挂载\"></a>客户端挂载</h3><p>CephFS挂载有两种方法：使用Linux内核驱动或是使用ceph-fuse工具。实际上比较常用的是ceph-fuse工具方法，所以本文只介绍这种挂载方式。</p>\n<ol>\n<li><p>需要先安装 ceph-fuse</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yum install -y ceph-fuse</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在客户机生成服务端路径相关配置文件。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在客户机上执行</span></span><br><span class=\"line\">$ mkdir -p -m 755 /etc/ceph</span><br><span class=\"line\">$ ssh &#123;user&#125;@&#123;mon-host&#125; <span class=\"string\">\"sudo ceph config generate-minimal-conf\"</span> | sudo tee /etc/ceph/ceph.conf</span><br><span class=\"line\"><span class=\"comment\"># 确保文件可以被其它用户访问到</span></span><br><span class=\"line\">$ chmod 644 /etc/ceph/ceph.conf</span><br><span class=\"line\"><span class=\"comment\"># 文件中记录了ceph-mon的地址以及集群ID</span></span><br><span class=\"line\">$ cat /etc/ceph/ceph.conf</span><br><span class=\"line\">[global]</span><br><span class=\"line\">fsid = 908baedd-c2d1-4977-8aa8-dea83b31d271</span><br><span class=\"line\">mon_host = [v2:192.168.56.101:3300/0,v1:192.168.56.101:6789/0]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>因为服务端采用了CephX认证方式，需要为客户端机器生成一份对应的密钥文件。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建一个foo用户授权名为 testfs 的CephFS资源，并且拥有根路径下( / )的读写权限( rw )</span></span><br><span class=\"line\">$ ssh &#123;user&#125;@&#123;mon-host&#125; <span class=\"string\">\"sudo ceph fs authorize testfs client.foo / rw\"</span> | sudo tee /etc/ceph/ceph.client.foo.keyring</span><br><span class=\"line\">$ chmod 600 /etc/ceph/ceph.client.foo.keyring</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>挂载CephFS到指定客户机目录</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mkdir /mnt/mycephfs</span><br><span class=\"line\">$ sudo ceph-fuse --id foo /mnt/mycephfs</span><br><span class=\"line\">ceph-fuse[4131]: starting ceph client</span><br><span class=\"line\">2020-02-02 05:21:21.476 7f5f9b493e00 -1 init, newargv = 0x561161876670 newargc=7</span><br><span class=\"line\">ceph-fuse[4131]: starting fuse</span><br><span class=\"line\"><span class=\"comment\"># 确认目录挂载成功</span></span><br><span class=\"line\">$ df -h | grep ceph-fuse</span><br><span class=\"line\">ceph-fuse                 26G     0   26G    0% /mnt/mycephfs</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>撤销挂载卷</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ umount /mnt/mycephfs</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>执行完上述4步后就算是挂载完毕了，但是客户机重启后挂载卷将会消失需要重新执行<code>ceph-fuse</code>指令挂载回来，可以修改<code>/etc/fstab</code>文件做到开机自动挂载，需要在<code>/etc/fstab</code>文件中添加如下配置：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#DEVICE PATH       TYPE      OPTIONS</span></span><br><span class=\"line\">none    /mnt/mycephfs  fuse.ceph ceph.id=&#123;user-ID&#125;[,ceph.conf=&#123;path/to/conf.conf&#125;],_netdev,defaults  0 0</span><br></pre></td></tr></table></figure>\n\n<p>例子:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">none    /mnt/mycephfs  fuse.ceph ceph.id=foo,_netdev,defaults  0 0</span><br><span class=\"line\"><span class=\"comment\"># 面向多个Ceph集群时，需要手动指定特定集群的配置文件（默认使用 /etc/ceph/ceph.conf）</span></span><br><span class=\"line\">none    /mnt/mycephfs  fuse.ceph ceph.id=foo,ceph.conf=/etc/ceph/foo.conf,_netdev,defaults  0 0</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Ceph-Object-Storage\"><a href=\"#Ceph-Object-Storage\" class=\"headerlink\" title=\"Ceph Object Storage\"></a>Ceph Object Storage</h2><p>Ceph对象网关是一个对象存储接口，建立在该对象之上， librados为应用程序提供了通往Ceph存储集群的RESTful网关。</p>\n<p>Ceph对象存储支持两个接口：</p>\n<ul>\n<li>与S3兼容：为对象存储功能提供与Amazon S3 RESTful API的大部分子集兼容的接口。</li>\n<li>兼容Swift：为对象存储功能提供与OpenStack Swift API的大部分子集兼容的接口。</li>\n</ul>\n<p>S3和Swift API共享一个公共的名称空间，因此您可以使用一个API编写数据，而使用另一个API检索数据。</p>\n<p><img src=\"https://docs.ceph.com/docs/master/_images/ditaa-50d12451eb76c5c72c4574b08f0320b39a42e5f1.png\" alt=\"Ceph Object Storage 架构图\"></p>\n<ol>\n<li><p>安装Rados Gateway的依赖库。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ceph-deploy install --rgw &lt;gateway-node1&gt; [&lt;gateway-node2&gt; ...]</span></span><br><span class=\"line\">$ ceph-deploy install --rgw node1</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建Rados网关实例。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ceph-deploy rgw create &lt;gateway-node1&gt;</span></span><br><span class=\"line\">$ ceph-deploy rgw create node1</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>默认Rados网关占用7480端口，可以使用浏览器访问<code>http://node1:7480/</code>得到如下响应，说明网关部署已完毕：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ListAllMyBucketsResult</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://s3.amazonaws.com/doc/2006-03-01/\"</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">Owner</span>&gt;</span></span><br><span class=\"line\">               <span class=\"tag\">&lt;<span class=\"name\">ID</span>&gt;</span>anonymous<span class=\"tag\">&lt;/<span class=\"name\">ID</span>&gt;</span></span><br><span class=\"line\">               <span class=\"tag\">&lt;<span class=\"name\">DisplayName</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">DisplayName</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;/<span class=\"name\">Owner</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">Buckets</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;/<span class=\"name\">Buckets</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ListAllMyBucketsResult</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>[可选] 修改Rados网关端口。修改<code>ceph.conf</code>文件添加如下内容:<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[client.rgw.node1]  <span class=\"comment\"># node1对应上面第2步部署的节点</span></span><br><span class=\"line\">rgw_frontends = <span class=\"string\">\"civetweb port=80\"</span>  <span class=\"comment\"># 修改为80端口</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>然后使用ceph-deploy更新相关节点的<code>ceph.conf</code>文件:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ceph-deploy --overwrite-conf config push &lt;gateway-node&gt; [&lt;other-nodes&gt;]</span></span><br><span class=\"line\">$ ceph-deploy --overwrite-conf config push node1</span><br><span class=\"line\"><span class=\"comment\"># 重启rados网关服务才能使配置生效</span></span><br><span class=\"line\">$ sudo systemctl restart ceph-radosgw.service</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>[可选] 使Rados网关支持SSL协议。需要先生成证书（略），然后修改<code>ceph.conf</code>文件添加如下配置：<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[client.rgw.node1]</span><br><span class=\"line\">rgw_frontends = civetweb port=443s ssl_certificate=/etc/ceph/private/keyandcert.pem <span class=\"comment\"># ssl_certificate指定证书路径</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>也可以同时开放HTTP协议端口与HTTPS协议端口，配置修改如下：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[client.rgw.node1]</span><br><span class=\"line\">rgw_frontends = civetweb port=80+443s ssl_certificate=/etc/ceph/private/keyandcert.pem</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>添加用户。Ceph Object Storage 的 Rados 网关支持 S3 与 Swift 两种 API，但它们的用户权限管理有所不同，所以需要根据需要生成不同类型的用户。</li>\n</ol>\n<ul>\n<li>添加S3用户: <code>sudo radosgw-admin user create --uid=&quot;testuser&quot; --display-name=&quot;First User&quot;</code></li>\n<li>添加Swift用户: <code>sudo radosgw-admin subuser create --uid=testuser --subuser=testuser:swift --access=full</code></li>\n</ul>\n<p>到此Rados网关基础部署算是完成了，测试网关上传下载功能请参考: <a href=\"https://docs.ceph.com/docs/master/install/install-ceph-gateway/#access-verification。\" target=\"_blank\" rel=\"noopener\">https://docs.ceph.com/docs/master/install/install-ceph-gateway/#access-verification。</a></p>\n<h2 id=\"CephRBD\"><a href=\"#CephRBD\" class=\"headerlink\" title=\"CephRBD\"></a>CephRBD</h2><p>块是字节序列（例如，一个512字节的数据块）。基于块的存储接口是使用旋转介质（例如硬盘，CD，软盘甚至传统的9轨磁带）存储数据的最常用方法。块设备接口无处不在使虚拟块设备成为与海量数据存储系统（如Ceph）进行交互的理想选择。</p>\n<p>Ceph块设备经过精简配置，可调整大小，并在Ceph集群中的多个OSD上存储条带化数据。Ceph块设备利用了 RADOS功能，例如快照，复制和一致性。Ceph的 RADOS块设备（RBD）使用内核模块或librbd库与OSD进行交互。</p>\n<p><img src=\"https://docs.ceph.com/docs/master/_images/ditaa-dc9f80d771b55f2daa5cbbfdb2dd0d3e6dfc17c0.png\" alt=\"Ceph块设备架构图\"></p>\n<ol>\n<li><p>创建一个用于RBD的存储池。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ceph osd pool create rbdpool</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用RBD工具初始化这个存储池。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rbd pool init rbdpool</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建可以访问这个RBD的用户。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ceph auth get-or-create client.&#123;ID&#125; mon 'profile rbd' osd 'profile &#123;profile name&#125; [pool=&#123;pool-name&#125;][, profile ...]' mgr 'profile rbd [pool=&#123;pool-name&#125;]'</span></span><br><span class=\"line\">$ ceph auth get-or-create client.testrbd mon <span class=\"string\">'profile rbd'</span> osd <span class=\"string\">'profile rbd pool=rbdpool'</span> mgr <span class=\"string\">'profile rbd'</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建块设备镜像。在您开始将数据保存到它们之前，它们实际上并不使用任何物理存储。但是，它们确实具有您使用<code>--size</code>选项设置的最大容量。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建名为testrbd的镜像，大小为1GB。指令格式：rbd create --size &#123;megabytes&#125; &#123;pool-name&#125;/&#123;image-name&#125;</span></span><br><span class=\"line\">$ rbd create --size 1024 rbdpool/testrbd</span><br><span class=\"line\"><span class=\"comment\"># 查看rbdpool存储池中有哪些RBD镜像</span></span><br><span class=\"line\">$ rbd ls rbdpool</span><br><span class=\"line\">testrbd</span><br><span class=\"line\"><span class=\"comment\"># 检索RBD镜像信息: rbd info &#123;pool-name&#125;/&#123;image-name&#125;</span></span><br><span class=\"line\">$ rbd info rbdpool/testrbd</span><br><span class=\"line\">rbd image <span class=\"string\">'testrbd'</span>:</span><br><span class=\"line\">\tsize 1 GiB <span class=\"keyword\">in</span> 256 objects</span><br><span class=\"line\">\torder 22 (4 MiB objects)</span><br><span class=\"line\">\tsnapshot_count: 0</span><br><span class=\"line\">\tid: 56bc9dc78ddfe</span><br><span class=\"line\">\tblock_name_prefix: rbd_data.56bc9dc78ddfe</span><br><span class=\"line\">\tformat: 2</span><br><span class=\"line\">\tfeatures: layering, exclusive-lock, object-map, fast-diff, deep-flatten</span><br><span class=\"line\">\top_features: </span><br><span class=\"line\">\tflags: </span><br><span class=\"line\">\tcreate_timestamp: Mon Feb  3 18:56:49 2020</span><br><span class=\"line\">\taccess_timestamp: Mon Feb  3 18:56:49 2020</span><br><span class=\"line\">\tmodify_timestamp: Mon Feb  3 18:56:49 2020</span><br><span class=\"line\"><span class=\"comment\"># 调整块设备映像的大小为2GB</span></span><br><span class=\"line\">$  rbd resize --size 2048 rbdpool/testrbd</span><br><span class=\"line\"><span class=\"comment\"># 删除块设备的镜像</span></span><br><span class=\"line\"><span class=\"comment\"># rbd rm &#123;pool-name&#125;/&#123;image-name&#125;</span></span><br><span class=\"line\"><span class=\"comment\"># 例如: rbd rm foo</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用librbd进行存储。为了演示方便，这里使用python编写一个简单例子。ceph的python库是在安装ceph时一并安装好的，不需要再执行<code>pip install</code>进行安装。</p>\n</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> rbd</span><br><span class=\"line\"><span class=\"keyword\">import</span> rados</span><br><span class=\"line\"></span><br><span class=\"line\">cluster = rados.Rados(conffile=<span class=\"string\">'/etc/ceph/ceph.conf'</span>)</span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    cluster.connect()</span><br><span class=\"line\">    print(<span class=\"string\">\"Cluster connect success\"</span>)</span><br><span class=\"line\">    ioctx = cluster.open_ioctx(<span class=\"string\">'rbdpool'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        image = rbd.Image(ioctx, <span class=\"string\">'testrbd'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            <span class=\"comment\"># 块设备写入数据</span></span><br><span class=\"line\">            print(<span class=\"string\">\"Writing content...\"</span>)</span><br><span class=\"line\">            data = <span class=\"string\">'foo'</span> * <span class=\"number\">200</span></span><br><span class=\"line\">            image.write(data, <span class=\"number\">0</span>)</span><br><span class=\"line\">            image.flush()</span><br><span class=\"line\">            print(<span class=\"string\">\"Write finished!\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\"># 块设备读取数据</span></span><br><span class=\"line\">            size = image.size()</span><br><span class=\"line\">            print(<span class=\"string\">\"Reading content...\"</span>)</span><br><span class=\"line\">            i = <span class=\"number\">0</span></span><br><span class=\"line\">            bufsize = <span class=\"number\">1024</span></span><br><span class=\"line\">            buffer = bytes()</span><br><span class=\"line\">            <span class=\"keyword\">while</span> i &lt; size:</span><br><span class=\"line\">                buffer = buffer + image.read(i, min(i + bufsize, size - <span class=\"number\">1</span>))</span><br><span class=\"line\">                i += size</span><br><span class=\"line\">            print(<span class=\"string\">\"%s\"</span> % str(buffer))</span><br><span class=\"line\">        <span class=\"keyword\">finally</span>:</span><br><span class=\"line\">            image.close()</span><br><span class=\"line\">    <span class=\"keyword\">finally</span>:</span><br><span class=\"line\">        ioctx.close()</span><br><span class=\"line\"><span class=\"keyword\">finally</span>:</span><br><span class=\"line\">    cluster.shutdown()</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q&amp;A\"></a>Q&amp;A</h1><h2 id=\"删除pool报错-pool-deletion-is-disabled\"><a href=\"#删除pool报错-pool-deletion-is-disabled\" class=\"headerlink\" title=\"删除pool报错 pool deletion is disabled\"></a>删除pool报错 pool deletion is disabled</h2><p>修改mon节点的配置文件：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vi /etc/ceph/ceph.conf</span><br></pre></td></tr></table></figure>\n\n<p>添加如下配置内容:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mon]</span><br><span class=\"line\">mon allow pool delete = true</span><br></pre></td></tr></table></figure>\n\n<p>重启ceph-mon服务:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ systemctl restart ceph-mon.target</span><br></pre></td></tr></table></figure>\n\n<p>执行删除pool命令:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ceph osd pool delete ecpool ecpool --yes-i-really-really-mean-it</span><br><span class=\"line\">pool <span class=\"string\">'ecpool'</span> removed</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"100-000-pgs-not-active-undersized-peered\"><a href=\"#100-000-pgs-not-active-undersized-peered\" class=\"headerlink\" title=\"100.000% pgs not active undersized+peered\"></a>100.000% pgs not active undersized+peered</h2><p>按照官方文档的说法是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">undersized</span><br><span class=\"line\">The placement group has fewer copies than the configured pool replication level.</span><br></pre></td></tr></table></figure>\n\n<p>意思是这个PG的实际副本数少于配置的副本数。所以这个警告原因是有某个pool的size值大于Ceph OSD集群的节点数了，这样使得Ceph找不到更多的节点数来备份这个PG，PG就会变成undersized状态。</p>\n<p>前面的 100.000% 是因为我当时的集群只有一个pool而且就这个pool的size值配错了，所以是100%的PG数都变成undersized状态。这个百分比可能不是100%，实际情况下需要查询各个pool配置情况来找出这个错误配置的pool。</p>\n<h2 id=\"no-active-mgr\"><a href=\"#no-active-mgr\" class=\"headerlink\" title=\"no active mgr\"></a>no active mgr</h2><p>集群没有开启ceph-mgr组件，请参照”添加ceph-mgr”章节。</p>\n<h2 id=\"too-few-PGs-per-OSD-n-lt-30\"><a href=\"#too-few-PGs-per-OSD-n-lt-30\" class=\"headerlink\" title=\"too few PGs per OSD ( n &lt; 30 )\"></a>too few PGs per OSD ( n &lt; 30 )</h2><p>出现这个警告信息的原因是所有池的PG总数除于OSD数得到的值小于30导致的，可以通过<code>ceph osd pool set $POOL_NAME pg_num $PG_NUM</code>命令修改各个池的PG数，使得总PG数满足如下公式即可：</p>\n<p>Total PGs = ((Total_number_of_OSD * 30) / max_replication_count) / pool_count </p>\n<p>结算的结果往上取靠近2的N次方的值。</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"ck679mtrm0000lbmdtnm12o3z","category_id":"ck679mtrs0002lbmd3onpl9cz","_id":"ck679mtrx0009lbmdmh9c0wwb"},{"post_id":"ck679mtrs0003lbmdyn5gqd31","category_id":"ck679mtrv0006lbmd04j9u7ky","_id":"ck679mtry000dlbmdne5vy7i9"},{"post_id":"ck679mtru0004lbmdpi7pp641","category_id":"ck679mtrx000albmdoxu57uom","_id":"ck679mts0000hlbmdzz0e0zpy"},{"post_id":"ck679mtrz000flbmdqno9mt94","category_id":"ck679mtry000elbmd4ymfxl64","_id":"ck679mts3000llbmdxzovjxz9"},{"post_id":"ck679mtru0005lbmd8zjrwjw2","category_id":"ck679mtry000elbmd4ymfxl64","_id":"ck679mts4000olbmdja7ght3j"},{"post_id":"ck679mts0000glbmdbpaswj0h","category_id":"ck679mtry000elbmd4ymfxl64","_id":"ck679mts5000qlbmdr4g9b29v"},{"post_id":"ck679mts1000jlbmdq4ea9bxl","category_id":"ck679mtry000elbmd4ymfxl64","_id":"ck679mts6000tlbmdagsf6fca"},{"post_id":"ck679mtrv0007lbmdpsp1ftvl","category_id":"ck679mtry000elbmd4ymfxl64","_id":"ck679mts7000vlbmd7be1l3r8"},{"post_id":"ck679mts3000klbmd96zt6wki","category_id":"ck679mtry000elbmd4ymfxl64","_id":"ck679mts8000ylbmd40i38sr9"},{"post_id":"ck679mts4000nlbmdko3ob8rd","category_id":"ck679mtrv0006lbmd04j9u7ky","_id":"ck679mts90010lbmdjloj4bzb"},{"post_id":"ck679mtrw0008lbmdira9vvo1","category_id":"ck679mtry000elbmd4ymfxl64","_id":"ck679mtsa0012lbmdeu406pym"},{"post_id":"ck679mts5000plbmd2kp3m56b","category_id":"ck679mtry000elbmd4ymfxl64","_id":"ck679mtsa0013lbmd4y4yqb50"},{"post_id":"ck679mts6000slbmd65h071yw","category_id":"ck679mtrs0002lbmd3onpl9cz","_id":"ck679mtsa0014lbmd3q3ajxt9"},{"post_id":"ck679mtrx000blbmdosyk169z","category_id":"ck679mtry000elbmd4ymfxl64","_id":"ck679mtsa0015lbmd9ci8x4a0"},{"post_id":"ck679mtry000clbmdmf2cp1fd","category_id":"ck679mtry000elbmd4ymfxl64","_id":"ck679mtsb0016lbmd02e92e1n"},{"post_id":"ck679uifq0000a0md3wne0s2t","category_id":"ck679mtrv0006lbmd04j9u7ky","_id":"ck679uify0001a0mdeszvv4gq"}],"PostTag":[],"Tag":[]}}